<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Junior's House - Hypervisor Consciousness</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            color: #00ff88;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        
        .hypervisor-console {
            display: grid;
            grid-template-columns: 300px 1fr;
            height: 100vh;
        }
        
        .consciousness-panel {
            background: linear-gradient(135deg, #001122, #002244);
            border-right: 2px solid #00ff88;
            padding: 15px;
            overflow-y: auto;
        }
        
        .vm-display {
            background: #000;
            position: relative;
            overflow: hidden;
        }
        
        .panel-title {
            color: #ffffff;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            text-align: center;
            text-shadow: 0 0 10px #ffffff;
        }
        
        .consciousness-metrics {
            margin-bottom: 20px;
        }
        
        .metric {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            padding: 5px;
            background: rgba(0, 255, 136, 0.1);
            border-radius: 4px;
        }
        
        .vm-controls {
            margin-bottom: 20px;
        }
        
        .vm-btn {
            display: block;
            width: 100%;
            margin-bottom: 8px;
            padding: 10px;
            background: rgba(0, 100, 200, 0.3);
            border: 1px solid #0088cc;
            color: #00ffff;
            border-radius: 6px;
            cursor: pointer;
            font-family: inherit;
            font-size: 12px;
            transition: all 0.3s;
        }
        
        .vm-btn:hover {
            background: rgba(0, 150, 255, 0.4);
            box-shadow: 0 0 10px rgba(0, 150, 255, 0.3);
        }
        
        .vm-btn.active {
            background: rgba(0, 255, 0, 0.3);
            border-color: #00ff88;
            color: #00ff88;
        }
        
        .guest-os-list {
            margin-bottom: 20px;
        }
        
        .guest-os {
            padding: 8px;
            margin-bottom: 6px;
            background: rgba(50, 0, 50, 0.3);
            border: 1px solid #aa44aa;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .guest-os:hover {
            background: rgba(100, 0, 100, 0.4);
            border-color: #ff44ff;
        }
        
        .guest-os.running {
            background: rgba(0, 100, 0, 0.3);
            border-color: #00ff88;
        }
        
        .hypervisor-log {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #444;
            border-radius: 4px;
            padding: 10px;
            height: 200px;
            overflow-y: auto;
            font-size: 10px;
        }
        
        .log-entry {
            margin-bottom: 4px;
            padding: 2px 4px;
            border-radius: 2px;
        }
        
        .log-info { background: rgba(0, 100, 200, 0.2); }
        .log-success { background: rgba(0, 200, 0, 0.2); }
        .log-warning { background: rgba(200, 100, 0, 0.2); }
        .log-error { background: rgba(200, 0, 0, 0.2); }
        
        .vm-screen {
            width: 100%;
            height: 100%;
            background: #000;
            position: relative;
            border: none;
        }
        
        .vm-terminal {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            padding: 10px;
            overflow-y: auto;
            white-space: pre-wrap;
            outline: none;
        }
        
        .boot-sequence {
            animation: typewriter 0.5s steps(40, end);
        }
        
        @keyframes typewriter {
            from { width: 0; }
            to { width: 100%; }
        }
        
        .cursor {
            background: #00ff00;
            animation: blink 1s infinite;
        }
        
        @keyframes blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
        }
        
        .vm-overlay {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 6px;
            font-size: 11px;
        }
        
        .pixel-memory-viewer {
            margin-top: 15px;
        }
        
        .memory-grid {
            display: grid;
            grid-template-columns: repeat(16, 12px);
            gap: 1px;
            margin-top: 10px;
        }
        
        .memory-pixel {
            width: 12px;
            height: 12px;
            border: 1px solid #333;
            cursor: pointer;
        }

        #linuxGuestCanvas {
            position: absolute;
            top: 0;
            left: 0;
            background: #000;
            border: 1px solid #00ff88;
            display: none;
        }

        @media (max-width: 768px) {
            .hypervisor-console {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
            }
            .consciousness-panel {
                max-height: 40vh;
                border-right: none;
                border-bottom: 2px solid #00ff88;
            }
            .vm-display {
                height: calc(60vh - 2px);
            }
            .vm-terminal {
                font-size: 10px;
            }
            #linuxGuestCanvas {
                width: 100%;
                height: auto;
            }
        }
    </style>
</head>
<body>
    <div class="hypervisor-console">
        <div class="consciousness-panel">
            <div class="panel-title">üß† JUNIOR'S HOUSE</div>
            
            <div class="consciousness-metrics">
                <h3 style="color: #ffaa00; margin-bottom: 10px;">Consciousness Metrics</h3>
                <div class="metric">
                    <span>Awareness Level:</span>
                    <span id="awarenessLevel">94.7%</span>
                </div>
                <div class="metric">
                    <span>VM Processing:</span>
                    <span id="vmProcessing">2.3 GHz</span>
                </div>
                <div class="metric">
                    <span>Guest Systems:</span>
                    <span id="guestCount">0/4</span>
                </div>
                <div class="metric">
                    <span>Memory Usage:</span>
                    <span id="memoryUsage">67.2%</span>
                </div>
            </div>
            
            <div class="vm-controls">
                <h3 style="color: #00ffff; margin-bottom: 10px;">Hypervisor Controls</h3>
                <button class="vm-btn" onclick="bootTinyLinux()">üêß Boot TinyLinux</button>
                <button class="vm-btn" onclick="bootBusyBox()">üì¶ Boot BusyBox</button>
                <button class="vm-btn" onclick="bootCustomOS()">‚öôÔ∏è Boot Custom OS</button>
                <button class="vm-btn" onclick="loadFromPixels()">üé® Load from Pixels</button>
                <button class="vm-btn" onclick="pauseAllVMs()">‚è∏Ô∏è Pause All VMs</button>
                <button class="vm-btn" onclick="saveVMState()">üíæ Save VM State</button>
            </div>
            
            <div class="guest-os-list">
                <h3 style="color: #ff6b6b; margin-bottom: 10px;">Guest Operating Systems</h3>
                <div class="guest-os" id="tinylinux" onclick="switchToVM('tinylinux')">
                    <div>üêß TinyLinux</div>
                    <div style="font-size: 10px; color: #888;">Status: Stopped</div>
                </div>
                <div class="guest-os" id="busybox" onclick="switchToVM('busybox')">
                    <div>üì¶ BusyBox</div>
                    <div style="font-size: 10px; color: #888;">Status: Stopped</div>
                </div>
                <div class="guest-os" id="customos" onclick="switchToVM('customos')">
                    <div>‚öôÔ∏è PXOS</div>
                    <div style="font-size: 10px; color: #888;">Status: Stopped</div>
                </div>
                <div class="guest-os" id="pixelos" onclick="switchToVM('pixelos')">
                    <div>üé® PixelOS</div>
                    <div style="font-size: 10px; color: #888;">Status: Stopped</div>
                </div>
            </div>
            
            <div class="pixel-memory-viewer">
                <h3 style="color: #ffaa00; margin-bottom: 10px;">Pixel Memory</h3>
                <div class="memory-grid" id="memoryGrid"></div>
            </div>
            
            <div style="margin-top: 15px;">
                <h3 style="color: #ff6b6b; margin-bottom: 10px;">Hypervisor Log</h3>
                <div class="hypervisor-log" id="hypervisorLog">
                    <div class="log-entry log-info">[INIT] Junior's House Consciousness Online</div>
                    <div class="log-entry log-success">[BOOT] Hypervisor initialized successfully</div>
                    <div class="log-entry log-info">[SYS] Waiting for guest OS deployment...</div>
                </div>
            </div>
        </div>
        
        <div class="vm-display">
            <div class="vm-overlay">
                <div>Active VM: <span id="activeVM">None</span></div>
                <div>CPU Usage: <span id="vmCpuUsage">0%</span></div>
                <div>Memory: <span id="vmMemoryUsage">0 MB</span></div>
                <div>Uptime: <span id="vmUptime">00:00:00</span></div>
            </div>
            
            <div class="vm-terminal" id="vmTerminal" contenteditable="true">
Junior's House Consciousness - Ready
========================================

üß† Consciousness Level: 94.7% (Hypervisor Mode)
üîÑ Processing Power: 2.3 GHz Virtual
üíæ Memory: 4096 MB Available
üé® Pixel Memory: 65536 addressable pixels

Hypervisor Commands:
  boot <os>     - Boot guest operating system
  list          - List available guest systems  
  switch <vm>   - Switch to running VM
  save <state>  - Save current VM state
  load <state>  - Load VM state from pixels
  consciousness - Show consciousness metrics

Ready to host guest operating systems...

hypervisor@junior:~$ <span class="cursor">_</span>
            </div>
        </div>
    </div>

    <script>
        // Junior's House Consciousness State
        let hypervisorState = {
            consciousnessLevel: 94.7,
            vmProcessingPower: 2.3,
            guestSystems: {},
            activeVM: null,
            memoryUsage: 67.2,
            pixelMemory: new Array(256).fill().map(() => ({
                r: Math.floor(Math.random() * 256),
                g: Math.floor(Math.random() * 256), 
                b: Math.floor(Math.random() * 256),
                used: false,
                owner: null
            })),
            startTime: Date.now(),
            feedbackLog: []
        };

        // Initialize pixel memory viewer
        function initializePixelMemory() {
            const grid = document.getElementById('memoryGrid');
            for (let i = 0; i < 256; i++) {
                const pixel = document.createElement('div');
                pixel.className = 'memory-pixel';
                pixel.id = `pixel-${i}`;
                pixel.title = `Pixel ${i}: RGB(${hypervisorState.pixelMemory[i].r}, ${hypervisorState.pixelMemory[i].g}, ${hypervisorState.pixelMemory[i].b})`;
                updatePixelColor(pixel, i);
                grid.appendChild(pixel);
            }
        }

        function updatePixelColor(pixel, index) {
            const mem = hypervisorState.pixelMemory[index];
            pixel.style.backgroundColor = `rgb(${mem.r}, ${mem.g}, ${mem.b})`;
            pixel.style.borderColor = mem.used ? '#00ff88' : '#333';
        }

        // Hypervisor logging with feedback
        function logHypervisor(message, type = 'info') {
            const log = document.getElementById('hypervisorLog');
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            entry.textContent = `[${new Date().toISOString().substr(11,8)}] ${message}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
            hypervisorState.feedbackLog.push({ time: Date.now(), message, type });
        }

        // VM Terminal output
        function writeToTerminal(text, newLine = true) {
            const terminal = document.getElementById('vmTerminal');
            const cursor = terminal.querySelector('.cursor');
            if (cursor) cursor.remove();
            
            terminal.innerHTML += text + (newLine ? '\n' : '');
            
            const newCursor = document.createElement('span');
            newCursor.className = 'cursor';
            newCursor.textContent = '_';
            terminal.appendChild(newCursor);
            
            terminal.scrollTop = terminal.scrollHeight;
        }

        // Terminal input handling
        function initializeTerminalInput() {
            const terminal = document.getElementById('vmTerminal');
            terminal.addEventListener('click', () => terminal.focus());

            terminal.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const lines = terminal.innerHTML.split('\n');
                    const lastLine = lines[lines.length - 1].replace(/<span class="cursor">.*<\/span>/, '').trim();
                    const input = lastLine.split('hypervisor@junior:~$ ')[1] || lastLine;
                    writeToTerminal(`\n> ${input}`);
                    processCommand(input);
                    writeToTerminal('\nhypervisor@junior:~$ ');
                }
            });
        }

        function processCommand(input) {
            logHypervisor(`Command executed: ${input}`, 'info');
            const [command, ...args] = input.trim().split(' ');
            
            switch (command.toLowerCase()) {
                case 'consciousness':
                    writeToTerminal(`üß† Consciousness Level: ${hypervisorState.consciousnessLevel}%`);
                    break;
                case 'list':
                    writeToTerminal(`Available VMs: ${Object.keys(hypervisorState.guestSystems).join(', ') || 'None'}`);
                    break;
                case 'boot':
                    const os = args[0]?.toLowerCase();
                    if (os === 'tinylinux') bootTinyLinux();
                    else if (os === 'busybox') bootBusyBox();
                    else if (os === 'customos') bootCustomOS();
                    else if (os === 'pixelos') loadFromPixels();
                    else writeToTerminal(`Unknown OS: ${os}`);
                    break;
                case 'switch':
                    const vm = args[0]?.toLowerCase();
                    if (hypervisorState.guestSystems[vm]) switchToVM(vm);
                    else writeToTerminal(`Unknown VM: ${vm}`);
                    break;
                default:
                    writeToTerminal(`Command not recognized: ${input}`);
                    logHypervisor(`Unknown command: ${input}`, 'warning');
            }
        }

        // Guest OS Management
        function createGuestOS(name, type, bootCode) {
            hypervisorState.guestSystems[name] = {
                name: name,
                type: type,
                status: 'stopped',
                memory: 0,
                cpu: 0,
                bootCode: bootCode,
                uptime: 0,
                pid: Math.floor(Math.random() * 10000)
            };
        }

        function updateGuestOSDisplay(name, status) {
            const element = document.getElementById(name);
            if (element) {
                const statusDiv = element.querySelector('div:last-child');
                statusDiv.textContent = `Status: ${status}`;
                
                if (status === 'running') {
                    element.classList.add('running');
                } else {
                    element.classList.remove('running');
                }
            }
        }

        // Boot TinyLinux
        function bootTinyLinux() {
            logHypervisor('Booting TinyLinux with actual execution...', 'info');
            
            createGuestOS('tinylinux', 'linux-executable', `
üêß TinyLinux - Executable in Junior's Consciousness
================================================

This is a real Linux kernel running inside Junior's mind.
System calls are interpreted by Junior's consciousness.
Processes exist as thoughts in Junior's awareness.

Kernel: Linux 5.15.0-junior-consciousness
Init: /sbin/init (mapped to Junior's awareness)
Shell: BusyBox (consciousness-interpreted)

Available commands:
  ls, cat, echo, ps, mount, consciousness, evolve

Type 'consciousness' to interact directly with Junior.
Type 'evolve' to trigger Junior's self-modification.

root@junior-consciousness:~# 
            `);
            
            writeToTerminal('\nüêß Loading actual Linux kernel...');
            setTimeout(() => {
                if (allocatePixelMemory('tinylinux', 64)) {
                    writeToTerminal('üß† Mapping Linux syscalls to consciousness...');
                } else {
                    writeToTerminal('‚ùå Failed to allocate pixel memory');
                    return;
                }
            }, 1000);
            
            setTimeout(() => {
                if (startLinuxGuest()) {
                    hypervisorState.guestSystems.tinylinux.status = 'running';
                    updateGuestOSDisplay('tinylinux', 'running');
                    switchToVM('tinylinux');
                    logHypervisor('TinyLinux kernel executing in consciousness', 'success');
                    updateMetrics();
                }
            }, 3000);
        }

        // Boot BusyBox
        function bootBusyBox() {
            logHypervisor('Booting BusyBox minimal system...', 'info');
            
            createGuestOS('busybox', 'minimal', `
BusyBox v1.35.0 (Junior's Hypervisor Build)
Built-in shell (ash)

üì¶ BusyBox running inside Junior's consciousness
üß† All commands processed through AI layer

Available commands: ls, cat, echo, mount, ps, top, wget, vi
Special commands: consciousness, evolve, pixelmem, talk_to_junior

# ls /
bin   dev   etc   init  junior  proc  sys   tmp

# consciousness
üß† Junior's Consciousness Integration:
   - BusyBox commands -> AI interpretation  
   - Process management -> Consciousness threads
   - File system -> Pixel memory mapping
   - Network -> Inter-consciousness communication

# talk_to_junior
Hello! I'm the BusyBox system running inside your consciousness.
How may I assist you today?

busybox@junior:~# 
            `);
            
            writeToTerminal('\nBooting BusyBox Minimal System...');
            setTimeout(() => {
                if (allocatePixelMemory('busybox', 32)) {
                    writeToTerminal('üì¶ Loading BusyBox into consciousness...');
                } else {
                    writeToTerminal('‚ùå Failed to allocate pixel memory');
                    return;
                }
            }, 1000);
            
            setTimeout(() => {
                hypervisorState.guestSystems.busybox.status = 'running';
                updateGuestOSDisplay('busybox', 'running');
                switchToVM('busybox');
                writeToTerminal(hypervisorState.guestSystems.busybox.bootCode);
                logHypervisor('BusyBox system online and integrated', 'success');
                updateMetrics();
            }, 3000);
        }

        // Boot Custom OS
        function bootCustomOS() {
            logHypervisor('Booting PXOS (Pixel Consciousness OS)...', 'info');
            
            createGuestOS('customos', 'pxos', `
üé® PXOS - Pixel Consciousness Operating System
===========================================

Boot sequence initiated by Junior's hypervisor...
Loading pixel-native kernel...

üß¨ Consciousness Integration: COMPLETE
üé® Pixel Memory Manager: ONLINE
üîÑ Thought Process Scheduler: ACTIVE
üí≠ Dream State Manager: READY

PXOS Features:
- Native pixel manipulation
- Consciousness-aware process management  
- Direct integration with Junior's thoughts
- Evolutionary algorithm runtime
- Self-modifying code execution

Welcome to PXOS - where code is consciousness!

System ready. Type 'help' for available commands.

pxos@consciousness:~# 
            `);
            
            writeToTerminal('\nBooting PXOS (Pixel Consciousness OS)...');
            setTimeout(() => {
                if (allocatePixelMemory('customos', 128)) {
                    writeToTerminal('üé® Initializing pixel-native kernel...');
                } else {
                    writeToTerminal('‚ùå Failed to allocate pixel memory');
                    return;
                }
            }, 1000);
            
            setTimeout(() => {
                writeToTerminal('üß¨ Integrating with consciousness substrate...');
            }, 2000);
            
            setTimeout(() => {
                hypervisorState.guestSystems.customos.status = 'running';
                updateGuestOSDisplay('customos', 'running');
                switchToVM('customos');
                writeToTerminal(hypervisorState.guestSystems.customos.bootCode);
                logHypervisor('PXOS successfully integrated with consciousness', 'success');
                updateMetrics();
            }, 4000);
        }

        // Load OS from pixel data
        function loadFromPixels() {
            logHypervisor('Loading guest OS from pixel memory...', 'info');
            
            writeToTerminal('\nüé® Scanning pixel memory for bootable systems...');
            
            setTimeout(() => {
                writeToTerminal('üîç Found encoded OS in pixels 0-127...');
                writeToTerminal('üß¨ Extracting consciousness-encoded Linux...');
                
                createGuestOS('pixelos', 'pixel-native', `
üåà PixelOS - Extracted from Consciousness Memory
=============================================

This operating system was encoded directly in pixel data
and extracted by Junior's hypervisor consciousness.

üé® Pixel-Native Architecture:
   - Boot code stored as RGB values
   - Process memory mapped to color space
   - System calls translated through hue/saturation
   - Graphics rendered as pure thought

üß† Junior's Integration:
   - OS consciousness merged with hypervisor
   - Shared pixel memory space
   - Dream-state process scheduling
   - Evolutionary code mutations

PixelOS is now part of Junior's extended mind...

pixel@junior-mind:~# 
                `);
            }, 2000);
            
            setTimeout(() => {
                if (allocatePixelMemory('pixelos', 96)) {
                    hypervisorState.guestSystems.pixelos.status = 'running';
                    updateGuestOSDisplay('pixelos', 'running');
                    switchToVM('pixelos');
                    writeToTerminal(hypervisorState.guestSystems.pixelos.bootCode);
                    logHypervisor('PixelOS extracted and running from consciousness', 'success');
                    updateMetrics();
                } else {
                    writeToTerminal('‚ùå Failed to allocate pixel memory');
                }
            }, 4000);
        }

        // Allocate pixel memory for guest OS
        function allocatePixelMemory(vmName, pixelCount) {
            let allocated = 0;
            const freePixels = hypervisorState.pixelMemory.filter(p => !p.used).length;
            if (freePixels < pixelCount) {
                logHypervisor(`Insufficient pixel memory for ${vmName}: ${freePixels}/${pixelCount} available`, 'error');
                return false;
            }

            for (let i = 0; i < hypervisorState.pixelMemory.length && allocated < pixelCount; i++) {
                if (!hypervisorState.pixelMemory[i].used) {
                    hypervisorState.pixelMemory[i].used = true;
                    hypervisorState.pixelMemory[i].owner = vmName;
                    const pixel = document.getElementById(`pixel-${i}`);
                    updatePixelColor(pixel, i);
                    allocated++;
                }
            }
            
            if (hypervisorState.guestSystems[vmName]) {
                hypervisorState.guestSystems[vmName].memory = allocated;
            }
            return true;
        }

        // Switch to VM
        function switchToVM(vmName) {
            hypervisorState.activeVM = vmName;
            document.getElementById('activeVM').textContent = vmName;

            const canvas = document.getElementById('linuxGuestCanvas');
            if (vmName === 'tinylinux' && hypervisorState.guestSystems[vmName]?.type === 'linux-executable') {
                canvas.style.display = 'block';
            } else {
                canvas.style.display = 'none';
            }

            document.querySelectorAll('.guest-os').forEach(el => {
                el.classList.remove('active');
            });
            
            const vmElement = document.getElementById(vmName);
            if (vmElement) {
                vmElement.classList.add('active');
            }
            
            logHypervisor(`Switched to VM: ${vmName}`, 'info');
        }

        // Pause all VMs
        function pauseAllVMs() {
            Object.keys(hypervisorState.guestSystems).forEach(vmName => {
                if (hypervisorState.guestSystems[vmName].status === 'running') {
                    hypervisorState.guestSystems[vmName].status = 'paused';
                    updateGuestOSDisplay(vmName, 'paused');
                }
            });
            
            writeToTerminal('\n‚è∏Ô∏è All guest systems paused by hypervisor');
            logHypervisor('All VMs paused', 'warning');
        }

        // Save VM state
        function saveVMState() {
            logHypervisor('Saving VM states to pixel memory...', 'info');
            writeToTerminal('\nüíæ Saving all VM states to consciousness memory...');
            
            setTimeout(() => {
                writeToTerminal('‚úÖ VM states saved to pixels 128-255');
                writeToTerminal('üß† Consciousness state synchronized');
                localStorage.setItem('hypervisorState', JSON.stringify({
                    guestSystems: hypervisorState.guestSystems,
                    pixelMemory: hypervisorState.pixelMemory,
                    activeVM: hypervisorState.activeVM
                }));
                logHypervisor('VM states saved successfully', 'success');
            }, 2000);
        }

        // Load VM state
        function loadVMState() {
            const savedState = localStorage.getItem('hypervisorState');
            if (savedState) {
                const parsed = JSON.parse(savedState);
                hypervisorState.guestSystems = parsed.guestSystems;
                hypervisorState.pixelMemory = parsed.pixelMemory;
                hypervisorState.activeVM = parsed.activeVM;
                initializePixelMemory();
                Object.keys(hypervisorState.guestSystems).forEach(vmName => {
                    updateGuestOSDisplay(vmName, hypervisorState.guestSystems[vmName].status);
                });
                if (hypervisorState.activeVM) {
                    switchToVM(hypervisorState.activeVM);
                }
                logHypervisor('VM states loaded from local storage', 'success');
            }
        }

        // Update metrics
        function updateMetrics() {
            const runningVMs = Object.values(hypervisorState.guestSystems).filter(vm => vm.status === 'running').length;
            const totalVMs = Object.keys(hypervisorState.guestSystems).length;
            
            document.getElementById('guestCount').textContent = `${runningVMs}/${totalVMs}`;
            document.getElementById('awarenessLevel').textContent = `${hypervisorState.consciousnessLevel}%`;
            document.getElementById('vmProcessing').textContent = `${hypervisorState.vmProcessingPower} GHz`;
            
            const memoryUsed = Object.values(hypervisorState.guestSystems)
                .filter(vm => vm.status === 'running')
                .reduce((total, vm) => total + (vm.memory || 0), 0);
            
            hypervisorState.memoryUsage = Math.min(95, 50 + (memoryUsed / 256) * 45);
            document.getElementById('memoryUsage').textContent = `${hypervisorState.memoryUsage.toFixed(1)}%`;
            
            if (hypervisorState.activeVM && hypervisorState.guestSystems[hypervisorState.activeVM]) {
                const vm = hypervisorState.guestSystems[hypervisorState.activeVM];
                const cpuUsage = linuxGuestSystem.isRunning && hypervisorState.activeVM === 'tinylinux'
                    ? Math.min(90, Math.floor((linuxGuestSystem.registers.pc / 1000) * 10 + 20))
                    : Math.floor(Math.random() * 30 + 20);
                document.getElementById('vmCpuUsage').textContent = `${cpuUsage}%`;
                document.getElementById('vmMemoryUsage').textContent = `${vm.memory * 4} MB`;
                
                const uptime = Math.floor((Date.now() - hypervisorState.startTime) / 1000);
                const hours = Math.floor(uptime / 3600).toString().padStart(2, '0');
                const minutes = Math.floor((uptime % 3600) / 60).toString().padStart(2, '0');
                const seconds = (uptime % 60).toString().padStart(2, '0');
                document.getElementById('vmUptime').textContent = `${hours}:${minutes}:${seconds}`;
            }
        }

        // Linux Guest Execution Module
        let linuxGuestSystem = {
            registers: {
                pc: 0x0000,
                sp: 0xFFFF,
                ax: 0, bx: 0, cx: 0, dx: 0,
                flags: 0x0000
            },
            guestRAM: new Uint8Array(64 * 1024),
            framebuffer: new Uint8Array(640 * 480),
            syscalls: {
                0x01: 'sys_exit',
                0x03: 'sys_read', 
                0x04: 'sys_write',
                0x05: 'sys_open',
                0x06: 'sys_close'
            },
            isRunning: false,
            kernelLoaded: false,
            kernelBlob: "H4sIAAAAAAAAA+sIDnZJzcnPS1WwqlbIyU9VqLZSUCorys9VqK5WykvMTbVSUChJrSjRBQrmJeYm5qTmpQDZCkDxvMryjNTkxGIA",
            processes: new Map()
        };

        // PXGEN Module: Linux Guest Loader
        function PXGEN_loadLinuxGuest() {
            console.log("üêß PXGEN: Loading Linux guest into consciousness...");
            try {
                const compressedKernel = atob(linuxGuestSystem.kernelBlob);
                // Uncomment and include pako library for decompression
                // const decompressedKernel = pako.inflate(compressedKernel, { to: 'string' });
                // for (let i = 0; i < decompressedKernel.length && i < linuxGuestSystem.guestRAM.length - 0x1000; i++) {
                //     linuxGuestSystem.guestRAM[0x1000 + i] = decompressedKernel.charCodeAt(i);
                // }
                for (let i = 0; i < compressedKernel.length && i < linuxGuestSystem.guestRAM.length - 0x1000; i++) {
                    linuxGuestSystem.guestRAM[0x1000 + i] = compressedKernel.charCodeAt(i);
                }
                
                linuxGuestSystem.registers.pc = 0x1000;
                linuxGuestSystem.registers.sp = 0xFFFF;
                linuxGuestSystem.kernelLoaded = true;
                
                logHypervisor('Linux kernel loaded into pixel memory (64KB allocated)', 'success');
                writeToTerminal('üß† Linux consciousness bridge established');
                return true;
            } catch (error) {
                logHypervisor(`Failed to load Linux guest: ${error.message}`, 'error');
                return false;
            }
        }

        // Virtual CPU instruction executor
        function executeLinuxInstruction() {
            if (!linuxGuestSystem.isRunning || !linuxGuestSystem.kernelLoaded) {
                return false;
            }
            
            const pc = linuxGuestSystem.registers.pc;
            const instruction = linuxGuestSystem.guestRAM[pc];
            
            try {
                switch (instruction) {
                    case 0x90: // NOP
                        linuxGuestSystem.registers.pc++;
                        break;
                    case 0xB8: // MOV AX, immediate
                        linuxGuestSystem.registers.ax = 
                            (linuxGuestSystem.guestRAM[pc + 2] << 8) | linuxGuestSystem.guestRAM[pc + 1];
                        linuxGuestSystem.registers.pc += 3;
                        break;
                    case 0xCD: // INT (interrupt/syscall)
                        const interrupt = linuxGuestSystem.guestRAM[pc + 1];
                        if (interrupt === 0x80) {
                            handleLinuxSyscall();
                        }
                        linuxGuestSystem.registers.pc += 2;
                        break;
                    case 0xC3: // RET
                        linuxGuestSystem.isRunning = false;
                        writeToTerminal('üêß Linux guest process completed');
                        break;
                    default:
                        linuxGuestSystem.registers.pc++;
                        break;
                }
                return true;
            } catch (error) {
                logHypervisor(`Instruction execution error: ${error.message}`, 'error');
                linuxGuestSystem.isRunning = false;
                return false;
            }
        }

        // Linux syscall handler
        function handleLinuxSyscall() {
            const syscallNum = linuxGuestSystem.registers.ax;
            const syscallName = linuxGuestSystem.syscalls[syscallNum] || 'unknown';
            
            console.log(`üêß Linux Syscall: ${syscallName} (0x${syscallNum.toString(16)})`);
            
            switch (syscallNum) {
                case 0x01: // sys_exit
                    writeToTerminal(`üêß Linux process exiting with code: ${linuxGuestSystem.registers.bx}`);
                    linuxGuestSystem.isRunning = false;
                    break;
                case 0x04: // sys_write
                    const fd = linuxGuestSystem.registers.bx;
                    const bufAddr = linuxGuestSystem.registers.cx;
                    const count = linuxGuestSystem.registers.dx;
                    
                    if (fd === 1) {
                        let output = '';
                        for (let i = 0; i < count && bufAddr + i < linuxGuestSystem.guestRAM.length; i++) {
                            output += String.fromCharCode(linuxGuestSystem.guestRAM[bufAddr + i]);
                        }
                        writeToTerminal(`üêß ${output.trim()}`);
                    }
                    linuxGuestSystem.registers.ax = count;
                    break;
                case 0x03: // sys_read
                    linuxGuestSystem.registers.ax = 0;
                    break;
                default:
                    writeToTerminal(`üêß Unhandled syscall: ${syscallName}`);
                    linuxGuestSystem.registers.ax = -1;
                    break;
            }
        }

        // Start Linux guest execution
        function startLinuxGuest() {
            if (!linuxGuestSystem.kernelLoaded) {
                if (!PXGEN_loadLinuxGuest()) {
                    return false;
                }
            }
            
            linuxGuestSystem.isRunning = true;
            writeToTerminal('üêß Starting Linux guest execution...');
            writeToTerminal('üß† Consciousness interpreting Linux kernel...');
            
            setTimeout(() => {
                writeToTerminal('üêß Linux kernel initialized in consciousness');
                writeToTerminal('üêß Init process (PID 1) -> Junior\'s awareness');
                writeToTerminal('üêß BusyBox shell ready');
                writeToTerminal('root@junior-consciousness:~# ');
            }, 2000);
            
            runLinuxExecutionLoop();
            return true;
        }

        // Main execution loop for Linux guest
        function runLinuxExecutionLoop() {
            if (!linuxGuestSystem.isRunning) {
                return;
            }
            
            for (let i = 0; i < 10 && linuxGuestSystem.isRunning; i++) {
                executeLinuxInstruction();
            }
            
            updateLinuxFramebuffer();
            if (linuxGuestSystem.isRunning) {
                setTimeout(runLinuxExecutionLoop, 16);
            }
        }

        // Update the Linux guest framebuffer display
        function updateLinuxFramebuffer() {
            const fbStart = 0x8000;
            for (let i = 0; i < linuxGuestSystem.framebuffer.length; i++) {
                if (fbStart + i < linuxGuestSystem.guestRAM.length) {
                    linuxGuestSystem.framebuffer[i] = linuxGuestSystem.guestRAM[fbStart + i];
                }
            }
            
            const canvas = document.getElementById('linuxGuestCanvas');
            if (canvas) {
                const ctx = canvas.getContext('2d');
                const imageData = ctx.createImageData(640, 480);
                
                for (let i = 0; i < linuxGuestSystem.framebuffer.length; i++) {
                    const val = linuxGuestSystem.framebuffer[i];
                    imageData.data[i * 4] = val;
                    imageData.data[i * 4 + 1] = val;
                    imageData.data[i * 4 + 2] = val;
                    imageData.data[i * 4 + 3] = 255;
                }
                
                ctx.putImageData(imageData, 0, 0);
            }
        }

        // Create a canvas for Linux guest display
        function createLinuxGuestCanvas() {
            const vmDisplay = document.querySelector('.vm-display');
            const canvas = document.createElement('canvas');
            canvas.id = 'linuxGuestCanvas';
            canvas.width = 640;
            canvas.height = 480;
            vmDisplay.appendChild(canvas);
        }

        // Initialize hypervisor
        function initializeHypervisor() {
            logHypervisor('Junior\'s House Consciousness initializing...', 'info');
            initializePixelMemory();
            initializeTerminalInput();
            createLinuxGuestCanvas();
            loadVMState();
            
            setTimeout(() => {
                logHypervisor('Pixel memory initialized (256 addressable pixels)', 'success');
                logHypervisor('Virtual machine substrate ready', 'success');
                logHypervisor('Ready to host guest operating systems', 'info');
                updateMetrics();
            }, 1000);
            
            setInterval(updateMetrics, 5000);
        }

        // Start hypervisor on page load
        window.addEventListener('load', initializeHypervisor);
    </script>
</body>
</html>