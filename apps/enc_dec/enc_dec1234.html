<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
Â  <title>PXDigest Lab â€“ Data Digester</title>
Â  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
Â  <style>
Â  Â  body {Â 
Â  Â  Â  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;Â 
Â  Â  Â  padding: 2rem;Â 
Â  Â  Â  background: linear-gradient(135deg, #0f0f23, #1a1a3a);Â 
Â  Â  Â  color: #e0e0e0;Â 
Â  Â  Â  margin: 0;
Â  Â  Â  min-height: 100vh;
Â  Â  }
Â  Â Â 
Â  Â  h1 {
Â  Â  Â  text-align: center;
Â  Â  Â  color: #00ff88;
Â  Â  Â  text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
Â  Â  Â  margin-bottom: 2rem;
Â  Â  }
Â  Â Â 
Â  Â  .container {
Â  Â  Â  max-width: 1200px;
Â  Â  Â  margin: 0 auto;
Â  Â  }
Â  Â Â 
Â  Â  .upload-section {
Â  Â  Â  background: rgba(255, 255, 255, 0.05);
Â  Â  Â  border: 2px dashed #00ff88;
Â  Â  Â  border-radius: 10px;
Â  Â  Â  padding: 2rem;
Â  Â  Â  text-align: center;
Â  Â  Â  margin-bottom: 2rem;
Â  Â  Â  transition: all 0.3s ease;
Â  Â  }
Â  Â Â 
Â  Â  .upload-section:hover {
Â  Â  Â  background: rgba(0, 255, 136, 0.1);
Â  Â  Â  border-color: #00ffaa;
Â  Â  }
Â  Â Â 
Â  Â  input[type="file"] {
Â  Â  Â  background: #2a2a4a;
Â  Â  Â  color: #e0e0e0;
Â  Â  Â  border: 1px solid #444;
Â  Â  Â  border-radius: 5px;
Â  Â  Â  padding: 0.5rem;
Â  Â  Â  margin: 0.5rem;
Â  Â  }
Â  Â Â 
Â  Â  .controls {Â 
Â  Â  Â  display: flex;
Â  Â  Â  flex-wrap: wrap;
Â  Â  Â  gap: 1rem;
Â  Â  Â  margin: 2rem 0;
Â  Â  Â  justify-content: center;
Â  Â  }
Â  Â Â 
Â  Â  button {
Â  Â  Â  background: linear-gradient(45deg, #00ff88, #00cc66);
Â  Â  Â  color: #000;
Â  Â  Â  border: none;
Â  Â  Â  padding: 0.8rem 1.5rem;
Â  Â  Â  border-radius: 25px;
Â  Â  Â  font-weight: bold;
Â  Â  Â  cursor: pointer;
Â  Â  Â  transition: all 0.3s ease;
Â  Â  }
Â  Â Â 
Â  Â  button:hover {
Â  Â  Â  transform: translateY(-2px);
Â  Â  Â  box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
Â  Â  }
Â  Â Â 
Â  Â  button:active {
Â  Â  Â  transform: translateY(0);
Â  Â  }
Â  Â Â 
Â  Â  label {
Â  Â  Â  display: flex;
Â  Â  Â  align-items: center;
Â  Â  Â  gap: 0.5rem;
Â  Â  Â  background: rgba(255, 255, 255, 0.1);
Â  Â  Â  padding: 0.5rem 1rem;
Â  Â  Â  border-radius: 20px;
Â  Â  }
Â  Â Â 
Â  Â  input[type="checkbox"] {
Â  Â  Â  accent-color: #00ff88;
Â  Â  }
Â  Â Â 
Â  Â  #pxCanvas {Â 
Â  Â  Â  border: 2px solid #00ff88;Â 
Â  Â  Â  border-radius: 10px;
Â  Â  Â  margin: 2rem auto;
Â  Â  Â  display: block;
Â  Â  Â  max-width: 100%;
Â  Â  Â  box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
Â  Â  }
Â  Â Â 
Â  Â  .metadata {Â 
Â  Â  Â  font-size: 1rem;Â 
Â  Â  Â  margin: 1rem 0;Â 
Â  Â  Â  color: #00ffaa;
Â  Â  Â  text-align: center;
Â  Â  Â  font-weight: bold;
Â  Â  }
Â  Â Â 
Â  Â  textarea {Â 
Â  Â  Â  width: 100%;Â 
Â  Â  Â  height: 200px;Â 
Â  Â  Â  margin: 1rem 0;Â 
Â  Â  Â  background: #1a1a2e;Â 
Â  Â  Â  color: #00ff88;Â 
Â  Â  Â  font-family: 'Courier New', monospace;Â 
Â  Â  Â  padding: 1rem;Â 
Â  Â  Â  border: 1px solid #333;
Â  Â  Â  border-radius: 10px;
Â  Â  Â  resize: vertical;
Â  Â  }
Â  Â Â 
Â  Â  pre {Â 
Â  Â  Â  background: #0f0f23;Â 
Â  Â  Â  padding: 1rem;Â 
Â  Â  Â  color: #00ddff;Â 
Â  Â  Â  font-size: 0.9rem;Â 
Â  Â  Â  white-space: pre-wrap;Â 
Â  Â  Â  word-break: break-all;Â 
Â  Â  Â  margin: 1rem 0;Â 
Â  Â  Â  border: 1px solid #333;Â 
Â  Â  Â  border-radius: 10px;
Â  Â  Â  overflow-x: auto;
Â  Â  }
Â  Â Â 
Â  Â  .section {
Â  Â  Â  background: rgba(255, 255, 255, 0.05);
Â  Â  Â  border-radius: 10px;
Â  Â  Â  padding: 1.5rem;
Â  Â  Â  margin: 1rem 0;
Â  Â  Â  border: 1px solid #333;
Â  Â  }
Â  Â Â 
Â  Â  .section h3 {
Â  Â  Â  color: #00ff88;
Â  Â  Â  margin-top: 0;
Â  Â  }
Â  </style>
</head>
<body>
Â  <div class="container">
Â  Â  <h1>ğŸ§ª PXDigest Lab â€“ Data Digester</h1>
Â  Â Â 
Â  Â  <div class="upload-section">
Â  Â  Â  <h3>Upload File to Digest</h3>
Â  Â  Â  <input type="file" id="fileInput" />
Â  Â  Â  <p>Choose any file to convert into a visual digest</p>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="controls">
Â  Â  Â  <label><input type="checkbox" id="bootOnlyToggle" /> Boot ID Only</label>
Â  Â  Â  <label><input type="checkbox" id="headerOnlyEncodeToggle" /> Header-Only Encode (for simple patterns)</label>
Â  Â  Â  <button onclick="digestAndExport()">ğŸ§ª Digest + Export (GZIP)</button>
Â  Â  Â  <button onclick="reconstructAndDownload()">â™»ï¸ Reconstruct + Download File</button>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="upload-section">
Â  Â  Â  <h3>Load Existing Digest</h3>
Â  Â  Â  <input type="file" id="loadDigestFile" accept=".pxdigest" />
Â  Â  Â  <p>Load a previously saved .pxdigest file</p>
Â  Â  </div>

Â  Â  <div class="section" id="canvasSection" style="display: none;">
Â  Â  Â  <h3>Visual Representation</h3>
Â  Â  Â  <div style="text-align: center; margin-bottom: 1rem;">
Â  Â  Â  Â  <label for="canvasRenderMode">Render Mode:</label>
Â  Â  Â  Â  <select id="canvasRenderMode">
Â  Â  Â  Â  Â  <option value="rgb">RGB (3 bytes/pixel)</option>
Â  Â  Â  Â  Â  <option value="grayscale">Grayscale (1 byte/pixel)</option>
Â  Â  Â  Â  Â  <option value="heatmap">Heatmap (1 byte/pixel)</option>
Â  Â  Â  Â  </select>
Â  Â  Â  Â  <label><input type="checkbox" id="pixelGridToggle" /> Pixel Grid</label>
Â  Â  Â  Â  <button onclick="renderCanvas()">ğŸ¨ Render Visual Canvas</button>
Â  Â  Â  Â  <button onclick="downloadCanvasPNG()" id="downloadPNGBtn" style="display: none;">ğŸ“¸ Download PNG</button>
Â  Â  Â  </div>
Â  Â  Â  <div id="pxCanvasContainer" style="position: relative;">
Â  Â  Â  Â  <canvas id="pxCanvas"></canvas>
Â  Â  Â  Â  <div id="pixelInfo" style="position: absolute; top: 0; left: 0; background: rgba(0, 0, 0, 0.8); color: #fff; padding: 5px 10px; border-radius: 3px; font-family: monospace; font-size: 0.85rem; pointer-events: none; display: none; z-index: 10; white-space: pre; line-height: 1.2;"></div>
Â  Â  Â  </div>
Â  Â  Â  <div style="margin-top: 1rem;">
Â  Â  Â  Â  <h4>Byte Distribution Histogram</h4>
Â  Â  Â  Â  <canvas id="histogramCanvas" style="width: 100%; height: 150px; border: 1px solid #333;"></canvas>
Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <div class="metadata" id="metadata">Ready to process files...</div>
Â  Â Â 
Â  Â  <div class="section" id="digestSection" style="display: none;">
Â  Â  Â  <h3>Digest Output</h3>
Â  Â  Â  <div style="text-align: center; margin-bottom: 1rem;">
Â  Â  Â  Â  <button onclick="showDigestOutput()">ğŸ“‹ Show Digest Data</button>
Â  Â  Â  Â  <button onclick="downloadDigest()" id="downloadDigestBtn" style="display: none;">ğŸ’¾ Download .pxdigest</button>
Â  Â  Â  </div>
Â  Â  Â  <textarea id="digestOutput" placeholder="Digested data will appear here..." style="display: none;"></textarea>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="section">
Â  Â  Â  <h3>Header Preview</h3>
Â  Â  Â  <div style="text-align: center; margin-bottom: 1rem;">
Â  Â  Â  Â  <button onclick="copyHeaderPreview()">ğŸ“‹ Copy Header Info</button>
Â  Â  Â  </div>
Â  Â  Â  <pre id="headerPreview">No file processed yet...</pre>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="section">
Â  Â  Â  <h3>zTXt Emitter Output</h3>
Â  Â  Â  <pre id="ztxtEmitterOutput">Waiting for file processing...</pre>
Â  Â  </div>
Â  </div>

Â  <script>
Â  Â  // Global variables
Â  Â  let originalBytes = null;
Â  Â  let originalFileName = 'reconstructed_file'; // Default filename for reconstructed files
Â  Â  let currentRenderMode = 'rgb'; // Default render mode

Â  Â  // Canvas references
Â  Â  const pxCanvas = document.getElementById('pxCanvas');
Â  Â  const pxCtx = pxCanvas.getContext('2d');
Â  Â  const histogramCanvas = document.getElementById('histogramCanvas');
Â  Â  const histogramCtx = histogramCanvas.getContext('2d');
Â  Â  const pixelInfoDisplay = document.getElementById('pixelInfo');
Â  Â  const canvasRenderModeSelect = document.getElementById('canvasRenderMode');
Â  Â  const pixelGridToggle = document.getElementById('pixelGridToggle');
    const headerOnlyEncodeToggle = document.getElementById('headerOnlyEncodeToggle'); // Get the new toggle

Â  Â  // File input handler
Â  Â  document.getElementById('fileInput').addEventListener('change', (e) => {
Â  Â  Â  document.getElementById('loadDigestFile').value = '';
Â  Â  Â  const file = e.target.files[0];
Â  Â  Â  if (!file) return;
Â  Â  Â Â 
Â  Â  Â  originalFileName = file.name; // Store the original file name 
Â  Â  Â  const reader = new FileReader();
Â  Â  Â  reader.onload = function(event) {
Â  Â  Â  Â  originalBytes = new Uint8Array(event.target.result);
Â  Â  Â  Â  document.getElementById('metadata').textContent = `Loaded <span class="math-inline">\{file\.name\} \(</span>{originalBytes.length} bytes)`;
Â  Â  Â  Â  console.log(`File loaded: ${file.name}, ${originalBytes.length} bytes`);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Clear previous outputs
Â  Â  Â  Â  document.getElementById('digestOutput').value = '';
Â  Â  Â  Â  document.getElementById('headerPreview').textContent = '';
Â  Â  Â  Â  document.getElementById('ztxtEmitterOutput').textContent = '';
Â  Â  Â  };
Â  Â  Â  reader.readAsArrayBuffer(file);
Â  Â  });

Â  Â  // Canvas render mode change handler
Â  Â  canvasRenderModeSelect.addEventListener('change', () => {
Â  Â  Â  currentRenderMode = canvasRenderModeSelect.value;
Â  Â  Â  if (originalBytes && document.getElementById('pxCanvas').width > 0) {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  }
Â  Â  });

Â  Â  // Pixel grid toggle handler
Â  Â  pixelGridToggle.addEventListener('change', () => {
Â  Â  Â  if (originalBytes && document.getElementById('pxCanvas').width > 0) {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  }
Â  Â  });

Â  Â  // Canvas hover for pixel info
Â  Â  pxCanvas.addEventListener('mousemove', (e) => {
Â  Â  Â  if (!originalBytes || pxCanvas.width === 0 || pxCanvas.height === 0) {
Â  Â  Â  Â  pixelInfoDisplay.style.display = 'none';
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  const rect = pxCanvas.getBoundingClientRect();
Â  Â  Â  const scaleX = pxCanvas.width / rect.width;
Â  Â  Â  const scaleY = pxCanvas.height / rect.height;
Â  Â  Â  const x = Math.floor((e.clientX - rect.left) * scaleX);
Â  Â  Â  const y = Math.floor((e.clientY - rect.top) * scaleY);

Â  Â  Â  let bytesPerPixel = currentRenderMode === 'rgb' ? 3 : 1;
Â  Â  Â  const pixelIndex = y * pxCanvas.width + x;
Â  Â  Â  const byteOffset = pixelIndex * bytesPerPixel;

Â  Â  Â  let pixelBytes = [];
Â  Â  Â  for (let i = 0; i < bytesPerPixel; i++) {
Â  Â  Â  Â  if (byteOffset + i < originalBytes.length) {
Â  Â  Â  Â  Â  pixelBytes.push(originalBytes[byteOffset + i]);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  pixelBytes.push(0);
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  let pixelInfoText = `X: ${x}, Y: <span class="math-inline">\{y\}\\nOffset\: 0x</span>{byteOffset.toString(16).padStart(6, '0')}`;
Â  Â  Â  if (bytesPerPixel === 3) {
Â  Â  Â  Â  pixelInfoText += `\nRGB: <span class="math-inline">\{pixelBytes\[0\]\},</span>{pixelBytes[1]},${pixelBytes[2]}`;
Â  Â  Â  } else {
Â  Â  Â  Â  pixelInfoText += `\nValue: ${pixelBytes[0]}`;
Â  Â  Â  }
Â  Â  Â  pixelInfoText += `\nHex: 0x${pixelBytes.map(b => b.toString(16).padStart(2, '0')).join('')}`;

Â  Â  Â  pixelInfoDisplay.style.display = 'block';
Â  Â  Â  const containerRect = pxCanvas.parentElement.getBoundingClientRect();
Â  Â  Â  let displayX = e.clientX - containerRect.left + 10;
Â  Â  Â  let displayY = e.clientY - containerRect.top + 10;

Â  Â  Â  if (displayX + 200 > containerRect.width) {
Â  Â  Â  Â  displayX = containerRect.width - 200;
Â  Â  Â  }
Â  Â  Â  if (displayY + 100 > containerRect.height) {
Â  Â  Â  Â  displayY = containerRect.height - 100;
Â  Â  Â  }

Â  Â  Â  pixelInfoDisplay.style.left = `${displayX}px`;
Â  Â  Â  pixelInfoDisplay.style.top = `${displayY}px`;
Â  Â  Â  pixelInfoDisplay.innerText = pixelInfoText;
Â  Â  });

Â  Â  pxCanvas.addEventListener('mouseleave', () => {
Â  Â  Â  pixelInfoDisplay.style.display = 'none';
Â  Â  });

Â  Â  // Load digest file handler
Â  Â  document.getElementById('loadDigestFile').addEventListener('change', (e) => {
Â  Â  Â  const file = e.target.files[0];
Â  Â  Â  if (!file) return;
Â  Â  Â Â 
Â  Â  Â  const reader = new FileReader();
Â  Â  Â  reader.onload = function(event) {
Â  Â  Â  Â  document.getElementById('digestOutput').value = event.target.result;
Â  Â  Â  Â  document.getElementById('digestSection').style.display = 'block';
Â  Â  Â  Â  showDigestOutput(); // Automatically show when loading from file
Â  Â  Â  Â  // For this step, we'll only call reconstructAndDownload for visual feedback
Â  Â  Â  Â  // Full reconstruction logic will be added in next steps.
Â  Â  Â  Â  // reconstructAndDownload(event.target.result); // Temporarily commented out for this step
Â  Â  Â  };
Â  Â  Â  reader.readAsText(file);
Â  Â  });

Â  Â  // Download digest function
Â  Â  function downloadDigest() {
Â  Â  Â  const digest = document.getElementById('digestOutput').value;
Â  Â  Â  if (!digest) {
Â  Â  Â  Â  alert('No digest to download. Please show digest data first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  const blob = new Blob([digest], { type: 'text/plain' });
Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  a.href = URL.createObjectURL(blob);
Â  Â  Â  a.download = `${originalFileName}.pxdigest`; // Use original filename for digest download 
Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  a.click();
Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  URL.revokeObjectURL(a.href);
Â  Â  }

Â  Â  // Main digest and export function
Â  Â  async function digestAndExport() {
Â  Â  Â  console.log('Digest button clicked.');
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file loaded. Please upload a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  // Show processing indicator
Â  Â  Â  document.getElementById('metadata').textContent = `Processing ${originalBytes.length} bytes...`;

Â  Â  Â  try {
Â  Â  Â  Â  // For this step, we'll hardcode reconstruction-spec and param to demonstrate header changes
Â  Â  Â  Â  // Actual detection logic will come later.
Â  Â  Â  Â  let reconstructionSpec = 'rebuild_zero_fill'; // Example spec 
Â  Â  Â  Â  let reconstructionParam = '0'; // Example param 

Â  Â  Â  Â  // Compress the data (always for now, even if spec implies header-only, for display purposes)
Â  Â  Â  Â  const compressed = pako.gzip(originalBytes); [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Convert to base64 in chunks to avoid stack overflow 
Â  Â  Â  Â  const base64 = arrayBufferToBase64(compressed); [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Convert to hex in chunks 
Â  Â  Â  Â  const hex = arrayBufferToHex(compressed); [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Generate checksum 
Â  Â  Â  Â  const hashBuffer = await crypto.subtle.digest('SHA-256', originalBytes.buffer); [cite: 1]
Â  Â  Â  Â  const headerHash = Array.from(new Uint8Array(hashBuffer)) [cite: 1]
Â  Â  Â  Â  Â  .map(b => b.toString(16).padStart(2, '0')).join(''); [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Construct the enhanced header
Â  Â  Â  Â  const header = `PXDigest v2
filename:<span class="math-inline">\{originalFileName\}
compressed\:</span>{compressed.length}
original:<span class="math-inline">\{originalBytes\.length\}
checksum\:</span>{headerHash}
reconstruction-spec:<span class="math-inline">\{reconstructionSpec\}
\[cite\_start\]reconstruction\-param\:</span>{reconstructionParam}`; [cite: 1]

Â  Â  Â  Â  // Compute 4-pixel boot signature (first 12 bytes of SHA-256) 
Â  Â  Â  Â  const hashBytes = new Uint8Array(hashBuffer); [cite: 1]
Â  Â  Â  Â  const bootRGBs = [0, 3, 6, 9].map(i => [hashBytes[i], hashBytes[i+1], hashBytes[i+2]]); [cite: 1]
Â  Â  Â  Â  const bootText = bootRGBs.map((rgb, i) => `128,${i} = <span class="math-inline">\{rgb\[0\]\},</span>{rgb[1]},${rgb[2]}`).join('\n'); [cite: 1]

Â  Â  Â  Â  // Auto-bloom registry 
Â  Â  Â  Â  const digestIndex = { [cite: 1]
Â  Â  Â  Â  Â  '28,63,165-177,95,8-103,48,213-229,77,212': 'pxgen/specs/run_tinycore_vm', [cite: 1]
Â  Â  Â  Â  Â  // Add more known digests here as needed
Â  Â  Â  Â  };
Â  Â  Â  Â  const bootKey = bootRGBs.map(rgb => rgb.join(',')).join('-'); [cite: 1]
Â  Â  Â  Â  const matchedSpec = digestIndex[bootKey] || 'No match'; [cite: 1]

Â  Â  Â  Â  // Draw boot pixels 
Â  Â  Â  Â  const bootCanvas = document.getElementById('pxCanvas'); [cite: 1]
Â  Â  Â  Â  const bootCtx = bootCanvas.getContext('2d'); [cite: 1]
Â  Â  Â  Â  bootCanvas.width = 200; [cite: 1]
Â  Â  Â  Â  bootCanvas.height = 50; [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Clear canvas 
Â  Â  Â  Â  bootCtx.fillStyle = '#000'; [cite: 1]
Â  Â  Â  Â  bootCtx.fillRect(0, 0, bootCanvas.width, bootCanvas.height); [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Draw boot pixels 
Â  Â  Â  Â  for (let i = 0; i < bootRGBs.length; i++) { [cite: 1]
Â  Â  Â  Â  Â  const [r, g, b] = bootRGBs[i]; [cite: 1]
Â  Â  Â  Â  Â  bootCtx.fillStyle = `rgb(<span class="math-inline">\{r\},</span>{g},${b})`; [cite: 1]
Â  Â  Â  Â  Â  bootCtx.fillRect(i * 30, 10, 25, 25); [cite: 1]
Â  Â  Â  Â  }

Â  Â  Â  Â  // Generate digest (still including full data for now) 
Â  Â  Â  Â  const bootOnly = document.getElementById('bootOnlyToggle').checked; [cite: 1]
Â  Â  Â  Â  const digest = bootOnly [cite: 1]
Â  Â  Â  Â  Â  ? `<span class="math-inline">\{header\}\\n</span>{bootText}` [cite: 1]
Â  Â  Â  Â  Â  : `<span class="math-inline">\{header\}\\n</span>{bootText}\n\n[Base64]\n${base64}\n\n[Hex]\n${hex}`; [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  document.getElementById('digestOutput').value = digest; [cite: 1]
Â  Â  Â  Â  console.log('Digest output written to textarea.'); [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Update header preview 
Â  Â  Â  Â  document.getElementById('headerPreview').textContent = `// PXDigest Header Info
${header}

// Boot Pixels
<span class="math-inline">\{bootText\}
// Bloom Match
\[cite\_start\]</span>{bootKey} => ${matchedSpec}`; [cite: 1]

Â  Â  Â  Â  // zTXt emitter output 
Â  Â  Â  Â  const ztxtSpec = `# pxgen/specs/restore_from_digest
READ_ZT pxgen/input/compressed_digest
DECODE_GZIP_BASE64 TO CODE_FORGE_REGION
HALT`; [cite: 1]
Â  Â  Â  Â  document.getElementById('ztxtEmitterOutput').textContent = ztxtSpec; [cite: 1]

Â  Â  Â  Â  // Show sections but keep digest hidden by default 
Â  Â  Â  Â  document.getElementById('canvasSection').style.display = 'block'; [cite: 1]
Â  Â  Â  Â  document.getElementById('digestSection').style.display = 'block'; [cite: 1]
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'none'; [cite: 1]
Â  Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'none'; [cite: 1]

Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Processed ${originalBytes.length} bytes successfully! Digest ready to view.`; [cite: 1]

Â  Â  Â  } catch (error) {
Â  Â  Â  Â  console.error('Error during digest:', error); [cite: 1]
Â  Â  Â  Â  alert('Error processing file: ' + error.message); [cite: 1]
Â  Â  Â  }
Â  Â  }

Â  Â  // Reconstruct from digest
Â  Â  // This function will be replaced/enhanced by reconstructAndDownload in a later step.
Â  Â  function reconstructFromDigest() { [cite: 1]
Â  Â  Â  const digest = document.getElementById('digestOutput').value; [cite: 1]
Â  Â  Â  if (!digest) { [cite: 1]
Â  Â  Â  Â  alert('No digest to reconstruct from.'); [cite: 1]
Â  Â  Â  Â  return; [cite: 1]
Â  Â  Â  } [cite: 1]

Â  Â  Â  try { [cite: 1]
Â  Â  Â  Â  const lines = digest.split('\n'); [cite: 1]
Â  Â  Â  Â  let headerChecksum = ''; [cite: 1]
Â  Â  Â  Â  let base64Data = ''; [cite: 1]
Â  Â  Â  Â  let inBase64Section = false; [cite: 1]

Â  Â  Â  Â  // Parse the digest 
Â  Â  Â  Â  for (let line of lines) { [cite: 1]
Â  Â  Â  Â  Â  if (line.startsWith('checksum:')) { [cite: 1]
Â  Â  Â  Â  Â  Â  headerChecksum = line.split(':')[1]; [cite: 1]
Â  Â  Â  Â  Â  } else if (line === '[Base64]') { [cite: 1]
Â  Â  Â  Â  Â  Â  inBase64Section = true; [cite: 1]
Â  Â  Â  Â  Â  } else if (line === '[Hex]') { [cite: 1]
Â  Â  Â  Â  Â  Â  inBase64Section = false; [cite: 1]
Â  Â  Â  Â  Â  } else if (inBase64Section && line.trim()) { [cite: 1]
Â  Â  Â  Â  Â  Â  base64Data += line.trim(); [cite: 1]
Â  Â  Â  Â  Â  } [cite: 1]
Â  Â  Â  Â  } [cite: 1]

Â  Â  Â  Â  if (!base64Data) { [cite: 1]
Â  Â  Â  Â  Â  alert('No base64 data found in digest.'); [cite: 1]
Â  Â  Â  Â  Â  return; [cite: 1]
Â  Â  Â  Â  } [cite: 1]

Â  Â  Â  Â  // Decode and decompress 
Â  Â  Â  Â  const binary = base64ToArrayBuffer(base64Data); [cite: 1]
Â  Â  Â  Â  const compressed = new Uint8Array(binary); [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  const bytes = pako.ungzip(compressed); [cite: 1]
Â  Â  Â  Â  originalBytes = bytes; [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Verify checksum 
Â  Â  Â  Â  crypto.subtle.digest('SHA-256', bytes.buffer).then(hash => { [cite: 1]
Â  Â  Â  Â  Â  const verifyHash = Array.from(new Uint8Array(hash)) [cite: 1]
Â  Â  Â  Â  Â  Â  .map(b => b.toString(16).padStart(2, '0')).join(''); [cite: 1]
Â  Â  Â  Â  Â  const resultMsg = verifyHash === headerChecksum [cite: 1]
Â  Â  Â  Â  Â  Â  ? `âœ… Reconstructed ${bytes.length} bytes (checksum OK)` [cite: 1]
Â  Â  Â  Â  Â  Â  : `âš ï¸ Reconstructed ${bytes.length} bytes (checksum MISMATCH)`; [cite: 1]
Â  Â  Â  Â  Â  document.getElementById('metadata').textContent = resultMsg; [cite: 1]
Â  Â  Â  Â  }); [cite: 1]

Â  Â  Â  Â  // Show sections but keep digest hidden by default 
Â  Â  Â  Â  document.getElementById('canvasSection').style.display = 'block'; [cite: 1]
Â  Â  Â  Â  document.getElementById('digestSection').style.display = 'block'; [cite: 1]
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'none'; [cite: 1]
Â  Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'none'; [cite: 1]

Â  Â  Â  } catch (error) { [cite: 1]
Â  Â  Â  Â  console.error('Error during reconstruction:', error); [cite: 1]
Â  Â  Â  Â  alert('Error reconstructing from digest: ' + error.message); [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  }

Â  Â  // Draw pixels from bytes
Â  Â  function drawFromBytes(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting reconstruction of canvas from bytes.'); [cite: 1]
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas'); [cite: 1]
Â  Â  Â  const ctx = canvas.getContext('2d'); [cite: 1]
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions 
Â  Â  Â  const totalPixels = Math.ceil(bytes.length / 3); [cite: 1]
Â  Â  Â  const w = Math.ceil(Math.sqrt(totalPixels)); [cite: 1]
Â  Â  Â  const h = Math.ceil(totalPixels / w); [cite: 1]
Â  Â  Â  canvas.width = w; [cite: 1]
Â  Â  Â  canvas.height = h; [cite: 1]
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`); [cite: 1]

Â  Â  Â  // Calculate entropy 
Â  Â  Â  const entropyBin = new Array(256).fill(0); [cite: 1]
Â  Â  Â  for (let b of bytes) entropyBin[b]++; [cite: 1]
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => { [cite: 1]
Â  Â  Â  Â  if (n === 0) return acc; [cite: 1]
Â  Â  Â  Â  const p = n / bytes.length; [cite: 1]
Â  Â  Â  Â  return acc + p * Math.log2(p); [cite: 1]
Â  Â  Â  }, 0); [cite: 1]
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`); [cite: 1]

Â  Â  Â  // Create image data 
Â  Â  Â  const imgData = ctx.createImageData(w, h); [cite: 1]
Â  Â  Â  let j = 0; [cite: 1]
Â  Â  Â  for (let i = 0; i < bytes.length; i += 3) { [cite: 1]
Â  Â  Â  Â  imgData.data[j++] = bytes[i]; [cite: 1]Â  Â  Â  Â  Â  Â // R 
Â  Â  Â  Â  imgData.data[j++] = bytes[i+1] || 0; [cite: 1]Â  Â  // G 
Â  Â  Â  Â  imgData.data[j++] = bytes[i+2] || 0; [cite: 1]Â  Â  // B 
Â  Â  Â  Â  imgData.data[j++] = 255; [cite: 1]Â  Â  Â  Â  Â  Â  Â  Â  // A 
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black 
Â  Â  Â  while (j < imgData.data.length) { [cite: 1]
Â  Â  Â  Â  imgData.data[j++] = 0; [cite: 1]Â  Â // R 
Â  Â  Â  Â  imgData.data[j++] = 0; [cite: 1]Â  Â // G 
Â  Â  Â  Â  imgData.data[j++] = 0; [cite: 1]Â  Â // B 
Â  Â  Â  Â  imgData.data[j++] = 255; [cite: 1] // A 
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0); [cite: 1]
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay 
Â  Â  Â  ctx.font = '12px monospace'; [cite: 1]
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)'; [cite: 1]
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)'; [cite: 1]
Â  Â  Â  ctx.lineWidth = 2; [cite: 1]
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`; [cite: 1]
Â  Â  Â  ctx.strokeText(text, 5, h - 10); [cite: 1]
Â  Â  Â  ctx.fillText(text, 5, h - 10); [cite: 1]
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.'); [cite: 1]

Â  Â  Â  // Animate bloom effect 
Â  Â  Â  let radius = 1; [cite: 1]
Â  Â  Â  function bloomStep() { [cite: 1]
Â  Â  Â  Â  ctx.beginPath(); [cite: 1]
Â  Â  Â  Â  ctx.arc(20, 20, radius, 0, 2 * Math.PI); [cite: 1]
Â  Â  Â  Â  ctx.strokeStyle = 'lime'; [cite: 1]
Â  Â  Â  Â  ctx.lineWidth = 2; [cite: 1]
Â  Â  Â  Â  ctx.stroke(); [cite: 1]
Â  Â  Â  Â  radius += 3; [cite: 1]
Â  Â  Â  Â  if (radius < 50) requestAnimationFrame(bloomStep); [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  Â  bloomStep(); [cite: 1]
Â  Â  }

Â  Â  // Function to copy header preview to clipboard 
Â  Â  function copyHeaderPreview() { [cite: 1]
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent; [cite: 1]
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') { [cite: 1]
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.'); [cite: 1]
Â  Â  Â  Â  return; [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() { [cite: 1]
Â  Â  Â  Â  // Visual feedback 
Â  Â  Â  Â  const button = event.target; [cite: 1]
Â  Â  Â  Â  const originalText = button.textContent; [cite: 1]
Â  Â  Â  Â  button.textContent = 'âœ… Copied!'; [cite: 1]
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)'; [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => { [cite: 1]
Â  Â  Â  Â  Â  button.textContent = originalText; [cite: 1]
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)'; [cite: 1]
Â  Â  Â  Â  }, 2000); [cite: 1]
Â  Â  Â  }).catch(function(err) { [cite: 1]
Â  Â  Â  Â  // Fallback for older browsers 
Â  Â  Â  Â  const textArea = document.createElement('textarea'); [cite: 1]
Â  Â  Â  Â  textArea.value = headerText; [cite: 1]
Â  Â  Â  Â  document.body.appendChild(textArea); [cite: 1]
Â  Â  Â  Â  textArea.select(); [cite: 1]
Â  Â  Â  Â  document.execCommand('copy'); [cite: 1]
Â  Â  Â  Â  document.body.removeChild(textArea); [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback 
Â  Â  Â  Â  const button = event.target; [cite: 1]
Â  Â  Â  Â  const originalText = button.textContent; [cite: 1]
Â  Â  Â  Â  button.textContent = 'âœ… Copied!'; [cite: 1]
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)'; [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => { [cite: 1]
Â  Â  Â  Â  Â  button.textContent = originalText; [cite: 1]
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)'; [cite: 1]
Â  Â  Â  Â  }, 2000); [cite: 1]
Â  Â  Â  }); [cite: 1]
Â  Â  }

Â  Â  // Function to show digest output on demand 
Â  Â  function showDigestOutput() { [cite: 1]
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput'); [cite: 1]
Â  Â  Â  if (!digestTextarea.value) { [cite: 1]
Â  Â  Â  Â  alert('No digest data available to show.'); [cite: 1]
Â  Â  Â  Â  return; [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block'; [cite: 1]
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block'; [cite: 1]
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`; [cite: 1]
Â  Â  }

Â  Â  // Function to render the canvas on demand 
Â  Â  function renderCanvas() { [cite: 1]
Â  Â  Â  if (!originalBytes) { [cite: 1]
Â  Â  Â  Â  alert('No file data available to render.'); [cite: 1]
Â  Â  Â  Â  return; [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...'; [cite: 1]
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update 
Â  Â  Â  setTimeout(() => { [cite: 1]
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes); [cite: 1]
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block'; [cite: 1]
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`; [cite: 1]
Â  Â  Â  }, 100); [cite: 1]
Â  Â  }

Â  Â  // Function to download canvas as PNG 
Â  Â  function downloadCanvasPNG() { [cite: 1]
Â  Â  Â  const canvas = document.getElementById('pxCanvas'); [cite: 1]
Â  Â  Â  if (!canvas.width || !canvas.height) { [cite: 1]
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.'); [cite: 1]
Â  Â  Â  Â  return; [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  // Create download link 
Â  Â  Â  canvas.toBlob(function(blob) { [cite: 1]
Â  Â  Â  Â  const url = URL.createObjectURL(blob); [cite: 1]
Â  Â  Â  Â  const a = document.createElement('a'); [cite: 1]
Â  Â  Â  Â  a.href = url; [cite: 1]
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png'; [cite: 1]
Â  Â  Â  Â  document.body.appendChild(a); [cite: 1]
Â  Â  Â  Â  a.click(); [cite: 1]
Â  Â  Â  Â  document.body.removeChild(a); [cite: 1]
Â  Â  Â  Â  URL.revokeObjectURL(url); [cite: 1]
Â  Â  Â  }, 'image/png'); [cite: 1]
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks 
Â  Â  function arrayBufferToBase64(buffer) { [cite: 1]
Â  Â  Â  const bytes = new Uint8Array(buffer); [cite: 1]
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks 
Â  Â  Â  let result = ''; [cite: 1]
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) { [cite: 1]
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize); [cite: 1]
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk)); [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  return result; [cite: 1]
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks 
Â  Â  function arrayBufferToHex(buffer) { [cite: 1]
Â  Â  Â  const bytes = new Uint8Array(buffer); [cite: 1]
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks 
Â  Â  Â  let result = ''; [cite: 1]
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) { [cite: 1]
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize); [cite: 1]
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join(''); [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  return result; [cite: 1]
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks 
Â  Â  function base64ToArrayBuffer(base64) { [cite: 1]
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks 
Â  Â  Â  const chunks = []; [cite: 1]
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) { [cite: 1]
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize); [cite: 1]
Â  Â  Â  Â  const binary = atob(chunk); [cite: 1]
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length); [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) { [cite: 1]
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j); [cite: 1]
Â  Â  Â  Â  } [cite: 1]
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes); [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks 
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0); [cite: 1]
Â  Â  Â  const result = new Uint8Array(totalLength); [cite: 1]
Â  Â  Â  let offset = 0; [cite: 1]
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) { [cite: 1]
Â  Â  Â  Â  result.set(chunk, offset); [cite: 1]
Â  Â  Â  Â  offset += chunk.length; [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  return result.buffer; [cite: 1]
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) { [cite: 1]
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.'); [cite: 1]
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas'); [cite: 1]
Â  Â  Â  const ctx = canvas.getContext('2d'); [cite: 1]
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance 
Â  Â  Â  const maxDimension = 1024; [cite: 1]
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3); [cite: 1]
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large 
Â  Â  Â  let sampledBytes = bytes; [cite: 1]
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) { [cite: 1]
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3)); [cite: 1]
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate)); [cite: 1]
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) { [cite: 1]
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate]; [cite: 1]
Â  Â  Â  Â  } [cite: 1]
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3); [cite: 1]
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`); [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions 
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension); [cite: 1]
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension); [cite: 1]
Â  Â  Â  canvas.width = w; [cite: 1]
Â  Â  Â  canvas.height = h; [cite: 1]
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`); [cite: 1]

Â  Â  Â  // Calculate entropy on a sample 
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000); [cite: 1]
Â  Â  Â  const entropyBin = new Array(256).fill(0); [cite: 1]
Â  Â  Â  for (let i = 0; i < sampleSize; i++) { [cite: 1]
Â  Â  Â  Â  entropyBin[sampledBytes[i]]++; [cite: 1]
Â  Â  Â  } [cite: 1]
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => { [cite: 1]
Â  Â  Â  Â  if (n === 0) return acc; [cite: 1]
Â  Â  Â  Â  const p = n / sampleSize; [cite: 1]
Â  Â  Â  Â  return acc + p * Math.log2(p); [cite: 1]
Â  Â  Â  }, 0); [cite: 1]
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`); [cite: 1]

Â  Â  Â  // Create image data 
Â  Â  Â  const imgData = ctx.createImageData(w, h); [cite: 1]
Â  Â  Â  let j = 0; [cite: 1]
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) { [cite: 1]
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i]; [cite: 1]Â  Â  Â  Â  Â  Â // R 
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0; [cite: 1]Â  Â  // G 
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0; [cite: 1]Â  Â  // B 
Â  Â  Â  Â  imgData.data[j++] = 255; [cite: 1]Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A 
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black 
Â  Â  Â  while (j < imgData.data.length) { [cite: 1]
Â  Â  Â  Â  imgData.data[j++] = 0; [cite: 1]Â  Â // R 
Â  Â  Â  Â  imgData.data[j++] = 0; [cite: 1]Â  Â // G 
Â  Â  Â  Â  imgData.data[j++] = 0; [cite: 1]Â  Â // B 
Â  Â  Â  Â  imgData.data[j++] = 255; [cite: 1] // A 
Â  Â  Â  } [cite: 1]
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0); [cite: 1]
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay 
Â  Â  Â  ctx.font = '12px monospace'; [cite: 1]
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)'; [cite: 1]
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)'; [cite: 1]
Â  Â  Â  ctx.lineWidth = 2; [cite: 1]
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`; [cite: 1]
Â  Â  Â  ctx.strokeText(text, 5, h - 10); [cite: 1]
Â  Â  Â  ctx.fillText(text, 5, h - 10); [cite: 1]
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.'); [cite: 1]

Â  Â  Â  // Simple bloom effect 
Â  Â  Â  ctx.beginPath(); [cite: 1]
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI); [cite: 1]
Â  Â  Â  ctx.strokeStyle = 'lime'; [cite: 1]
Â  Â  Â  ctx.lineWidth = 3; [cite: 1]
Â  Â  Â  ctx.stroke(); [cite: 1]
Â  Â  } [cite: 1]
Â  </script>
</body>
</html>