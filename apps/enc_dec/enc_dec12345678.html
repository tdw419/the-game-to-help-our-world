<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="UTF-8" />
Â  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
Â  <title>PXDigest Lab â€“ Data Digester</title>
Â  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
Â  <style>
Â  Â  body {Â 
Â  Â  Â  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;Â 
Â  Â  Â  padding: 2rem;Â 
Â  Â  Â  background: linear-gradient(135deg, #0f0f23, #1a1a3a);Â 
Â  Â  Â  color: #e0e0e0;Â 
Â  Â  Â  margin: 0;
Â  Â  Â  min-height: 100vh;
Â  Â  }
Â  Â Â 
Â  Â  h1 {
Â  Â  Â  text-align: center;
Â  Â  Â  color: #00ff88;
Â  Â  Â  text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
Â  Â  Â  margin-bottom: 2rem;
Â  Â  }
Â  Â Â 
Â  Â  .container {
Â  Â  Â  max-width: 1200px;
Â  Â  Â  margin: 0 auto;
Â  Â  }
Â  Â Â 
Â  Â  .upload-section {
Â  Â  Â  background: rgba(255, 255, 255, 0.05);
Â  Â  Â  border: 2px dashed #00ff88;
Â  Â  Â  border-radius: 10px;
Â  Â  Â  padding: 2rem;
Â  Â  Â  text-align: center;
Â  Â  Â  margin-bottom: 2rem;
Â  Â  Â  transition: all 0.3s ease;
Â  Â  }
Â  Â Â 
Â  Â  .upload-section:hover {
Â  Â  Â  background: rgba(0, 255, 136, 0.1);
Â  Â  Â  border-color: #00ffaa;
Â  Â  }
Â  Â Â 
Â  Â  input[type="file"] {
Â  Â  Â  background: #2a2a4a;
Â  Â  Â  color: #e0e0e0;
Â  Â  Â  border: 1px solid #444;
Â  Â  Â  border-radius: 5px;
Â  Â  Â  padding: 0.5rem;
Â  Â  Â  margin: 0.5rem;
Â  Â  }
Â  Â Â 
Â  Â  .controls {Â 
Â  Â  Â  display: flex;
Â  Â  Â  flex-wrap: wrap;
Â  Â  Â  gap: 1rem;
Â  Â  Â  margin: 2rem 0;
Â  Â  Â  justify-content: center;
Â  Â  }
Â  Â Â 
Â  Â  button {
Â  Â  Â  background: linear-gradient(45deg, #00ff88, #00cc66);
Â  Â  Â  color: #000;
Â  Â  Â  border: none;
Â  Â  Â  padding: 0.8rem 1.5rem;
Â  Â  Â  border-radius: 25px;
Â  Â  Â  font-weight: bold;
Â  Â  Â  cursor: pointer;
Â  Â  Â  transition: all 0.3s ease;
Â  Â  }
Â  Â Â 
Â  Â  button:hover {
Â  Â  Â  transform: translateY(-2px);
Â  Â  Â  box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
Â  Â  }
Â  Â Â 
Â  Â  button:active {
Â  Â  Â  transform: translateY(0);
Â  Â  }
Â  Â Â 
Â  Â  label {
Â  Â  Â  display: flex;
Â  Â  Â  align-items: center;
Â  Â  Â  gap: 0.5rem;
Â  Â  Â  background: rgba(255, 255, 255, 0.1);
Â  Â  Â  padding: 0.5rem 1rem;
Â  Â  Â  border-radius: 20px;
Â  Â  }
Â  Â Â 
Â  Â  input[type="checkbox"] {
Â  Â  Â  accent-color: #00ff88;
Â  Â  }
Â  Â Â 
Â  Â  #pxCanvas {Â 
Â  Â  Â  border: 2px solid #00ff88;Â 
Â  Â  Â  border-radius: 10px;
Â  Â  Â  margin: 2rem auto;
Â  Â  Â  display: block;
Â  Â  Â  max-width: 100%;
Â  Â  Â  box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
Â  Â  }
Â  Â Â 
Â  Â  .metadata {Â 
Â  Â  Â  font-size: 1rem;Â 
Â  Â  Â  margin: 1rem 0;Â 
Â  Â  Â  color: #00ffaa;
Â  Â  Â  text-align: center;
Â  Â  Â  font-weight: bold;
Â  Â  }
Â  Â Â 
Â  Â  textarea {Â 
Â  Â  Â  width: 100%;Â 
Â  Â  Â  height: 200px;Â 
Â  Â  Â  margin: 1rem 0;Â 
Â  Â  Â  background: #1a1a2e;Â 
Â  Â  Â  color: #00ff88;Â 
Â  Â  Â  font-family: 'Courier New', monospace;Â 
Â  Â  Â  padding: 1rem;Â 
Â  Â  Â  border: 1px solid #333;
Â  Â  Â  border-radius: 10px;
Â  Â  Â  resize: vertical;
Â  Â  }
Â  Â Â 
Â  Â  pre {Â 
Â  Â  Â  background: #0f0f23;Â 
Â  Â  Â  padding: 1rem;Â 
Â  Â  Â  color: #00ddff;Â 
Â  Â  Â  font-size: 0.9rem;Â 
Â  Â  Â  white-space: pre-wrap;Â 
Â  Â  Â  word-break: break-all;Â 
Â  Â  Â  margin: 1rem 0;Â 
Â  Â  Â  border: 1px solid #333;Â 
Â  Â  Â  border-radius: 10px;
Â  Â  Â  overflow-x: auto;
Â  Â  }
Â  Â Â 
Â  Â  .section {
Â  Â  Â  background: rgba(255, 255, 255, 0.05);
Â  Â  Â  border-radius: 10px;
Â  Â  Â  padding: 1.5rem;
Â  Â  Â  margin: 1rem 0;
Â  Â  Â  border: 1px solid #333;
Â  Â  }
Â  Â Â 
Â  Â  .section h3 {
Â  Â  Â  color: #00ff88;
Â  Â  Â  margin-top: 0;
Â  Â  }
Â  </style>
</head>
<body>
Â  <div class="container">
Â  Â  <h1>ğŸ§ª PXDigest Lab â€“ Data Digester</h1>
Â  Â Â 
Â  Â  <div class="upload-section">
Â  Â  Â  <h3>Upload File to Digest</h3>
Â  Â  Â  <input type="file" id="fileInput" />
Â  Â  Â  <p>Choose any file to convert into a visual digest</p>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="controls">
Â  Â  Â  <label><input type="checkbox" id="bootOnlyToggle" /> Boot ID Only</label>
Â  Â  Â  <label><input type="checkbox" id="headerOnlyEncodeToggle" /> Header-Only Encode (for simple patterns)</label>
Â  Â  Â  <button onclick="digestAndExport()">ğŸ§ª Digest + Export (GZIP)</button>
Â  Â  Â  <button onclick="reconstructAndDownload()">â™»ï¸ Reconstruct + Download File</button>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="upload-section">
Â  Â  Â  <h3>Load Existing Digest</h3>
Â  Â  Â  <input type="file" id="loadDigestFile" accept=".pxdigest" />
Â  Â  Â  <p>Load a previously saved .pxdigest file</p>
Â  Â  </div>

    <div class="section">
        <h3>Rebuild from Header Text</h3>
        <textarea id="rebuildHeaderInput" placeholder="Paste Header Preview text here..." style="height: 150px;"></textarea>
        <div style="text-align: center; margin-top: 1rem;">
            <button onclick="reconstructAndDownload(document.getElementById('rebuildHeaderInput').value)">â™»ï¸ Rebuild from Pasted Header</button>
        </div>
    </div>
    Â  Â  <div class="section" id="canvasSection" style="display: none;">
Â  Â  Â  <h3>Visual Representation</h3>
Â  Â  Â  <div style="text-align: center; margin-bottom: 1rem;">
Â  Â  Â  Â  <label for="canvasRenderMode">Render Mode:</label>
Â  Â  Â  Â  <select id="canvasRenderMode">
Â  Â  Â  Â  Â  <option value="rgb">RGB (3 bytes/pixel)</option>
Â  Â  Â  Â  Â  <option value="grayscale">Grayscale (1 byte/pixel)</option>
Â  Â  Â  Â  Â  <option value="heatmap">Heatmap (1 byte/pixel)</option>
Â  Â  Â  Â  </select>
Â  Â  Â  Â  <label><input type="checkbox" id="pixelGridToggle" /> Pixel Grid</label>
Â  Â  Â  Â  <button onclick="renderCanvas()">ğŸ¨ Render Visual Canvas</button>
Â  Â  Â  Â  <button onclick="downloadCanvasPNG()" id="downloadPNGBtn" style="display: none;">ğŸ“¸ Download PNG</button>
Â  Â  Â  </div>
Â  Â  Â  <div id="pxCanvasContainer" style="position: relative;">
Â  Â  Â  Â  <canvas id="pxCanvas"></canvas>
Â  Â  Â  Â  <div id="pixelInfo" style="position: absolute; top: 0; left: 0; background: rgba(0, 0, 0, 0.8); color: #fff; padding: 5px 10px; border-radius: 3px; font-family: monospace; font-size: 0.85rem; pointer-events: none; display: none; z-index: 10; white-space: pre; line-height: 1.2;"></div>
Â  Â  Â  </div>
Â  Â  Â  <div style="margin-top: 1rem;">
Â  Â  Â  Â  <h4>Byte Distribution Histogram</h4>
Â  Â  Â  Â  <canvas id="histogramCanvas" style="width: 100%; height: 150px; border: 1px solid #333;"></canvas>
Â  Â  Â  </div>
Â  Â  </div>
Â  Â  <div class="metadata" id="metadata">Ready to process files...</div>
Â  Â Â 
Â  Â  <div class="section" id="digestSection" style="display: none;">
Â  Â  Â  <h3>Digest Output</h3>
Â  Â  Â  <div style="text-align: center; margin-bottom: 1rem;">
Â  Â  Â  Â  <button onclick="showDigestOutput()">ğŸ“‹ Show Digest Data</button>
Â  Â  Â  Â  <button onclick="downloadDigest()" id="downloadDigestBtn" style="display: none;">ğŸ’¾ Download .pxdigest</button>
Â  Â  Â  </div>
Â  Â  Â  <textarea id="digestOutput" placeholder="Digested data will appear here..." style="display: none;"></textarea>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="section">
Â  Â  Â  <h3>Header Preview</h3>
Â  Â  Â  <div style="text-align: center; margin-bottom: 1rem;">
Â  Â  Â  Â  <button onclick="copyHeaderPreview()">ğŸ“‹ Copy Header Info</button>
Â  Â  Â  </div>
Â  Â  Â  <pre id="headerPreview">No file processed yet...</pre>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="section">
Â  Â  Â  <h3>zTXt Emitter Output</h3>
Â  Â  Â  <pre id="ztxtEmitterOutput">Waiting for file processing...</pre>
Â  Â  </div>
Â  </div>

Â  <script>
Â  Â  // Global variables
Â  Â  let originalBytes = null;
Â  Â  let originalFileName = 'reconstructed_file'; // Default filename for reconstructed files
Â  Â  let currentRenderMode = 'rgb'; // Default render mode

Â  Â  // Canvas references
Â  Â  const pxCanvas = document.getElementById('pxCanvas');
Â  Â  const pxCtx = pxCanvas.getContext('2d');
Â  Â  const histogramCanvas = document.getElementById('histogramCanvas');
Â  Â  const histogramCtx = histogramCanvas.getContext('2d');
Â  Â  const pixelInfoDisplay = document.getElementById('pixelInfo');
Â  Â  const canvasRenderModeSelect = document.getElementById('canvasRenderMode');
Â  Â  const pixelGridToggle = document.getElementById('pixelGridToggle');
    const headerOnlyEncodeToggle = document.getElementById('headerOnlyEncodeToggle');

Â  Â  // File input handler
Â  Â  document.getElementById('fileInput').addEventListener('change', (e) => {
Â  Â  Â  document.getElementById('loadDigestFile').value = '';
Â  Â  Â  const file = e.target.files[0];
Â  Â  Â  if (!file) {
          originalBytes = null; // Clear bytes if no file selected
          originalFileName = 'reconstructed_file'; // Reset filename
          document.getElementById('metadata').textContent = 'No file selected.';
          return;
      }
Â  Â  Â Â 
Â  Â  Â  originalFileName = file.name; // Store the original file name
Â  Â  Â  const reader = new FileReader();
Â  Â  Â  reader.onload = function(event) {
Â  Â  Â  Â  originalBytes = new Uint8Array(event.target.result);
Â  Â  Â  Â  document.getElementById('metadata').textContent = `Loaded <span class="math-inline">\{file\.name\} \(</span>{originalBytes.length} bytes)`;
Â  Â  Â  Â  console.log(`File loaded: ${file.name}, ${originalBytes.length} bytes`);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Clear previous outputs
Â  Â  Â  Â  document.getElementById('digestOutput').value = '';
Â  Â  Â  Â  document.getElementById('headerPreview').textContent = '';
Â  Â  Â  Â  document.getElementById('ztxtEmitterOutput').textContent = '';
Â  Â  Â  };
Â  Â  Â  reader.readAsArrayBuffer(file);
Â  Â  });

Â  Â  // Canvas render mode change handler
Â  Â  canvasRenderModeSelect.addEventListener('change', () => {
Â  Â  Â  currentRenderMode = canvasRenderModeSelect.value;
Â  Â  Â  if (originalBytes && document.getElementById('pxCanvas').width > 0) {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  }
Â  Â  });

Â  Â  // Pixel grid toggle handler
Â  Â  pixelGridToggle.addEventListener('change', () => {
Â  Â  Â  if (originalBytes && document.getElementById('pxCanvas').width > 0) {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  }
Â  Â  });

Â  Â  // Canvas hover for pixel info
Â  Â  pxCanvas.addEventListener('mousemove', (e) => {
Â  Â  Â  if (!originalBytes || pxCanvas.width === 0 || pxCanvas.height === 0) {
Â  Â  Â  Â  pixelInfoDisplay.style.display = 'none';
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  const rect = pxCanvas.getBoundingClientRect();
Â  Â  Â  const scaleX = pxCanvas.width / rect.width;
Â  Â  Â  const scaleY = pxCanvas.height / rect.height;
Â  Â  Â  const x = Math.floor((e.clientX - rect.left) * scaleX);
Â  Â  Â  const y = Math.floor((e.clientY - rect.top) * scaleY);

Â  Â  Â  let bytesPerPixel = currentRenderMode === 'rgb' ? 3 : 1;
Â  Â  Â  const pixelIndex = y * pxCanvas.width + x;
Â  Â  Â  const byteOffset = pixelIndex * bytesPerPixel;

Â  Â  Â  let pixelBytes = [];
Â  Â  Â  for (let i = 0; i < bytesPerPixel; i++) {
Â  Â  Â  Â  if (byteOffset + i < originalBytes.length) {
Â  Â  Â  Â  Â  pixelBytes.push(originalBytes[byteOffset + i]);
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  pixelBytes.push(0);
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  let pixelInfoText = `X: ${x}, Y: <span class="math-inline">\{y\}\\nOffset\: 0x</span>{byteOffset.toString(16).padStart(6, '0')}`;
Â  Â  Â  if (bytesPerPixel === 3) {
Â  Â  Â  Â  pixelInfoText += `\nRGB: <span class="math-inline">\{pixelBytes\[0\]\},</span>{pixelBytes[1]},${pixelBytes[2]}`;
Â  Â  Â  } else {
Â  Â  Â  Â  pixelInfoText += `\nValue: ${pixelBytes[0]}`;
Â  Â  Â  }
Â  Â  Â  pixelInfoText += `\nHex: 0x${pixelBytes.map(b => b.toString(16).padStart(2, '0')).join('')}`;

Â  Â  Â  pixelInfoDisplay.style.display = 'block';
Â  Â  Â  const containerRect = pxCanvas.parentElement.getBoundingClientRect();
Â  Â  Â  let displayX = e.clientX - containerRect.left + 10;
Â  Â  Â  let displayY = e.clientY - containerRect.top + 10;

Â  Â  Â  if (displayX + 200 > containerRect.width) {
Â  Â  Â  Â  displayX = containerRect.width - 200;
Â  Â  Â  }
Â  Â  Â  if (displayY + 100 > containerRect.height) {
Â  Â  Â  Â  displayY = containerRect.height - 100;
Â  Â  Â  }

Â  Â  Â  pixelInfoDisplay.style.left = `${displayX}px`;
Â  Â  Â  pixelInfoDisplay.style.top = `${displayY}px`;
Â  Â  Â  pixelInfoDisplay.innerText = pixelInfoText;
Â  Â  });

Â  Â  pxCanvas.addEventListener('mouseleave', () => {
Â  Â  Â  pixelInfoDisplay.style.display = 'none';
Â  Â  });

Â  Â  // Load digest file handler
Â  Â  document.getElementById('loadDigestFile').addEventListener('change', (e) => {
Â  Â  Â  const file = e.target.files[0];
Â  Â  Â  if (!file) return;
Â  Â  Â Â 
Â  Â  Â  const reader = new FileReader();
Â  Â  Â  reader.onload = function(event) {
Â  Â  Â  Â  const digestContent = event.target.result;
Â  Â  Â  Â  document.getElementById('digestOutput').value = digestContent;
Â  Â  Â  Â  document.getElementById('digestSection').style.display = 'block';
Â  Â  Â  Â  showDigestOutput(); // Automatically show when loading from file
Â  Â  Â  Â  reconstructAndDownload(digestContent); // Call unified reconstruction function
Â  Â  Â  };
Â  Â  Â  reader.readAsText(file);
Â  Â  });

Â  Â  // Download digest function
Â  Â  function downloadDigest() {
Â  Â  Â  const digest = document.getElementById('digestOutput').value;
Â  Â  Â  if (!digest) {
Â  Â  Â  Â  alert('No digest to download. Please show digest data first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  const blob = new Blob([digest], { type: 'text/plain' });
Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  a.href = URL.createObjectURL(blob);
Â  Â  Â  a.download = `${originalFileName}.pxdigest`; // Use original filename for digest download
Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  a.click();
Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  URL.revokeObjectURL(a.href);
Â  Â  }

Â  Â  // Main digest and export function
Â  Â  async function digestAndExport() {
Â  Â  Â  console.log('Digest button clicked.');
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file loaded. Please upload a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }

Â  Â  Â  // Show processing indicator
Â  Â  Â  document.getElementById('metadata').textContent = `Processing ${originalBytes.length} bytes...`;

Â  Â  Â  try {
Â  Â  Â  Â  let reconstructionSpec = 'gzip-base64'; // Default to full compression
Â  Â  Â  Â  let reconstructionParam = '';
        let includeDataSection = true; // By default, include Base64/Hex data

Â  Â  Â  Â  if (headerOnlyEncodeToggle.checked) {
Â  Â  Â  Â  Â  const zeroFillTest = new Uint8Array(originalBytes.length).every(byte => byte === 0);
Â  Â  Â  Â  Â  if (zeroFillTest) {
Â  Â  Â  Â  Â  Â  reconstructionSpec = 'rebuild_zero_fill';
Â  Â  Â  Â  Â  Â  reconstructionParam = '0'; // Parameter can be the fill value
              includeDataSection = false; // Do not include data section for true header-only
Â  Â  Â  Â  Â  Â  alert('Detected all zeros. Encoding for Header-Only reconstruction (zero-fill).');
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  // More sophisticated pattern detection for repeating strings, etc. could go here.
Â  Â  Â  Â  Â  Â  // Example for repeating string (basic check, can be improved):
Â  Â  Â  Â  Â  Â  let detectedRepeatingPattern = '';
Â  Â  Â  Â  Â  Â  if (originalBytes.length > 0) {
Â  Â  Â  Â  Â  Â  Â  // Try to find a repeating pattern of length 1 to 10
Â  Â  Â  Â  Â  Â  Â  for (let len = 1; len <= 10 && len <= originalBytes.length; len++) {
Â  Â  Â  Â  Â  Â  Â  Â  const patternCandidate = new TextDecoder().decode(originalBytes.slice(0, len));
Â  Â  Â  Â  Â  Â  Â  Â  let isRepeating = true;
Â  Â  Â  Â  Â  Â  Â  Â  for (let i = len; i < originalBytes.length; i++) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (originalBytes[i] !== originalBytes[i % len]) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  isRepeating = false;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  if (isRepeating) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  detectedRepeatingPattern = patternCandidate;
Â  Â  Â  Â  Â  Â  Â  Â  Â  break;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if (detectedRepeatingPattern) {
Â  Â  Â  Â  Â  Â  Â  reconstructionSpec = 'rebuild_repeating_string';
Â  Â  Â  Â  Â  Â  Â  reconstructionParam = detectedRepeatingPattern;
              includeDataSection = false; // Do not include data section for true header-only
Â  Â  Â  Â  Â  Â  Â  alert(`Detected repeating string pattern: "${detectedRepeatingPattern}". Encoding for Header-Only reconstruction.`);
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  alert('Header-Only encoding is currently limited to all-zero or simple repeating string files. Full data will be included.');
Â  Â  Â  Â  Â  Â  Â  headerOnlyEncodeToggle.checked = false; // Uncheck it if not applicable
Â  Â  Â  Â  Â  Â  Â  reconstructionSpec = 'gzip-base64'; // Fallback to full data encoding
              includeDataSection = true;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  
Â  Â  Â  Â  let compressed = new Uint8Array(0);
Â  Â  Â  Â  let base64 = '';
Â  Â  Â  Â  let hex = '';
        let digestData = '';

Â  Â  Â  Â  if (includeDataSection) { // Only compress and include data section if explicitly requested or if header-only didn't apply
Â  Â  Â  Â  Â  Â  compressed = pako.gzip(originalBytes);
Â  Â  Â  Â  Â  Â  base64 = arrayBufferToBase64(compressed);
Â  Â  Â  Â  Â  Â  hex = arrayBufferToHex(compressed);
Â  Â  Â  Â  Â  Â  digestData = `\n\n[Base64]\n${base64}\n\n[Hex]\n${hex}`;
Â  Â  Â  Â  }

Â  Â  Â  Â  // Generate checksum (always of original bytes)
Â  Â  Â  Â  const hashBuffer = await crypto.subtle.digest('SHA-256', originalBytes.buffer);
Â  Â  Â  Â  const headerHash = Array.from(new Uint8Array(hashBuffer))
Â  Â  Â  Â  Â  .map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Construct the enhanced header with filename and reconstruction spec
Â  Â  Â  Â  const header = `PXDigest v2
filename:<span class="math-inline">\{originalFileName\}
compressed\:</span>{compressed.length}
original:<span class="math-inline">\{originalBytes\.length\}
checksum\:</span>{headerHash}
reconstruction-spec:<span class="math-inline">\{reconstructionSpec\}
reconstruction\-param\:</span>{reconstructionParam}`;

Â  Â  Â  Â  // Compute 4-pixel boot signature (first 12 bytes of SHA-256)
Â  Â  Â  Â  const hashBytes = new Uint8Array(hashBuffer);
Â  Â  Â  Â  const bootRGBs = [0, 3, 6, 9].map(i => [hashBytes[i], hashBytes[i+1], hashBytes[i+2]]);
Â  Â  Â  Â  const bootText = bootRGBs.map((rgb, i) => `128,${i} = <span class="math-inline">\{rgb\[0\]\},</span>{rgb[1]},${rgb[2]}`).join('\n');

Â  Â  Â  Â  // Auto-bloom registry
Â  Â  Â  Â  const digestIndex = {
Â  Â  Â  Â  Â  '28,63,165-177,95,8-103,48,213-229,77,212': 'pxgen/specs/run_tinycore_vm',
Â  Â  Â  Â  Â  // Add more known digests here as needed
Â  Â  Â  Â  };
Â  Â  Â  Â  const bootKey = bootRGBs.map(rgb => rgb.join(',')).join('-');
Â  Â  Â  Â  const matchedSpec = digestIndex[bootKey] || 'No match';

Â  Â  Â  Â  // Draw boot pixels
Â  Â  Â  Â  const bootCanvas = document.getElementById('pxCanvas');
Â  Â  Â  Â  const bootCtx = bootCanvas.getContext('2d');
Â  Â  Â  Â  bootCanvas.width = 200;
Â  Â  Â  Â  bootCanvas.height = 50;
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Clear canvas
Â  Â  Â  Â  bootCtx.fillStyle = '#000';
Â  Â  Â  Â  bootCtx.fillRect(0, 0, bootCanvas.width, bootCanvas.height);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Draw boot pixels
Â  Â  Â  Â  for (let i = 0; i < bootRGBs.length; i++) {
Â  Â  Â  Â  Â  const [r, g, b] = bootRGBs[i];
Â  Â  Â  Â  Â  bootCtx.fillStyle = `rgb(<span class="math-inline">\{r\},</span>{g},${b})`;
Â  Â  Â  Â  Â  bootCtx.fillRect(i * 30, 10, 25, 25);
Â  Â  Â  Â  }

Â  Â  Â  Â  // Generate digest string
Â  Â  Â  Â  const bootOnly = document.getElementById('bootOnlyToggle').checked;
Â  Â  Â  Â  const digest = `<span class="math-inline">\{header\}\\n</span>{bootText}${bootOnly ? '' : digestData}`;
Â  Â  Â  Â Â 
Â  Â  Â  Â  document.getElementById('digestOutput').value = digest;
Â  Â  Â  Â  console.log('Digest output written to textarea.');
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Update header preview
Â  Â  Â  Â  document.getElementById('headerPreview').textContent = `// PXDigest Header Info
${header}

// Boot Pixels
${bootText}

// Bloom Match
${bootKey} => ${matchedSpec}`;

Â  Â  Â  Â  // zTXt emitter output
Â  Â  Â  Â  const ztxtSpec = `# pxgen/specs/restore_from_digest
READ_ZT pxgen/input/compressed_digest
DECODE_GZIP_BASE64 TO CODE_FORGE_REGION
HALT`;
Â  Â  Â  Â  document.getElementById('ztxtEmitterOutput').textContent = ztxtSpec;

Â  Â  Â  Â  // Show sections but keep digest hidden by default
Â  Â  Â  Â  document.getElementById('canvasSection').style.display = 'block';
Â  Â  Â  Â  document.getElementById('digestSection').style.display = 'block';
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'none';
Â  Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'none';

Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Processed ${originalBytes.length} bytes successfully! Digest ready to view.`;

Â  Â  Â  } catch (error) {
Â  Â  Â  Â  console.error('Error during digest:', error);
Â  Â  Â  Â  alert('Error processing file: ' + error.message);
Â  Â  Â  }
Â  Â  }

    // Unified reconstruction function
Â  Â  async function reconstructAndDownload(digestContent = null) {
Â  Â  Â  const digest = digestContent || document.getElementById('digestOutput').value;
Â  Â  Â  if (!digest) {
Â  Â  Â  Â  alert('No digest to reconstruct from. Please load or generate a digest first.');
Â  Â  Â  Â  return null;
Â  Â  Â  }

Â  Â  Â  document.getElementById('metadata').textContent = 'Reconstructing file from digest...';

Â  Â  Â  // Parse all header fields more robustly
Â  Â  Â  let headerChecksum = '';
Â  Â  Â  let originalSize = 0;
Â  Â  Â  let fileNameFromDigest = 'reconstructed_file'; // Default
Â  Â  Â  let reconstructionSpec = '';
Â  Â  Â  let reconstructionParam = '';
Â  Â  Â  let base64Data = ''; // This will capture the full base64 data if present
Â  Â  Â  let inBase64Section = false;

Â  Â  Â  const lines = digest.split('\n');
Â  Â  Â  for (let line of lines) {
            const parts = line.split(':');
            if (parts.length > 1) { // Ensure line has a key-value pair
                const key = parts[0].trim();
                const value = parts.slice(1).join(':').trim(); // Join back if value has colons
                
                if (key === 'filename') {
                    fileNameFromDigest = value;
                } else if (key === 'checksum') {
                    headerChecksum = value;
                } else if (key === 'original') {
                    originalSize = parseInt(value, 10);
                } else if (key === 'reconstruction-spec') {
                    reconstructionSpec = value;
                } else if (key === 'reconstruction-param') {
                    reconstructionParam = value;
                }
            }
Â  Â  Â  Â  
            // Handle Base64/Hex sections
Â  Â  Â  Â  if (line === '[Base64]') {
Â  Â  Â  Â  Â  inBase64Section = true;
Â  Â  Â  Â  } else if (line === '[Hex]') {
Â  Â  Â  Â  Â  inBase64Section = false;
Â  Â  Â  Â  } else if (inBase64Section && line.trim()) {
Â  Â  Â  Â  Â  base64Data += line.trim();
Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  let reconstructedBytes = null;
Â  Â  Â  let reconstructionMethod = 'Unknown';

Â  Â  Â  // Attempt Header-Only Reconstruction IF a specific spec is found AND Base64 data is NOT present.
      // This enforces that it's *truly* header-only, not just a fallback.
Â  Â  Â  if (reconstructionSpec && reconstructionSpec !== 'gzip-base64' && !base64Data) {
Â  Â  Â  Â  Â  reconstructionMethod = 'Header-Only';
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  if (reconstructionSpec === 'rebuild_zero_fill') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  reconstructedBytes = rebuildZeroFill(originalSize);
Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('metadata').textContent = `Reconstructing via Header-Only (Zero-Fill)...`;
Â  Â  Â  Â  Â  Â  Â  } else if (reconstructionSpec === 'rebuild_repeating_string') {
Â  Â  Â  Â  Â  Â  Â  Â  Â  reconstructedBytes = rebuildRepeatingString(reconstructionParam, originalSize);
Â  Â  Â  Â  Â  Â  Â  Â  Â  document.getElementById('metadata').textContent = `Reconstructing via Header-Only (Repeating String)...`;
Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  console.warn(`Unknown reconstruction-spec in header: ${reconstructionSpec}. No Base64 data found for fallback.`);
Â  Â  Â  Â  Â  Â  Â  Â  Â  reconstructedBytes = null; // Cannot reconstruct with this spec and no data
Â  Â  Â  Â  Â  Â  Â  Â  Â  reconstructionMethod = 'Header-Only (Unknown Spec) Failed';
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  console.error(`Header-Only reconstruction failed for spec ${reconstructionSpec}:`, e);
Â  Â  Â  Â  Â  Â  Â  alert(`Header-Only reconstruction failed for ${reconstructionSpec}: ${e.message}. No Base64 data for fallback.`);
Â  Â  Â  Â  Â  Â  Â  reconstructedBytes = null; // Cannot reconstruct
Â  Â  Â  Â  Â  Â  Â  reconstructionMethod = 'Header-Only (Error) Failed';
Â  Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  // Fallback to Base64 Reconstruction if Header-Only didn't work or wasn't applicable, AND Base64 data IS present
Â  Â  Â  if (!reconstructedBytes && base64Data) {
Â  Â  Â  Â  Â  reconstructionMethod = (reconstructionMethod === 'Unknown' ? 'Base64' : reconstructionMethod + ' Base64 Fallback');
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  const binary = base64ToArrayBuffer(base64Data);
Â  Â  Â  Â  Â  Â  Â  const compressed = new Uint8Array(binary);
Â  Â  Â  Â  Â  Â  Â  reconstructedBytes = pako.ungzip(compressed);
Â  Â  Â  Â  Â  Â  Â  document.getElementById('metadata').textContent = `Reconstructing via Base64...`;
Â  Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  Â  Â  console.error('Base64 reconstruction failed:', e);
Â  Â  Â  Â  Â  Â  Â  alert('Error decoding/decompressing Base64 data: ' + e.message);
Â  Â  Â  Â  Â  Â  Â  document.getElementById('metadata').textContent = `âŒ Reconstruction failed (Base64): ${e.message}`;
Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  }
Â  Â  Â  } else if (!reconstructedBytes) {
Â  Â  Â  Â  Â  // If still no bytes after all attempts
Â  Â  Â  Â  Â  alert('No valid reconstruction method found or data available in digest. Ensure your digest contains Base64 data OR a recognized header-only spec with no Base64 data.');
Â  Â  Â  Â  Â  document.getElementById('metadata').textContent = 'âŒ Reconstruction failed: No data or valid spec.';
Â  Â  Â  Â  Â  return null;
Â  Â  Â  }
Â  Â  Â  
Â  Â  Â  originalBytes = reconstructedBytes; // Update global originalBytes for canvas rendering

Â  Â  Â  // Verify checksum
Â  Â  Â  const hashBuffer = await crypto.subtle.digest('SHA-256', reconstructedBytes.buffer);
Â  Â  Â  const verifyHash = Array.from(new Uint8Array(hashBuffer))
Â  Â  Â  Â  .map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  
Â  Â  Â  let checksumStatus = verifyHash === headerChecksum
Â  Â  Â  Â  ? 'OK'
Â  Â  Â  Â  : 'MISMATCH';
Â  Â  Â  
Â  Â  Â  // Verify original size
Â  Â  Â  let sizeStatus = 'OK';
Â  Â  Â  if (originalSize > 0 && reconstructedBytes.length !== originalSize) {
Â  Â  Â  Â  Â  sizeStatus = 'MISMATCH';
Â  Â  Â  }

Â  Â  Â  const finalStatusMsg = `âœ… Reconstructed ${reconstructedBytes.length} bytes (Method: ${reconstructionMethod}, Checksum: ${checksumStatus}, Size: ${sizeStatus})`;
Â  Â  Â  document.getElementById('metadata').textContent = finalStatusMsg;

Â  Â  Â  if (checksumStatus === 'MISMATCH' || sizeStatus === 'MISMATCH') {
Â  Â  Â  Â  Â  alert(`Warning: Reconstruction complete but issues found! Checksum: ${checksumStatus}, Size: ${sizeStatus}`);
Â  Â  Â  }

Â  Â  Â  // Trigger download
Â  Â  Â  const blob = new Blob([reconstructedBytes], { type: 'application/octet-stream' });
Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  a.href = URL.createObjectURL(blob);
Â  Â  Â  a.download = fileNameFromDigest;
Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  a.click();
Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  URL.revokeObjectURL(a.href);
Â  Â  Â  
Â  Â  Â  // Show canvas and histogram if data is available
Â  Â  Â  if (reconstructedBytes.length > 0) {
Â  Â  Â  Â  drawFromBytesOptimized(reconstructedBytes);
Â  Â  Â  Â  drawHistogram(reconstructedBytes); // Assuming drawHistogram exists and is robust
Â  Â  Â  Â  document.getElementById('canvasSection').style.display = 'block';
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  }


Â  Â  Â  return reconstructedBytes; // Return the reconstructed bytes for further use (e.g., canvas rendering)
Â  Â  }

    // Helper functions for Header-Only reconstruction
    function rebuildZeroFill(size) {
        if (typeof size !== 'number' || size < 0) {
            throw new Error("Invalid size for zero-fill reconstruction.");
        }
        return new Uint8Array(size); // Automatically filled with zeros
    }

    function rebuildRepeatingString(pattern, size) {
        if (!pattern) {
            throw new Error("Repeating string pattern is empty.");
        }
        if (typeof size !== 'number' || size < 0) {
            throw new Error("Invalid size for repeating string reconstruction.");
        }
        // Using TextEncoder to handle various characters correctly
        const patternBytes = new TextEncoder().encode(pattern);
        if (patternBytes.length === 0) {
            throw new Error("Encoded repeating string pattern is empty.");
        }
        const bytes = new Uint8Array(size);
        for (let i = 0; i < size; i++) {
            bytes[i] = patternBytes[i % patternBytes.length];
        }
        return bytes;
    }


Â  Â  // Draw pixels from bytes (original, non-optimized version - kept for reference)
Â  Â  // This function is effectively replaced by drawFromBytesOptimized for actual use.
Â  Â  function drawFromBytes(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â  const w = Math.ceil(Math.sqrt(totalPixels));
Â  Â  Â  const h = Math.ceil(totalPixels / w);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let b of bytes) entropyBin[b]++;
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / bytes.length;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < bytes.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = bytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = bytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = bytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;                // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Animate bloom effect
Â  Â  Â  let radius = 1;
Â  Â  Â  function bloomStep() {
Â  Â  Â  Â  ctx.beginPath();
Â  Â  Â  Â  ctx.arc(20, 20, radius, 0, 2 * Math.PI);
Â  Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  Â  ctx.stroke();
Â  Â  Â  Â  radius += 3;
Â  Â  Â  Â  if (radius < 50) requestAnimationFrame(bloomStep);
Â  Â  Â  }
Â  Â  Â  bloomStep();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let i = 0; i < sampleSize; i++) {
Â  Â  Â  Â  entropyBin[sampledBytes[i]]++;
Â  Â  Â  }
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let i = 0; i < sampleSize; i++) {
Â  Â  Â  Â  entropyBin[sampledBytes[i]]++;
Â  Â  Â  }
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let i = 0; i < sampleSize; i++) {
Â  Â  Â  Â  entropyBin[sampledBytes[i]]++;
Â  Â  Â  }
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let i = 0; i < sampleSize; i++) {
Â  Â  Â  Â  entropyBin[sampledBytes[i]]++;
Â  Â  Â  }
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let b of bytes) entropyBin[b]++;
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let b of bytes) entropyBin[b]++;
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let b of bytes) entropyBin[b]++;
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let b of bytes) entropyBin[b]++;
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let b of bytes) entropyBin[b]++;
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let b of bytes) entropyBin[b]++;
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let b of bytes) entropyBin[b]++;
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  }).catch(function(err) {
Â  Â  Â  Â  // Fallback for older browsers
Â  Â  Â  Â  const textArea = document.createElement('textarea');
Â  Â  Â  Â  textArea.value = headerText;
Â  Â  Â  Â  document.body.appendChild(textArea);
Â  Â  Â  Â  textArea.select();
Â  Â  Â  Â  document.execCommand('copy');
Â  Â  Â  Â  document.body.removeChild(textArea);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  }, 2000);
Â  Â  Â  });
Â  Â  }

Â  Â  // Function to show digest output on demand
Â  Â  function showDigestOutput() {
Â  Â  Â  const digestTextarea = document.getElementById('digestOutput');
Â  Â  Â  if (!digestTextarea.value) {
Â  Â  Â  Â  alert('No digest data available to show.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  digestTextarea.style.display = 'block';
Â  Â  Â  document.getElementById('downloadDigestBtn').style.display = 'inline-block';
Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Digest data displayed! (${digestTextarea.value.length} characters)`;
Â  Â  }

Â  Â  // Function to render the canvas on demand
Â  Â  function renderCanvas() {
Â  Â  Â  if (!originalBytes) {
Â  Â  Â  Â  alert('No file data available to render.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  document.getElementById('metadata').textContent = 'Rendering visual representation...';
Â  Â  Â Â 
Â  Â  Â  // Use setTimeout to allow UI to update
Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  drawFromBytesOptimized(originalBytes);
Â  Â  Â  Â  document.getElementById('downloadPNGBtn').style.display = 'inline-block';
Â  Â  Â  Â  document.getElementById('metadata').textContent = `âœ… Canvas rendered! (${originalBytes.length} bytes visualized)`;
Â  Â  Â  }, 100);
Â  Â  }

Â  Â  // Function to download canvas as PNG
Â  Â  function downloadCanvasPNG() {
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  if (!canvas.width || !canvas.height) {
Â  Â  Â  Â  alert('No canvas to download. Please render the canvas first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Create download link
Â  Â  Â  canvas.toBlob(function(blob) {
Â  Â  Â  Â  const url = URL.createObjectURL(blob);
Â  Â  Â  Â  const a = document.createElement('a');
Â  Â  Â  Â  a.href = url;
Â  Â  Â  Â  a.download = 'pxdigest_visualization.png';
Â  Â  Â  Â  document.body.appendChild(a);
Â  Â  Â  Â  a.click();
Â  Â  Â  Â  document.body.removeChild(a);
Â  Â  Â  Â  URL.revokeObjectURL(url);
Â  Â  Â  }, 'image/png');
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Base64 in chunks
Â  Â  function arrayBufferToBase64(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += btoa(String.fromCharCode.apply(null, chunk));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert ArrayBuffer to Hex in chunks
Â  Â  function arrayBufferToHex(buffer) {
Â  Â  Â  const bytes = new Uint8Array(buffer);
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  let result = '';
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < bytes.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = bytes.slice(i, i + chunkSize);
Â  Â  Â  Â  result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result;
Â  Â  }

Â  Â  // Helper function to convert Base64 to ArrayBuffer in chunks
Â  Â  function base64ToArrayBuffer(base64) {
Â  Â  Â  const chunkSize = 8192; // Process in 8KB chunks
Â  Â  Â  const chunks = [];
Â  Â  Â Â 
Â  Â  Â  for (let i = 0; i < base64.length; i += chunkSize) {
Â  Â  Â  Â  const chunk = base64.slice(i, i + chunkSize);
Â  Â  Â  Â  const binary = atob(chunk);
Â  Â  Â  Â  const bytes = new Uint8Array(binary.length);
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let j = 0; j < binary.length; j++) {
Â  Â  Â  Â  Â  bytes[j] = binary.charCodeAt(j);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  chunks.push(bytes);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Combine all chunks
Â  Â  Â  const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
Â  Â  Â  const result = new Uint8Array(totalLength);
Â  Â  Â  let offset = 0;
Â  Â  Â Â 
Â  Â  Â  for (const chunk of chunks) {
Â  Â  Â  Â  result.set(chunk, offset);
Â  Â  Â  Â  offset += chunk.length;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  return result.buffer;
Â  Â  }

Â  Â  // Optimized drawFromBytes function for large files
Â  Â  function drawFromBytesOptimized(bytes) {
Â  Â  Â  console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
Â  Â  Â Â 
Â  Â  Â  const canvas = document.getElementById('pxCanvas');
Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â Â 
Â  Â  Â  // Limit canvas size for performance
Â  Â  Â  const maxDimension = 1024;
Â  Â  Â  let totalPixels = Math.ceil(bytes.length / 3);
Â  Â  Â Â 
Â  Â  Â  // Sample data if too large
Â  Â  Â  let sampledBytes = bytes;
Â  Â  Â  if (bytes.length > maxDimension * maxDimension * 3) {
Â  Â  Â  Â  const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
Â  Â  Â  Â  sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
Â  Â  Â  Â  for (let i = 0; i < sampledBytes.length; i++) {
Â  Â  Â  Â  Â  sampledBytes[i] = bytes[i * sampleRate];
Â  Â  Â  Â  }
Â  Â  Â  Â  totalPixels = Math.ceil(sampledBytes.length / 3);
Â  Â  Â  Â  console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Calculate canvas dimensions
Â  Â  Â  const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
Â  Â  Â  const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
Â  Â  Â  canvas.width = w;
Â  Â  Â  canvas.height = h;
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

Â  Â  Â  // Calculate entropy on a sample
Â  Â  Â  const sampleSize = Math.min(sampledBytes.length, 100000);
Â  Â  Â  const entropyBin = new Array(256).fill(0);
Â  Â  Â  for (let b of bytes) entropyBin[b]++;
Â  Â  Â  const entropy = -entropyBin.reduce((acc, n) => {
Â  Â  Â  Â  if (n === 0) return acc;
Â  Â  Â  Â  const p = n / sampleSize;
Â  Â  Â  Â  return acc + p * Math.log2(p);
Â  Â  Â  }, 0);
Â  Â  Â Â 
Â  Â  Â  console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

Â  Â  Â  // Create image data
Â  Â  Â  const imgData = ctx.createImageData(w, h);
Â  Â  Â  let j = 0;
Â  Â  Â  for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i];Â  Â  Â  Â  Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+1] || 0;Â  Â  // G
Â  Â  Â  Â  imgData.data[j++] = sampledBytes[i+2] || 0;Â  Â  // B
Â  Â  Â  Â  imgData.data[j++] = 255;Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  // Fill remaining pixels with black
Â  Â  Â  while (j < imgData.data.length) {
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // R
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // G
Â  Â  Â  Â  imgData.data[j++] = 0;Â  Â // B
Â  Â  Â  Â  imgData.data[j++] = 255; // A
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  ctx.putImageData(imgData, 0, 0);
Â  Â  Â Â 
Â  Â  Â  // Add entropy text overlay
Â  Â  Â  ctx.font = '12px monospace';
Â  Â  Â  ctx.fillStyle = 'rgba(255,255,0,0.8)';
Â  Â  Â  ctx.strokeStyle = 'rgba(0,0,0,0.8)';
Â  Â  Â  ctx.lineWidth = 2;
Â  Â  Â  const text = `Entropy: ${entropy.toFixed(2)} bpb`;
Â  Â  Â  ctx.strokeText(text, 5, h - 10);
Â  Â  Â  ctx.fillText(text, 5, h - 10);
Â  Â  Â Â 
Â  Â  Â  console.log('[PXDigest] Pixel data rendered to canvas.');

Â  Â  Â  // Simple bloom effect
Â  Â  Â  ctx.beginPath();
Â  Â  Â  ctx.arc(20, 20, 10, 0, 2 * Math.PI);
Â  Â  Â  ctx.strokeStyle = 'lime';
Â  Â  Â  ctx.lineWidth = 3;
Â  Â  Â  ctx.stroke();
Â  Â  }

Â  Â  // Function to copy header preview to clipboard
Â  Â  function copyHeaderPreview() {
Â  Â  Â  const headerText = document.getElementById('headerPreview').textContent;
Â  Â  Â  if (!headerText || headerText === 'No file processed yet...') {
Â  Â  Â  Â  alert('No header data to copy. Please process a file first.');
Â  Â  Â  Â  return;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  navigator.clipboard.writeText(headerText).then(function() {
Â  Â  Â  Â  // Visual feedback
Â  Â  Â  Â  const button = event.target;
Â  Â  Â  Â  const originalText = button.textContent;
Â  Â  Â  Â  button.textContent = 'âœ… Copied!';
Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
Â  Â  Â  Â Â 
Â  Â  Â  Â  setTimeout(() => {
Â  Â  Â  Â  Â  button.textContent = originalText;
Â  Â  Â  Â  Â  button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
Â  Â  Â  Â  },