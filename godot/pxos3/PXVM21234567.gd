# PXVM.gd
# This script simulates the PXTalk Virtual Machine execution environment.
# It is designed to be instantiated and managed by PXBootSim.gd,
# receiving the selected ISO path and a reference to PXBootSim for logging.

extends Node

# Dictionary to simulate PXRAM, storing variables and their values
var pxram: Dictionary = {
	"kernel_offset": 0,
	"kernel_size": 0,
	"initrd_offset": 0,
	"initrd_size": 0,
	"kernel_data": null,
	"initrd_data": null,
	"root_dir_lba": 0,   # LBA of the root directory (from PVD)
	"root_dir_size": 0,  # Size of the root directory (from PVD)
	"iso_parsed_files": {}, # Stores dynamically parsed file/directory info: { "full/path/to/file": { "lba": X, "size": Y, "is_dir": bool } }
	"iso_dir_map": {} # Stores metadata for directories: { "path_key": { "lba": X, "size": Y } }
}

# Path to the ISO file to be loaded (now set dynamically by PXBootSim.gd)
var iso_file_path: String = "" 

# FileAccess object for reading the ISO
var iso_file_access: FileAccess = null

# Reference to the PXBootSim for logging (set dynamically by PXBootSim.gd)
var px_boot_sim = null 

# --- Simulated Embedded PXTalk Boot Script ---
# This simulates the 'boot.pxtalk' file that would be generated by your Python compiler
# and theoretically embedded within the ISO.
# You should replace this string with the actual content of your generated tinycore_boot.pxtalk.
# This version defaults to PX_LAUNCH_QEMU for real boot, or PX_EXEC_KERNEL for simulation.
var embedded_pxtalk_boot_script_content: String = """
PX_LOG "[PXBIOS] Embedded boot.pxtalk executing..."

# MBR and PVD checks (conceptual, as PXVM already does this)
# Note: "tinycore.iso" here is a placeholder in the PXTalk script,
# the PXVM's _execute_px_read_bytes will use the dynamically set iso_file_path.
PX_READ_BYTES "tinycore.iso" 0 512 -> mbr_data
PX_COMPARE mbr_data 0x1FE 0xAA55 THEN "LABEL MBR_OK" ELSE "PX_HALT"
LABEL MBR_OK
PX_READ_ISO_PVD # This would internally verify CD001 and get root_dir_lba/size
PX_LOG "[PXBIOS] ISO structure validated by embedded script."

# Dynamically discovered kernel and initrd locations (replace with actual values from your compiler output)
# These are example values; use the ones from your compiled tinycore_boot.pxtalk
PX_SET kernel_offset 1048576
PX_SET kernel_size 8388608
PX_SET initrd_offset 6291456
PX_SET initrd_size 16777216

PX_LOG "[PXBIOS] Found kernel at offset $kernel_offset (size $kernel_size)"
PX_LOG "[PXBIOS] Found initrd at offset $initrd_offset (size $initrd_size)"

# Read kernel and initrd data into PXRAM
PX_READ_BYTES "tinycore.iso" $kernel_offset $kernel_size -> kernel_data
PX_READ_BYTES "tinycore.iso" $initrd_offset $initrd_size -> initrd_data

PX_LOG "[PXBIOS] Kernel and Initrd loaded. Handoff to real QEMU or simulation..."
# Uncomment ONE of these lines to choose the handoff method:
PX_LAUNCH_QEMU # Handoff to real QEMU (requires QEMU installed)
# PX_EXEC_KERNEL # Handoff to simulated kernel (PXOSUIScreen.gd)
"""
# --- End Simulated Embedded PXTalk Boot Script ---


# -------------------
# SYSTEM INIT
# -------------------

func _ready():
    # Phase 2: Modify PXVM.gd _ready() to use the selected ISO:
    # PXVM is now instantiated by PXBootSim.gd and its _ready() is called.
    # We wait for PXBootSim.gd to call set_iso_path and set_px_boot_sim.
    pass 


# --- Phase 1: Finalize PXVM.gd Integration: set_iso_path and set_px_boot_sim ---
func set_iso_path(path: String):
    iso_file_path = path
    # Once the ISO path is set, we can attempt to open the file and start the boot sequence.
    if _open_iso_file(iso_file_path):
        _execute_px_exec_script(embedded_pxtalk_boot_script_content)

func set_px_boot_sim(sim_node):
    px_boot_sim = sim_node
# --- End Phase 1 ---


func _exit_tree():
	if iso_file_access:
		iso_file_access.close()
		iso_file_access = null

func _open_iso_file(path: String) -> bool:
	if iso_file_access:
		iso_file_access.close()
		iso_file_access = null

	iso_file_access = FileAccess.open(path, FileAccess.READ)
	if iso_file_access == null:
		_execute_px_log(f"[PXBIOS] ERROR: Could not open ISO file: {path}. Error: {FileAccess.get_open_error()}")
		return false
	_execute_px_log(f"[PXBIOS] ISO file opened: {path}")
	return true

# -------------------
# PXTalk Emulation (Now driven by _execute_px_exec_script)
# -------------------

func _execute_px_exec_script(script_content: String):
    _execute_px_log("[PXBIOS] Executing embedded PXTalk boot script...")
    var lines = script_content.split("\n")
    var labels = {} # To store LABEL positions for PX_JUMP/THEN

    # First pass: identify labels
    for i in range(lines.size()):
        var line = lines[i].strip_edges()
        if line.begins_with("LABEL "):
            var label_name = line.replace("LABEL ", "").strip_edges()
            labels[label_name] = i

    var current_line_index = 0
    while current_line_index < lines.size():
        var line = lines[current_line_index].strip_edges()
        if line.empty() or line.begins_with("#") or line.begins_with("LABEL "):
            current_line_index += 1
            continue

        var parts = line.split(" ", false)
        var instruction = parts[0].to_upper()
        var args = parts.slice(1)

        match instruction:
            "PX_LOG":
                var message = line.replace("PX_LOG ", "").strip_edges()
                # Replace PXRAM variables like $kernel_offset
                for key in pxram.keys():
                    message = message.replace(f"${key}", str(pxram.get(key, 'N/A')))
                _execute_px_log(message)
            "PX_READ_BYTES":
                if args.size() >= 4:
                    # The PXTalk script might have "tinycore.iso" as source_file,
                    # but we use the dynamically selected self.iso_file_path for the actual read.
                    var source_file_in_script = args[0].strip_edges().trim_prefix("\"").trim_suffix("\"") # This is ignored for actual read
                    var offset_str = args[1]
                    var length_str = args[2]
                    var target_pxram_key = args[3].trim_prefix("->").strip_edges()

                    var offset = int(offset_str) if not offset_str.begins_with("$") else pxram.get(offset_str.trim_prefix("$"), 0)
                    var length = int(length_str) if not length_str.begins_with("$") else pxram.get(length_str.trim_prefix("$"), 0)

                    _execute_px_read_bytes(self.iso_file_path, offset, length, target_pxram_key) # Use self.iso_file_path
                else:
                    _execute_px_log("[PXTalk] ERROR: PX_READ_BYTES: Missing arguments.")
                    return # Halt script execution on error
            "PX_COMPARE":
                if args.size() >= 5: # data_key, offset, expected_value, THEN, LABEL
                    var data_key = args[0]
                    var offset = int(args[1])
                    var expected_value = int(args[2], 0) # Auto-detect base (0x for hex)
                    var then_keyword = args[3].to_upper()
                    var target_label = args[4]

                    var result = _execute_px_compare(data_key, offset, expected_value)
                    if result and then_keyword == "THEN" and labels.has(target_label):
                        current_line_index = labels[target_label] # Jump
                        continue # Continue from new line index
                    elif not result and then_keyword == "ELSE" and labels.has(target_label): # Optional ELSE
                        current_line_index = labels[target_label] # Jump
                        continue # Continue from new line index
                else:
                    _execute_px_log("[PXTalk] ERROR: PX_COMPARE: Missing arguments.")
                    return # Halt script execution on error
            "PX_READ_ISO_PVD":
                if not _execute_px_read_iso_pvd():
                    _execute_px_log("[PXTalk] ERROR: PX_READ_ISO_PVD failed. Halting.")
                    return # Halt script execution on error
            "PX_SET":
                if args.size() >= 2:
                    var var_name = args[0]
                    var value_str = args[1]
                    var value
                    if value_str.begins_with("$"): # If value is another PXRAM variable
                        value = pxram.get(value_str.trim_prefix("$"), 0)
                    elif value_str.begins_with("0x"): # Hex value
                        value = int(value_str, 16)
                    else: # Decimal value
                        value = int(value_str)
                    pxram[var_name] = value
                else:
                    _execute_px_log("[PXTalk] ERROR: PX_SET: Missing arguments.")
                    return # Halt script execution on error
            "PX_EXEC_KERNEL": # Phase 4: PX_EXEC_KERNEL triggers handoff
                _execute_px_exec_kernel()
                return # Handoff, so script execution ends
            "PX_LAUNCH_QEMU":
                _execute_px_launch_qemu()
                return # Handoff, so script execution ends
            "PX_HALT":
                _execute_px_log("[PXTalk] PX_HALT instruction encountered. Stopping boot.")
                return # Stop script execution
            "PX_JUMP":
                if args.size() >= 1:
                    var target_label = args[0]
                    if labels.has(target_label):
                        current_line_index = labels[target_label]
                        continue # Continue from new line index
                    else:
                        _execute_px_log(f"[PXTalk] ERROR: PX_JUMP: Label '{target_label}' not found.")
                        return # Halt script execution on error
                else:
                    _execute_px_log("[PXTalk] ERROR: PX_JUMP: Missing label argument.")
                    return # Halt script execution on error
            _:
                _execute_px_log(f"[PXTalk] ERROR: Unknown PXTalk instruction: {instruction}")
                return # Halt script execution on unknown instruction
        
        current_line_index += 1
    _execute_px_log("[PXBIOS] PXTalk script finished execution.")


func _execute_px_log(message: String):
	print(message) # Print to Godot console for debugging
	if px_boot_sim:
		px_boot_sim._process_px_log_message(message)

func _execute_px_compare(data_key: String, offset: int, expected_value: int) -> bool:
	var data: PoolByteArray = pxram.get(data_key)
	if not data or offset + 2 > data.size():
		_execute_px_log(f"[PXBIOS] ERROR: Compare data '{data_key}' not available or too small.")
		return false
	var val = (data[offset+1] << 8) | data[offset] # Read as little-endian 16-bit
	if val == expected_value:
		_execute_px_log(f"[PXBIOS] Verified {data_key} signature: 0x{expected_value:X}")
		return true
	else:
		_execute_px_log(f"[PXBIOS] ERROR: {data_key} signature mismatch: 0x{val:X} (expected 0x{expected_value:X}).")
		return false

# Phase 3: Make PXVM read the real ISO
func _execute_px_read_bytes(source_file_placeholder: String, offset: int, length: int, target_pxram_key: String):
	# source_file_placeholder is from the PXTalk script, but we use the dynamically selected self.iso_file_path
	if not iso_file_access or iso_file_access.get_path() != self.iso_file_path:
		_execute_px_log(f"[PXBIOS] ERROR: ISO file '{self.iso_file_path}' not open or incorrect for PX_READ_BYTES.")
		pxram[target_pxram_key] = null
		return

	if offset < 0 or length <= 0:
		_execute_px_log(f"[PXBIOS] ERROR: Invalid offset ({offset}) or length ({length}) for PX_READ_BYTES.")
		pxram[target_pxram_key] = null
		return

	# Seek to the specified offset
	iso_file_access.seek(offset)
	
	# Read the bytes
	var data = iso_file_access.get_buffer(length)
	
	if data.size() != length:
		_execute_px_log(f"[PXBIOS] WARNING: Read {data.size()} bytes, expected {length} for {target_pxram_key}. Partial read.")

	pxram[target_pxram_key] = data
	_execute_px_log(f"[PXBIOS] Read {data.size()} bytes for {target_pxram_key} from offset {offset}.")


func _execute_px_read_iso_pvd() -> bool:
	var pvd_offset = 0x8000 # Standard PVD location (sector 16 * 2048 bytes/sector)
	var pvd_length = 2048   # Standard PVD size (one sector)

	_execute_px_read_bytes(iso_file_path, pvd_offset, pvd_length, "pvd_data")
	var pvd_data: PoolByteArray = pxram.get("pvd_data")
	if pvd_data == null or pvd_data.size() < 156:
		_execute_px_log("[PXBIOS] ERROR: Failed to read PVD or PVD too small.")
		return false

	var identifier_string = pvd_data.slice(1, 6).get_string_from_ascii()

	if identifier_string == "CD001":
		_execute_px_log("[PXBIOS] ISO9660 structure detected: CD001")
		
		pxram["root_dir_lba"] = _read_le_uint32(pvd_data, 158)
		pxram["root_dir_size"] = _read_le_uint32(pvd_data, 166)

		_execute_px_log(f"[PXBIOS] Root Directory at LBA: {pxram['root_dir_lba']} (Size: {pxram['root_dir_size']} bytes)")
		return true
	else:
		_execute_px_log(f"[PXBIOS] ERROR: Invalid ISO9660 PVD signature: '{identifier_string}' (expected 'CD001').")
		return false

# Phase 4: PX_EXEC_KERNEL triggers handoff
func _execute_px_exec_kernel():
    px_boot_sim._process_px_log_message("[PXVM] PX_EXEC_KERNEL reached. Handoff to simulated OS.")
    # Phase 5: (Optional) Spawn PXOSUIScreen if available
    var screen = load("res://PXOSUIScreen.tscn").instantiate()
    get_tree().root.add_child(screen)
    # Pass PXRAM to the PXOSUIScreen if it has a setter method
    if screen.has_method("set_pxram_data"):
        screen.set_pxram_data(pxram)
    
    # Hide and free the current scene (PXBootSim)
    if get_tree().current_scene:
        get_tree().current_scene.queue_free()
    get_tree().current_scene = screen # Set the new scene as current


func _execute_px_launch_qemu():
	_execute_px_log("[PXBIOS] Attempting QEMU Handoff...")

	var kernel_data_bytes: PoolByteArray = pxram.get("kernel_data")
	var initrd_data_bytes: PoolByteArray = pxram.get("initrd_data")

	if not kernel_data_bytes or kernel_data_bytes.empty():
		_execute_px_log("[PXBIOS] ERROR: No kernel_data found for QEMU launch.")
		return
	if not initrd_data_bytes or initrd_data_bytes.empty():
		_execute_px_log("[PXBIOS] ERROR: No initrd_data found for QEMU launch.")
		return

	var kernel_path = "user://vmlinuz"
	var initrd_path = "user://core.gz"

	var file = FileAccess.open(kernel_path, FileAccess.WRITE)
	if file:
		file.store_buffer(kernel_data_bytes)
		file.close()
		_execute_px_log(f"[PXBIOS] Saved kernel to: {ProjectSettings.globalize_path(kernel_path)}")
	else:
		_execute_px_log(f"[PXBIOS] ERROR: Could not save kernel to {kernel_path}.")
		return

	file = FileAccess.open(initrd_path, FileAccess.WRITE)
	if file:
		file.store_buffer(initrd_data_bytes)
		file.close()
		_execute_px_log(f"[PXBIOS] Saved initrd to: {ProjectSettings.globalize_path(initrd_path)}")
	else:
		_execute_px_log(f"[PXBIOS] ERROR: Could not save initrd to {initrd_path}.")
		return

	var qemu_cmd = "qemu-system-x86_64"
	var qemu_args = [
		"-kernel", ProjectSettings.globalize_path(kernel_path),
		"-initrd", ProjectSettings.globalize_path(initrd_path),
		"-append", "console=ttyS0",
		"-nographic",
		"-m", "128M"
	]

	_execute_px_log(f"[PXBIOS] Launching QEMU: {qemu_cmd} {' '.join(qemu_args)}")
	_execute_px_log("[PXBIOS] Check your system's terminal/console for QEMU output.")
	_execute_px_log("[PXBIOS] QEMU will run in the background. Close its window/process to return.")

	var pid = OS.execute(qemu_cmd, qemu_args, true)
	
	if pid != -1:
		_execute_px_log(f"[PXBIOS] QEMU launched with PID: {pid}. PXVM continues execution.")
		get_tree().quit()
	else:
		_execute_px_log("[PXBIOS] ERROR: Failed to launch QEMU. Is 'qemu-system-x86_64' in your PATH?")
		_execute_px_log("[PXBIOS] Falling back to simulated kernel handoff...")
		_execute_px_exec_kernel()


# Utils for reading multi-byte integers from PoolByteArray
func _read_le_uint32(data: PoolByteArray, offset: int) -> int:
	if offset + 4 > data.size(): return 0
	return (data[offset+3] << 24) | (data[offset+2] << 16) | (data[offset+1] << 8) | data[offset]

func _read_be_uint32(data: PoolByteArray, offset: int) -> int:
	if offset + 4 > data.size(): return 0
	return (data[offset] << 24) | (data[offset+1] << 16) | (data[offset+2] << 8) | data[offset+3]

