### PXCompiler.gd
# Converts PXTalk source code into structured bytecode for PXVM execution.

extends Node

class_name PXCompiler

func compile(source_text: String) -> Dictionary:
    var lines = source_text.strip_edges(true, true).split("\n")
    var instructions = []

    for line in lines:
        line = line.strip_edges()
        if line == "" or line.begins_with("#"):
            continue # Skip empty lines or comments

        var tokens = line.split(" ", false)
        var opcode = tokens[0].to_upper()
        var args = tokens.slice(1, tokens.size())

        match opcode:
            "PRINT":
                instructions.append({"opcode": "PRINT", "args": [_join_args(args)]})
            "VAR", "SET_VAR":
                if args.size() >= 3 and args[1] == "=":
                    instructions.append({"opcode": "SET_VAR", "args": [args[0], _parse_literal(args[2])]})
            "JUMP":
                instructions.append({"opcode": "JUMP", "args": [int(args[0])]})
            "READ":
                instructions.append({"opcode": "READ_FILE", "args": [_join_args(args)]})
            "WRITE":
                if args.size() >= 2:
                    instructions.append({"opcode": "WRITE_FILE", "args": [args[0], _join_args(args.slice(1, args.size()))]})
            "SHELL":
                instructions.append({"opcode": "SHELL_COMMAND", "args": args})
            "HALT":
                instructions.append({"opcode": "HALT", "args": []})
            _:
                instructions.append({"opcode": "UNKNOWN", "args": [line]})

    return {"instructions": instructions}

func _join_args(args: Array) -> String:
    return " ".join(args).strip_edges()

func _parse_literal(value: String) -> Variant:
    if value.is_valid_float():
        return float(value)
    elif value.is_valid_integer():
        return int(value)
    elif value.begins_with("\"") and value.ends_with("\""):
        return value.strip_edges().substr(1, value.length() - 2)
    return value


### PXVM.gd
# Executes PXApp bytecode generated by PXCompiler

extends Node

class_name PXVM

signal vm_output(msg)

var shell_callback = null # Function to call shell commands (can be passed in)
var file_system = null # PXRAM or virtual FS reference

func execute(app_data: Dictionary):
    var instructions = app_data.get("instructions", [])
    var pc = 0
    var running = true
    var variables = {}
    var last_result = ""

    while running and pc < instructions.size():
        var instr = instructions[pc]
        var opcode = instr.get("opcode", "")
        var args = instr.get("args", [])

        match opcode:
            "PRINT":
                var msg = _replace_vars(args[0], variables, last_result)
                emit_signal("vm_output", msg)
            "SET_VAR":
                if args.size() >= 2:
                    variables[args[0]] = args[1]
            "JUMP":
                if args.size() == 1:
                    pc = int(args[0])
                    continue
            "READ_FILE":
                var path = args[0]
                if file_system and file_system.has(path):
                    last_result = file_system[path]
                else:
                    last_result = "<no file>"
            "WRITE_FILE":
                if args.size() >= 2:
                    var out_path = args[0]
                    var data = _replace_vars(args[1], variables, last_result)
                    if file_system:
                        file_system[out_path] = data
            "SHELL_COMMAND":
                if shell_callback:
                    var cmd = " ".join(args)
                    var result = shell_callback(cmd)
                    last_result = result
            "HALT":
                running = false
            _:
                emit_signal("vm_output", "Unknown opcode: " + opcode)

        pc += 1

func _replace_vars(text: String, vars: Dictionary, last_result: String) -> String:
    var output = text
    for key in vars.keys():
        output = output.replace("$" + key, str(vars[key]))
    output = output.replace("$_LAST_RESULT", last_result)
    return output
