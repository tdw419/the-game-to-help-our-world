<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PXDigest Lab – Decoder</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 2rem;
            background: linear-gradient(135deg, #1a1a3a, #0f0f23); /* Slightly different gradient for decoder */
            color: #e0e0e0;
            margin: 0;
            min-height: 100vh;
        }
        
        h1 {
            text-align: center;
            color: #00ffaa; /* Different shade for decoder */
            text-shadow: 0 0 10px rgba(0, 255, 170, 0.3);
            margin-bottom: 2rem;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .section {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
            border: 1px solid #333;
        }
        
        .section h3 {
            color: #00ffaa;
            margin-top: 0;
        }

        textarea {
            width: 100%;
            height: 180px;
            margin: 1rem 0;
            background: #1a1a2e;
            color: #00ddff; /* Decoder specific text color */
            font-family: 'Courier New', monospace;
            padding: 1rem;
            border: 1px solid #333;
            border-radius: 10px;
            resize: vertical;
        }

        button {
            background: linear-gradient(45deg, #00ffaa, #00cc88); /* Decoder specific button color */
            color: #000;
            border: none;
            padding: 0.8rem 1.5rem;
            border-radius: 25px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 0.5rem;
        }
        
        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 255, 170, 0.3);
        }

        .metadata {
            font-size: 1rem;
            margin: 1rem 0;
            color: #00ffcc;
            text-align: center;
            font-weight: bold;
        }

        #pxCanvas {
            border: 2px solid #00ffaa;
            border-radius: 10px;
            margin: 2rem auto;
            display: block;
            max-width: 100%;
            box-shadow: 0 0 20px rgba(0, 255, 170, 0.2);
        }

        #histogramCanvas {
            width: 100%;
            height: 150px;
            border: 1px solid #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>♻️ PXDigest Lab – Decoder Module</h1>
        
        <div class="section">
            <h3>Load Complete Digest (.pxdigest)</h3>
            <input type="file" id="loadDigestFile" accept=".pxdigest" />
            <p>Load a full .pxdigest file generated by the encoder.</p>
        </div>

        <div class="section">
            <h3>Paste Full Digest Content</h3>
            <textarea id="fullDigestInput" placeholder="Paste full .pxdigest content (header + data) here..."></textarea>
            <div style="text-align: center; margin-top: 1rem;">
                <button onclick="reconstructAndDownload(document.getElementById('fullDigestInput').value)">♻️ Reconstruct + Download from Full Digest</button>
            </div>
        </div>

        <div class="section">
            <h3>Paste Header Information Only</h3>
            <p>For files encoded with "Header-Only Encode" mode.</p>
            <textarea id="headerOnlyInput" placeholder="Paste PXDigest header (e.g., from 'Header Preview') here..."></textarea>
            <div style="text-align: center; margin-top: 1rem;">
                <button onclick="reconstructAndDownload(document.getElementById('headerOnlyInput').value)">♻️ Rebuild from Header Only</button>
            </div>
        </div>

        <div class="metadata" id="metadata">Ready to decode files...</div>

        <div class="section" id="canvasSection" style="display: none;">
            <h3>Visual Representation</h3>
            <div style="text-align: center; margin-bottom: 1rem;">
                <canvas id="pxCanvas"></canvas>
            </div>
            <div style="margin-top: 1rem;">
                <h4>Byte Distribution Histogram</h4>
                <canvas id="histogramCanvas"></canvas>
            </div>
        </div>
    </div>

    <script>
        let originalBytes = null; // Will store the reconstructed bytes
        let currentRenderMode = 'rgb'; // Default, though not configurable on this page yet

        const pxCanvas = document.getElementById('pxCanvas');
        const pxCtx = pxCanvas.getContext('2d');
        const histogramCanvas = document.getElementById('histogramCanvas');
        const histogramCtx = histogramCanvas.getContext('2d');

        // Load digest file handler
        document.getElementById('loadDigestFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = async function(event) {
                const digestContent = event.target.result;
                document.getElementById('fullDigestInput').value = digestContent; // Populate full digest textarea
                document.getElementById('headerOnlyInput').value = ''; // Clear header-only textarea
                reconstructAndDownload(digestContent); // Trigger reconstruction
            };
            reader.readAsText(file);
        });

        async function reconstructAndDownload(digestContent) {
            if (!digestContent) {
                alert('No digest content provided for reconstruction.');
                return null;
            }

            document.getElementById('metadata').textContent = 'Reconstructing file...';

            let headerChecksum = '';
            let originalSize = 0;
            let fileNameFromDigest = 'reconstructed_file';
            let reconstructionSpec = 'gzip-base64'; // Default
            let reconstructionParam = '';
            let base64Data = '';
            let inBase64Section = false;

            const lines = digestContent.split('\n');
            for (let line of lines) {
                const parts = line.split(':');
                if (parts.length > 1) {
                    const key = parts[0].trim();
                    const value = parts.slice(1).join(':').trim();
                    
                    if (key === 'filename') {
                        fileNameFromDigest = value;
                    } else if (key === 'checksum') {
                        headerChecksum = value;
                    } else if (key === 'original') {
                        originalSize = parseInt(value, 10);
                    } else if (key === 'reconstruction-spec') {
                        reconstructionSpec = value;
                    } else if (key === 'reconstruction-param') {
                        reconstructionParam = value;
                    }
                }
                
                if (line === '[Base64]') {
                    inBase64Section = true;
                } else if (line === '[Hex]') {
                    inBase64Section = false;
                } else if (inBase64Section && line.trim()) {
                    base64Data += line.trim();
                }
            }

            let reconstructedBytes = null;
            let reconstructionMethod = 'Unknown';

            // --- Attempt Header-Only Reconstruction ---
            // This is attempted ONLY if a specific reconstruction-spec is found AND NO Base64 data is present
            if (reconstructionSpec && reconstructionSpec !== 'gzip-base64' && !base64Data) {
                reconstructionMethod = 'Header-Only';
                try {
                    if (reconstructionSpec === 'rebuild_zero_fill') {
                        reconstructedBytes = rebuildZeroFill(originalSize);
                        document.getElementById('metadata').textContent = `Reconstructing via Header-Only (Zero-Fill)...`;
                    } else if (reconstructionSpec === 'rebuild_repeating_string') {
                        reconstructedBytes = rebuildRepeatingString(reconstructionParam, originalSize);
                        document.getElementById('metadata').textContent = `Reconstructing via Header-Only (Repeating String)...`;
                    } else {
                        console.warn(`Unknown reconstruction-spec: ${reconstructionSpec}. Cannot perform Header-Only reconstruction without Base64 data.`);
                        reconstructedBytes = null; // Force fallback logic to kick in if Base64 exists
                        reconstructionMethod = 'Header-Only (Unknown Spec) Failed';
                    }
                } catch (e) {
                    console.error(`Header-Only reconstruction failed for spec ${reconstructionSpec}:`, e);
                    alert(`Header-Only reconstruction failed for ${reconstructionSpec}: ${e.message}.`);
                    reconstructedBytes = null; // Force fallback
                    reconstructionMethod = 'Header-Only (Error) Failed';
                }
            }

            // --- Fallback to Base64 Reconstruction ---
            // This happens if Header-Only failed/wasn't applicable, OR if Base64 data is present
            if (!reconstructedBytes && base64Data) {
                reconstructionMethod = (reconstructionMethod === 'Unknown' ? 'Base64' : reconstructionMethod + ' -> Base64 Fallback');
                try {
                    const binary = base64ToArrayBuffer(base64Data);
                    const compressed = new Uint8Array(binary);
                    reconstructedBytes = pako.ungzip(compressed);
                    document.getElementById('metadata').textContent = `Reconstructing via Base64...`;
                } catch (e) {
                    console.error('Base64 decompression failed:', e);
                    alert('Error decoding/decompressing Base64 data: ' + e.message);
                    document.getElementById('metadata').textContent = `❌ Reconstruction failed (Base64): ${e.message}`;
                    return null;
                }
            } else if (!reconstructedBytes) {
                // Final check: if still no reconstructedBytes after all attempts
                alert('No valid reconstruction method found or data available in digest. Ensure digest has Base64 data or a recognized header-only spec without data section.');
                document.getElementById('metadata').textContent = '❌ Reconstruction failed: No data or valid spec.';
                return null;
            }
            
            originalBytes = reconstructedBytes; // Update global originalBytes for canvas rendering

            // --- Verification (Checksum & Size) ---
            const hashBuffer = await crypto.subtle.digest('SHA-256', reconstructedBytes.buffer);
            const verifyHash = Array.from(new Uint8Array(hashBuffer))
                .map(b => b.toString(16).padStart(2, '0')).join('');
            
            let checksumStatus = verifyHash === headerChecksum
                ? 'OK'
                : 'MISMATCH';
            
            let sizeStatus = 'OK';
            if (originalSize > 0 && reconstructedBytes.length !== originalSize) {
                sizeStatus = 'MISMATCH';
            }

            const finalStatusMsg = `✅ Reconstructed ${reconstructedBytes.length} bytes (Method: ${reconstructionMethod}, Checksum: ${checksumStatus}, Original Size: ${originalSize} bytes)`;
            document.getElementById('metadata').textContent = finalStatusMsg;

            if (checksumStatus === 'MISMATCH' || sizeStatus === 'MISMATCH') {
                alert(`Warning: Reconstruction complete but issues found! Checksum: ${checksumStatus}, Size: ${reconstructedBytes.length} vs Header: ${originalSize} (${sizeStatus})`);
            }

            // --- Download Reconstructed File ---
            const blob = new Blob([reconstructedBytes], { type: 'application/octet-stream' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = fileNameFromDigest;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(a.href);
            
            // --- Update Visuals (Canvas & Histogram) ---
            if (reconstructedBytes.length > 0) {
                drawFromBytesOptimized(reconstructedBytes);
                drawHistogram(reconstructedBytes);
                document.getElementById('canvasSection').style.display = 'block';
            }

            return reconstructedBytes; // Return the reconstructed bytes
        }

        // Helper functions for Header-Only reconstruction
        function rebuildZeroFill(size) {
            if (typeof size !== 'number' || size < 0) {
                throw new Error("Invalid size for zero-fill reconstruction.");
            }
            return new Uint8Array(size); // Automatically filled with zeros
        }

        function rebuildRepeatingString(pattern, size) {
            if (!pattern) {
                throw new Error("Repeating string pattern is empty.");
            }
            if (typeof size !== 'number' || size < 0) {
                throw new Error("Invalid size for repeating string reconstruction.");
            }
            const patternBytes = new TextEncoder().encode(pattern);
            if (patternBytes.length === 0) {
                throw new Error("Encoded repeating string pattern is empty.");
            }
            const bytes = new Uint8Array(size);
            for (let i = 0; i < size; i++) {
                bytes[i] = patternBytes[i % patternBytes.length];
            }
            return bytes;
        }

        // Helper function to draw pixels on canvas
        function drawFromBytesOptimized(bytes) {
            console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
            
            const canvas = document.getElementById('pxCanvas');
            const ctx = canvas.getContext('2d');
            
            // Limit canvas size for performance
            const maxDimension = 1024;
            let totalPixels = Math.ceil(bytes.length / 3);
            
            // Sample data if too large
            let sampledBytes = bytes;
            if (bytes.length > maxDimension * maxDimension * 3) {
                const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
                sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
                for (let i = 0; i < sampledBytes.length; i++) {
                    sampledBytes[i] = bytes[i * sampleRate];
                }
                totalPixels = Math.ceil(sampledBytes.length / 3);
                console.log(`[PXDigest] Sampled ${sampledBytes.length} bytes (rate: 1/${sampleRate})`);
            }
            
            // Calculate canvas dimensions
            const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
            const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
            canvas.width = w;
            canvas.height = h;
            
            console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

            // Calculate entropy on a sample
            const sampleSize = Math.min(sampledBytes.length, 100000);
            const entropyBin = new Array(256).fill(0);
            for (let b of sampledBytes) entropyBin[b]++;
            const entropy = -entropyBin.reduce((acc, n) => {
                if (n === 0) return acc;
                const p = n / sampleSize;
                return acc + p * Math.log2(p);
            }, 0);
            
            console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

            // Create image data
            const imgData = ctx.createImageData(w, h);
            let dataIdx = 0; // index for imgData.data (RGBA)
            let byteIdx = 0; // index for sampledBytes

            // Current render mode is hardcoded in this decoder for simplicity, 
            // but for full functionality, it should be extracted from digest or selected.
            const renderMode = 'rgb'; // Assuming RGB for decoding visualization
            const bytesPerPixel = renderMode === 'rgb' ? 3 : 1;

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    let r = 0, g = 0, b = 0;

                    if (renderMode === 'rgb') {
                        r = sampledBytes[byteIdx] || 0;
                        g = sampledBytes[byteIdx + 1] || 0;
                        b = sampledBytes[byteIdx + 2] || 0;
                        byteIdx += 3;
                    } else { // Grayscale or heatmap simplified for decoder display
                        const val = sampledBytes[byteIdx] || 0;
                        r = val;
                        g = val;
                        b = val;
                        byteIdx += 1;
                    }

                    imgData.data[dataIdx++] = r;
                    imgData.data[dataIdx++] = g;
                    imgData.data[dataIdx++] = b;
                    imgData.data[dataIdx++] = 255; // Alpha
                }
            }
            
            ctx.putImageData(imgData, 0, 0);
            
            // Add entropy text overlay
            ctx.font = '12px monospace';
            ctx.fillStyle = 'rgba(255,255,0,0.8)';
            ctx.strokeStyle = 'rgba(0,0,0,0.8)';
            ctx.lineWidth = 2;
            const text = `Entropy: ${entropy.toFixed(2)} bpb`;
            ctx.strokeText(text, 5, h - 10);
            ctx.fillText(text, 5, h - 10);
            
            console.log('[PXDigest] Pixel data rendered to canvas.');
        }

        // Function to draw histogram
        function drawHistogram(bytes) {
            if (!bytes || bytes.length === 0) {
                histogramCtx.clearRect(0, 0, histogramCanvas.width, histogramCanvas.height);
                histogramCtx.fillStyle = '#ccc';
                histogramCtx.font = '12px Arial';
                histogramCtx.fillText('No data for histogram', 10, histogramCanvas.height / 2);
                return;
            }

            const counts = new Array(256).fill(0);
            for (const byteValue of bytes) {
                counts[byteValue]++;
            }

            const maxCount = Math.max(...counts);
            const barWidth = histogramCanvas.width / 256;

            histogramCtx.clearRect(0, 0, histogramCanvas.width, histogramCanvas.height);
            histogramCtx.fillStyle = '#00ff88';

            for (let i = 0; i < 256; i++) {
                const barHeight = (counts[i] / maxCount) * histogramCanvas.height;
                histogramCtx.fillRect(i * barWidth, histogramCanvas.height - barHeight, barWidth, barHeight);
            }

            // Add labels
            histogramCtx.fillStyle = '#e0e0e0';
            histogramCtx.font = '10px monospace';
            histogramCtx.fillText('0x00', 0, histogramCanvas.height - 5);
            histogramCtx.fillText('0xFF', histogramCanvas.width - 25, histogramCanvas.height - 5);
        }
    </script>
</body>
</html>