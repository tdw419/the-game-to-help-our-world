<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PXDigest Lab – Data Digester</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      padding: 2rem; 
      background: linear-gradient(135deg, #0f0f23, #1a1a3a); 
      color: #e0e0e0; 
      margin: 0;
      min-height: 100vh;
    }
    
    h1 {
      text-align: center;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
      margin-bottom: 2rem;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .upload-section {
      background: rgba(255, 255, 255, 0.05);
      border: 2px dashed #00ff88;
      border-radius: 10px;
      padding: 2rem;
      text-align: center;
      margin-bottom: 2rem;
      transition: all 0.3s ease;
    }
    
    .upload-section:hover {
      background: rgba(0, 255, 136, 0.1);
      border-color: #00ffaa;
    }
    
    input[type="file"] {
      background: #2a2a4a;
      color: #e0e0e0;
      border: 1px solid #444;
      border-radius: 5px;
      padding: 0.5rem;
      margin: 0.5rem;
    }
    
    .controls { 
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin: 2rem 0;
      justify-content: center;
    }
    
    button {
      background: linear-gradient(45deg, #00ff88, #00cc66);
      color: #000;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 25px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(255, 255, 255, 0.1);
      padding: 0.5rem 1rem;
      border-radius: 20px;
    }
    
    input[type="checkbox"] {
      accent-color: #00ff88;
    }
    
    #pxCanvas { 
      border: 2px solid #00ff88; 
      border-radius: 10px;
      margin: 2rem auto;
      display: block;
      max-width: 100%;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
    }
    
    .metadata { 
      font-size: 1rem; 
      margin: 1rem 0; 
      color: #00ffaa;
      text-align: center;
      font-weight: bold;
    }
    
    textarea { 
      width: 100%; 
      height: 200px; 
      margin: 1rem 0; 
      background: #1a1a2e; 
      color: #00ff88; 
      font-family: 'Courier New', monospace; 
      padding: 1rem; 
      border: 1px solid #333;
      border-radius: 10px;
      resize: vertical;
    }
    
    pre { 
      background: #0f0f23; 
      padding: 1rem; 
      color: #00ddff; 
      font-size: 0.9rem; 
      white-space: pre-wrap; 
      word-break: break-all; 
      margin: 1rem 0; 
      border: 1px solid #333; 
      border-radius: 10px;
      overflow-x: auto;
    }
    
    .section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 1.5rem;
      margin: 1rem 0;
      border: 1px solid #333;
    }
    
    .section h3 {
      color: #00ff88;
      margin-top: 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>🧪 PXDigest Lab – Data Digester</h1>
    
    <div class="upload-section">
      <h3>Upload File to Digest</h3>
      <input type="file" id="fileInput" />
      <p>Choose any file to convert into a visual digest</p>
    </div>
    
    <div class="controls">
      <label><input type="checkbox" id="bootOnlyToggle" /> Boot ID Only</label>
      <label><input type="checkbox" id="headerOnlyEncodeToggle" /> Header-Only Encode (for simple patterns)</label>
      <button onclick="digestAndExport()">🧪 Digest + Export (GZIP)</button>
      <button onclick="reconstructAndDownload()">♻️ Reconstruct + Download File</button>
    </div>
    
    <div class="upload-section">
      <h3>Load Existing Digest</h3>
      <input type="file" id="loadDigestFile" accept=".pxdigest" />
      <p>Load a previously saved .pxdigest file</p>
    </div>

    <div class="section">
        <h3>Rebuild from Header Text</h3>
        <textarea id="rebuildHeaderInput" placeholder="Paste Header Preview text here..." style="height: 150px;"></textarea>
        <div style="text-align: center; margin-top: 1rem;">
            <button onclick="reconstructAndDownload(document.getElementById('rebuildHeaderInput').value)">♻️ Rebuild from Pasted Header</button>
        </div>
    </div>
        <div class="section" id="canvasSection" style="display: none;">
      <h3>Visual Representation</h3>
      <div style="text-align: center; margin-bottom: 1rem;">
        <label for="canvasRenderMode">Render Mode:</label>
        <select id="canvasRenderMode">
          <option value="rgb">RGB (3 bytes/pixel)</option>
          <option value="grayscale">Grayscale (1 byte/pixel)</option>
          <option value="heatmap">Heatmap (1 byte/pixel)</option>
        </select>
        <label><input type="checkbox" id="pixelGridToggle" /> Pixel Grid</label>
        <button onclick="renderCanvas()">🎨 Render Visual Canvas</button>
        <button onclick="downloadCanvasPNG()" id="downloadPNGBtn" style="display: none;">📸 Download PNG</button>
      </div>
      <div id="pxCanvasContainer" style="position: relative;">
        <canvas id="pxCanvas"></canvas>
        <div id="pixelInfo" style="position: absolute; top: 0; left: 0; background: rgba(0, 0, 0, 0.8); color: #fff; padding: 5px 10px; border-radius: 3px; font-family: monospace; font-size: 0.85rem; pointer-events: none; display: none; z-index: 10; white-space: pre; line-height: 1.2;"></div>
      </div>
      <div style="margin-top: 1rem;">
        <h4>Byte Distribution Histogram</h4>
        <canvas id="histogramCanvas" style="width: 100%; height: 150px; border: 1px solid #333;"></canvas>
      </div>
    </div>
    <div class="metadata" id="metadata">Ready to process files...</div>
    
    <div class="section" id="digestSection" style="display: none;">
      <h3>Digest Output</h3>
      <div style="text-align: center; margin-bottom: 1rem;">
        <button onclick="showDigestOutput()">📋 Show Digest Data</button>
        <button onclick="downloadDigest()" id="downloadDigestBtn" style="display: none;">💾 Download .pxdigest</button>
      </div>
      <textarea id="digestOutput" placeholder="Digested data will appear here..." style="display: none;"></textarea>
    </div>
    
    <div class="section">
      <h3>Header Preview</h3>
      <div style="text-align: center; margin-bottom: 1rem;">
        <button onclick="copyHeaderPreview()">📋 Copy Header Info</button>
      </div>
      <pre id="headerPreview">No file processed yet...</pre>
    </div>
    
    <div class="section">
      <h3>zTXt Emitter Output</h3>
      <pre id="ztxtEmitterOutput">Waiting for file processing...</pre>
    </div>
  </div>

  <script>
    // Global variables
    let originalBytes = null;
    let originalFileName = 'reconstructed_file'; // Default filename for reconstructed files
    let currentRenderMode = 'rgb'; // Default render mode

    // Canvas references
    const pxCanvas = document.getElementById('pxCanvas');
    const pxCtx = pxCanvas.getContext('2d');
    const histogramCanvas = document.getElementById('histogramCanvas');
    const histogramCtx = histogramCanvas.getContext('2d');
    const pixelInfoDisplay = document.getElementById('pixelInfo');
    const canvasRenderModeSelect = document.getElementById('canvasRenderMode');
    const pixelGridToggle = document.getElementById('pixelGridToggle');
    const headerOnlyEncodeToggle = document.getElementById('headerOnlyEncodeToggle');

    // File input handler
    document.getElementById('fileInput').addEventListener('change', (e) => {
      document.getElementById('loadDigestFile').value = '';
      const file = e.target.files[0];
      if (!file) {
          originalBytes = null; // Clear bytes if no file selected
          originalFileName = 'reconstructed_file'; // Reset filename
          document.getElementById('metadata').textContent = 'No file selected.';
          return;
      }
      
      originalFileName = file.name; // Store the original file name
      const reader = new FileReader();
      reader.onload = function(event) {
        originalBytes = new Uint8Array(event.target.result);
        document.getElementById('metadata').textContent = `Loaded <span class="math-inline">\{file\.name\} \(</span>{originalBytes.length} bytes)`;
        console.log(`File loaded: ${file.name}, ${originalBytes.length} bytes`);
        
        // Clear previous outputs
        document.getElementById('digestOutput').value = '';
        document.getElementById('headerPreview').textContent = '';
        document.getElementById('ztxtEmitterOutput').textContent = '';
      };
      reader.readAsArrayBuffer(file);
    });

    // Canvas render mode change handler
    canvasRenderModeSelect.addEventListener('change', () => {
      currentRenderMode = canvasRenderModeSelect.value;
      if (originalBytes && document.getElementById('pxCanvas').width > 0) {
        drawFromBytesOptimized(originalBytes);
      }
    });

    // Pixel grid toggle handler
    pixelGridToggle.addEventListener('change', () => {
      if (originalBytes && document.getElementById('pxCanvas').width > 0) {
        drawFromBytesOptimized(originalBytes);
      }
    });

    // Canvas hover for pixel info
    pxCanvas.addEventListener('mousemove', (e) => {
      if (!originalBytes || pxCanvas.width === 0 || pxCanvas.height === 0) {
        pixelInfoDisplay.style.display = 'none';
        return;
      }

      const rect = pxCanvas.getBoundingClientRect();
      const scaleX = pxCanvas.width / rect.width;
      const scaleY = pxCanvas.height / rect.height;
      const x = Math.floor((e.clientX - rect.left) * scaleX);
      const y = Math.floor((e.clientY - rect.top) * scaleY);

      let bytesPerPixel = currentRenderMode === 'rgb' ? 3 : 1;
      const pixelIndex = y * pxCanvas.width + x;
      const byteOffset = pixelIndex * bytesPerPixel;

      let pixelBytes = [];
      for (let i = 0; i < bytesPerPixel; i++) {
        if (byteOffset + i < originalBytes.length) {
          pixelBytes.push(originalBytes[byteOffset + i]);
        } else {
          pixelBytes.push(0);
        }
      }

      let pixelInfoText = `X: ${x}, Y: <span class="math-inline">\{y\}\\nOffset\: 0x</span>{byteOffset.toString(16).padStart(6, '0')}`;
      if (bytesPerPixel === 3) {
        pixelInfoText += `\nRGB: <span class="math-inline">\{pixelBytes\[0\]\},</span>{pixelBytes[1]},${pixelBytes[2]}`;
      } else {
        pixelInfoText += `\nValue: ${pixelBytes[0]}`;
      }
      pixelInfoText += `\nHex: 0x${pixelBytes.map(b => b.toString(16).padStart(2, '0')).join('')}`;

      pixelInfoDisplay.style.display = 'block';
      const containerRect = pxCanvas.parentElement.getBoundingClientRect();
      let displayX = e.clientX - containerRect.left + 10;
      let displayY = e.clientY - containerRect.top + 10;

      if (displayX + 200 > containerRect.width) {
        displayX = containerRect.width - 200;
      }
      if (displayY + 100 > containerRect.height) {
        displayY = containerRect.height - 100;
      }

      pixelInfoDisplay.style.left = `${displayX}px`;
      pixelInfoDisplay.style.top = `${displayY}px`;
      pixelInfoDisplay.innerText = pixelInfoText;
    });

    pxCanvas.addEventListener('mouseleave', () => {
      pixelInfoDisplay.style.display = 'none';
    });

    // Load digest file handler
    document.getElementById('loadDigestFile').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        const digestContent = event.target.result;
        document.getElementById('digestOutput').value = digestContent;
        document.getElementById('digestSection').style.display = 'block';
        showDigestOutput(); // Automatically show when loading from file
        reconstructAndDownload(digestContent); // Call unified reconstruction function
      };
      reader.readAsText(file);
    });

    // Download digest function
    function downloadDigest() {
      const digest = document.getElementById('digestOutput').value;
      if (!digest) {
        alert('No digest to download. Please show digest data first.');
        return;
      }
      
      const blob = new Blob([digest], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${originalFileName}.pxdigest`; // Use original filename for digest download
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
    }

    // Main digest and export function
    async function digestAndExport() {
      console.log('Digest button clicked.');
      if (!originalBytes) {
        alert('No file loaded. Please upload a file first.');
        return;
      }

      // Show processing indicator
      document.getElementById('metadata').textContent = `Processing ${originalBytes.length} bytes...`;

      try {
        let reconstructionSpec = 'gzip-base64'; // Default to full compression
        let reconstructionParam = '';
        let includeDataSection = true; // By default, include Base64/Hex data

        if (headerOnlyEncodeToggle.checked) {
          const zeroFillTest = new Uint8Array(originalBytes.length).every(byte => byte === 0);
          if (zeroFillTest) {
            reconstructionSpec = 'rebuild_zero_fill';
            reconstructionParam = '0'; // Parameter can be the fill value
              includeDataSection = false; // Do not include data section for true header-only
            alert('Detected all zeros. Encoding for Header-Only reconstruction (zero-fill).');
          } else {
            // More sophisticated pattern detection for repeating strings, etc. could go here.
            // Example for repeating string (basic check, can be improved):
            let detectedRepeatingPattern = '';
            if (originalBytes.length > 0) {
              // Try to find a repeating pattern of length 1 to 10
              for (let len = 1; len <= 10 && len <= originalBytes.length; len++) {
                const patternCandidate = new TextDecoder().decode(originalBytes.slice(0, len));
                let isRepeating = true;
                for (let i = len; i < originalBytes.length; i++) {
                  if (originalBytes[i] !== originalBytes[i % len]) {
                    isRepeating = false;
                    break;
                  }
                }
                if (isRepeating) {
                  detectedRepeatingPattern = patternCandidate;
                  break;
                }
              }
            }

            if (detectedRepeatingPattern) {
              reconstructionSpec = 'rebuild_repeating_string';
              reconstructionParam = detectedRepeatingPattern;
              includeDataSection = false; // Do not include data section for true header-only
              alert(`Detected repeating string pattern: "${detectedRepeatingPattern}". Encoding for Header-Only reconstruction.`);
            } else {
              alert('Header-Only encoding is currently limited to all-zero or simple repeating string files. Full data will be included.');
              headerOnlyEncodeToggle.checked = false; // Uncheck it if not applicable
              reconstructionSpec = 'gzip-base64'; // Fallback to full data encoding
              includeDataSection = true;
            }
        }
        
        let compressed = new Uint8Array(0);
        let base64 = '';
        let hex = '';
        let digestData = '';

        if (includeDataSection) { // Only compress and include data section if explicitly requested or if header-only didn't apply
            compressed = pako.gzip(originalBytes);
            base64 = arrayBufferToBase64(compressed);
            hex = arrayBufferToHex(compressed);
            digestData = `\n\n[Base64]\n${base64}\n\n[Hex]\n${hex}`;
        }

        // Generate checksum (always of original bytes)
        const hashBuffer = await crypto.subtle.digest('SHA-256', originalBytes.buffer);
        const headerHash = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0')).join('');
        
        // Construct the enhanced header with filename and reconstruction spec
        const header = `PXDigest v2
filename:<span class="math-inline">\{originalFileName\}
compressed\:</span>{compressed.length}
original:<span class="math-inline">\{originalBytes\.length\}
checksum\:</span>{headerHash}
reconstruction-spec:<span class="math-inline">\{reconstructionSpec\}
reconstruction\-param\:</span>{reconstructionParam}`;

        // Compute 4-pixel boot signature (first 12 bytes of SHA-256)
        const hashBytes = new Uint8Array(hashBuffer);
        const bootRGBs = [0, 3, 6, 9].map(i => [hashBytes[i], hashBytes[i+1], hashBytes[i+2]]);
        const bootText = bootRGBs.map((rgb, i) => `128,${i} = <span class="math-inline">\{rgb\[0\]\},</span>{rgb[1]},${rgb[2]}`).join('\n');

        // Auto-bloom registry
        const digestIndex = {
          '28,63,165-177,95,8-103,48,213-229,77,212': 'pxgen/specs/run_tinycore_vm',
          // Add more known digests here as needed
        };
        const bootKey = bootRGBs.map(rgb => rgb.join(',')).join('-');
        const matchedSpec = digestIndex[bootKey] || 'No match';

        // Draw boot pixels
        const bootCanvas = document.getElementById('pxCanvas');
        const bootCtx = bootCanvas.getContext('2d');
        bootCanvas.width = 200;
        bootCanvas.height = 50;
        
        // Clear canvas
        bootCtx.fillStyle = '#000';
        bootCtx.fillRect(0, 0, bootCanvas.width, bootCanvas.height);
        
        // Draw boot pixels
        for (let i = 0; i < bootRGBs.length; i++) {
          const [r, g, b] = bootRGBs[i];
          bootCtx.fillStyle = `rgb(<span class="math-inline">\{r\},</span>{g},${b})`;
          bootCtx.fillRect(i * 30, 10, 25, 25);
        }

        // Generate digest string
        const bootOnly = document.getElementById('bootOnlyToggle').checked;
        const digest = `<span class="math-inline">\{header\}\\n</span>{bootText}${bootOnly ? '' : digestData}`;
        
        document.getElementById('digestOutput').value = digest;
        console.log('Digest output written to textarea.');
        
        // Update header preview
        document.getElementById('headerPreview').textContent = `// PXDigest Header Info
${header}

// Boot Pixels
${bootText}

// Bloom Match
${bootKey} => ${matchedSpec}`;

        // zTXt emitter output
        const ztxtSpec = `# pxgen/specs/restore_from_digest
READ_ZT pxgen/input/compressed_digest
DECODE_GZIP_BASE64 TO CODE_FORGE_REGION
HALT`;
        document.getElementById('ztxtEmitterOutput').textContent = ztxtSpec;

        // Show sections but keep digest hidden by default
        document.getElementById('canvasSection').style.display = 'block';
        document.getElementById('digestSection').style.display = 'block';
        document.getElementById('downloadPNGBtn').style.display = 'none';
        document.getElementById('downloadDigestBtn').style.display = 'none';

        document.getElementById('metadata').textContent = `✅ Processed ${originalBytes.length} bytes successfully! Digest ready to view.`;

      } catch (error) {
        console.error('Error during digest:', error);
        alert('Error processing file: ' + error.message);
      }
    }

    // Unified reconstruction function
    async function reconstructAndDownload(digestContent = null) {
      const digest = digestContent || document.getElementById('digestOutput').value;
      if (!digest) {
        alert('No digest to reconstruct from. Please load or generate a digest first.');
        return null;
      }

      document.getElementById('metadata').textContent = 'Reconstructing file from digest...';

      // Parse all header fields more robustly
      let headerChecksum = '';
      let originalSize = 0;
      let fileNameFromDigest = 'reconstructed_file'; // Default
      let reconstructionSpec = '';
      let reconstructionParam = '';
      let base64Data = ''; // This will capture the full base64 data if present
      let inBase64Section = false;

      const lines = digest.split('\n');
      for (let line of lines) {
            const parts = line.split(':');
            if (parts.length > 1) { // Ensure line has a key-value pair
                const key = parts[0].trim();
                const value = parts.slice(1).join(':').trim(); // Join back if value has colons
                
                if (key === 'filename') {
                    fileNameFromDigest = value;
                } else if (key === 'checksum') {
                    headerChecksum = value;
                } else if (key === 'original') {
                    originalSize = parseInt(value, 10);
                } else if (key === 'reconstruction-spec') {
                    reconstructionSpec = value;
                } else if (key === 'reconstruction-param') {
                    reconstructionParam = value;
                }
            }
        
            // Handle Base64/Hex sections
        if (line === '[Base64]') {
          inBase64Section = true;
        } else if (line === '[Hex]') {
          inBase64Section = false;
        } else if (inBase64Section && line.trim()) {
          base64Data += line.trim();
        }
      }

      let reconstructedBytes = null;
      let reconstructionMethod = 'Unknown';

      // Attempt Header-Only Reconstruction IF a specific spec is found AND Base64 data is NOT present.
      // This enforces that it's *truly* header-only, not just a fallback.
      if (reconstructionSpec && reconstructionSpec !== 'gzip-base64' && !base64Data) {
          reconstructionMethod = 'Header-Only';
          try {
              if (reconstructionSpec === 'rebuild_zero_fill') {
                  reconstructedBytes = rebuildZeroFill(originalSize);
                  document.getElementById('metadata').textContent = `Reconstructing via Header-Only (Zero-Fill)...`;
              } else if (reconstructionSpec === 'rebuild_repeating_string') {
                  reconstructedBytes = rebuildRepeatingString(reconstructionParam, originalSize);
                  document.getElementById('metadata').textContent = `Reconstructing via Header-Only (Repeating String)...`;
              } else {
                  console.warn(`Unknown reconstruction-spec in header: ${reconstructionSpec}. No Base64 data found for fallback.`);
                  reconstructedBytes = null; // Cannot reconstruct with this spec and no data
                  reconstructionMethod = 'Header-Only (Unknown Spec) Failed';
              }
          } catch (e) {
              console.error(`Header-Only reconstruction failed for spec ${reconstructionSpec}:`, e);
              alert(`Header-Only reconstruction failed for ${reconstructionSpec}: ${e.message}. No Base64 data for fallback.`);
              reconstructedBytes = null; // Cannot reconstruct
              reconstructionMethod = 'Header-Only (Error) Failed';
          }
      }

      // Fallback to Base64 Reconstruction if Header-Only didn't work or wasn't applicable, AND Base64 data IS present
      if (!reconstructedBytes && base64Data) {
          reconstructionMethod = (reconstructionMethod === 'Unknown' ? 'Base64' : reconstructionMethod + ' Base64 Fallback');
          try {
              const binary = base64ToArrayBuffer(base64Data);
              const compressed = new Uint8Array(binary);
              reconstructedBytes = pako.ungzip(compressed);
              document.getElementById('metadata').textContent = `Reconstructing via Base64...`;
          } catch (e) {
              console.error('Base64 reconstruction failed:', e);
              alert('Error decoding/decompressing Base64 data: ' + e.message);
              document.getElementById('metadata').textContent = `❌ Reconstruction failed (Base64): ${e.message}`;
              return null;
          }
      } else if (!reconstructedBytes) {
          // If still no bytes after all attempts
          alert('No valid reconstruction method found or data available in digest. Ensure your digest contains Base64 data OR a recognized header-only spec with no Base64 data.');
          document.getElementById('metadata').textContent = '❌ Reconstruction failed: No data or valid spec.';
          return null;
      }
      
      originalBytes = reconstructedBytes; // Update global originalBytes for canvas rendering

      // Verify checksum
      const hashBuffer = await crypto.subtle.digest('SHA-256', reconstructedBytes.buffer);
      const verifyHash = Array.from(new Uint8Array(hashBuffer))
        .map(b => b.toString(16).padStart(2, '0')).join('');
      
      let checksumStatus = verifyHash === headerChecksum
        ? 'OK'
        : 'MISMATCH';
      
      // Verify original size
      let sizeStatus = 'OK';
      if (originalSize > 0 && reconstructedBytes.length !== originalSize) {
          sizeStatus = 'MISMATCH';
      }

      const finalStatusMsg = `✅ Reconstructed ${reconstructedBytes.length} bytes (Method: ${reconstructionMethod}, Checksum: ${checksumStatus}, Size: ${sizeStatus})`;
      document.getElementById('metadata').textContent = finalStatusMsg;

      if (checksumStatus === 'MISMATCH' || sizeStatus === 'MISMATCH') {
          alert(`Warning: Reconstruction complete but issues found! Checksum: ${checksumStatus}, Size: ${sizeStatus}`);
      }

      // Trigger download
      const blob = new Blob([reconstructedBytes], { type: 'application/octet-stream' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = fileNameFromDigest;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
      
      // Show canvas and histogram if data is available
      if (reconstructedBytes.length > 0) {
        drawFromBytesOptimized(reconstructedBytes);
        drawHistogram(reconstructedBytes); // Assuming drawHistogram exists and is robust
        document.getElementById('canvasSection').style.display = 'block';
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
      }


      return reconstructedBytes; // Return the reconstructed bytes for further use (e.g., canvas rendering)
    }

    // Helper functions for Header-Only reconstruction
    function rebuildZeroFill(size) {
        if (typeof size !== 'number' || size < 0) {
            throw new Error("Invalid size for zero-fill reconstruction.");
        }
        return new Uint8Array(size); // Automatically filled with zeros
    }

    function rebuildRepeatingString(pattern, size) {
        if (!pattern) {
            throw new Error("Repeating string pattern is empty.");
        }
        if (typeof size !== 'number' || size < 0) {
            throw new Error("Invalid size for repeating string reconstruction.");
        }
        // Using TextEncoder to handle various characters correctly
        const patternBytes = new TextEncoder().encode(pattern);
        if (patternBytes.length === 0) {
            throw new Error("Encoded repeating string pattern is empty.");
        }
        const bytes = new Uint8Array(size);
        for (let i = 0; i < size; i++) {
            bytes[i] = patternBytes[i % patternBytes.length];
        }
        return bytes;
    }


    // Draw pixels from bytes (original, non-optimized version - kept for reference)
    // This function is effectively replaced by drawFromBytesOptimized for actual use.
    function drawFromBytes(bytes) {
      console.log('[PXDigest] Starting reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Calculate canvas dimensions
      const totalPixels = Math.ceil(bytes.length / 3);
      const w = Math.ceil(Math.sqrt(totalPixels));
      const h = Math.ceil(totalPixels / w);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy
      const entropyBin = new Array(256).fill(0);
      for (let b of bytes) entropyBin[b]++;
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / bytes.length;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < bytes.length; i += 3) {
        imgData.data[j++] = bytes[i];           // R
        imgData.data[j++] = bytes[i+1] || 0;    // G
        imgData.data[j++] = bytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Animate bloom effect
      let radius = 1;
      function bloomStep() {
        ctx.beginPath();
        ctx.arc(20, 20, radius, 0, 2 * Math.PI);
        ctx.strokeStyle = 'lime';
        ctx.lineWidth = 2;
        ctx.stroke();
        radius += 3;
        if (radius < 50) requestAnimationFrame(bloomStep);
      }
      bloomStep();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let i = 0; i < sampleSize; i++) {
        entropyBin[sampledBytes[i]]++;
      }
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let i = 0; i < sampleSize; i++) {
        entropyBin[sampledBytes[i]]++;
      }
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let i = 0; i < sampleSize; i++) {
        entropyBin[sampledBytes[i]]++;
      }
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let i = 0; i < sampleSize; i++) {
        entropyBin[sampledBytes[i]]++;
      }
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let b of bytes) entropyBin[b]++;
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let b of bytes) entropyBin[b]++;
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let b of bytes) entropyBin[b]++;
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let b of bytes) entropyBin[b]++;
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let b of bytes) entropyBin[b]++;
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let b of bytes) entropyBin[b]++;
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let b of bytes) entropyBin[b]++;
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `✅ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `✅ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled <span class="math-inline">\{sampledBytes\.length\} bytes \(rate\: 1/</span>{sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let b of bytes) entropyBin[b]++;
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '✅ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        },