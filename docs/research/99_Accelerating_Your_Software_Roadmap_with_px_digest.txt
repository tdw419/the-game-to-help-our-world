Got it! You're trying to understand how the **PXDigest Lab ‚Äì Data Digester** software was created so quickly and how to explain it in the simplest way possible. Since I didn‚Äôt create the software (you provided the code), I‚Äôll explain how a developer could build something like this rapidly, based on the code‚Äôs structure, the tools used, and modern web development practices. I‚Äôll keep it concise, non-technical, and focused on the key factors that enable fast software creation, while addressing the role of the **pxdigest** format and the hypothetical **pxdisk** (likely a disk imaging tool for testing, as discussed previously). I‚Äôll also clarify the minimal files needed to run it, tying it to your earlier question.

---

### **What the Software Does (Quick Recap)**

The **PXDigest Lab** is a web tool that:
- Takes any file (e.g., a text file or disk image), compresses it, and turns it into a special text file called a `.pxdigest`.
- Shows the file‚Äôs data as a colorful picture on a canvas.
- Lets you save the `.pxdigest` and later use it to get the original file back.
- Adds a ‚Äúfingerprint‚Äù (four colored pixels) to identify the file.

Think of it like a digital ‚Äúshrink-wrap‚Äù machine: it packs a file into a smaller, labeled package (`.pxdigest`) and shows you a snapshot of what‚Äôs inside.

---

### **Easiest Way to Explain How It Was Made So Quickly**

The software was built fast because it uses **ready-made tools**, **simple web tech**, and a **focused design**. Here‚Äôs the simplest explanation:

1. **Used a Web Page as the Base**:
   - The developer made a single web page (like a document) using HTML, CSS, and JavaScript‚Äîthe stuff every browser understands.
   - HTML sets up buttons and a canvas (like a digital drawing board).
   - CSS makes it look nice (dark background, green text).
   - JavaScript does the work (reading files, compressing, drawing).
   - **Why Fast?** Web pages are quick to create with basic code editors (like Notepad or VS Code), and browsers handle all the heavy lifting (no need to install special software).

2. **Borrowed Free Tools**:
   - Instead of writing complex code from scratch, the developer used:
     - **Pako**: A free library that compresses files (like zipping them). It‚Äôs just one line to include it from the internet.
     - **Browser Tools**: The browser‚Äôs built-in features handle file reading (FileReader), secure fingerprinting (Crypto API for SHA-256), and drawing (Canvas API).
   - **Why Fast?** These tools are pre-built, tested, and free. Including them is as easy as adding a line like `<script src="pako.js">`.

3. **Kept the PXDigest Format Simple**:
   - The `.pxdigest` format is just a text file with:
     - Basic info (file size, fingerprint).
     - A ‚Äúfingerprint‚Äù (four colors made from the file‚Äôs unique code).
     - The compressed file (in a text-friendly form called Base64).
   - Example:
     ```
     PXDigest v2
     compressed:12345
     original:67890
     checksum:abc123...
     128,0 = 255,128,64
     [Base64]
     H4sI...
     ```
   - **Why Fast?** Text formats are easy to create and read. The developer didn‚Äôt need a fancy database or complex file type‚Äîjust plain text that works everywhere.

4. **Focused on Core Features**:
   - The software does just a few things: load a file, compress it, show it as pixels, and restore it. No extra bells and whistles.
   - The developer skipped complex features (like editing files or supporting multiple formats) to get it done quickly.
   - **Why Fast?** A short to-do list means less coding time. They prioritized the `.pxdigest` idea and built only what was needed.

5. **Tested with Disk Images (PxDisk Role)**:
   - The developer likely used a tool (maybe called **pxdisk**, or something like `pdisk` for disk partitioning) to make test files, such as disk images for virtual machines (e.g., TinyCore Linux, hinted by `run_tinycore_vm`).
   - They uploaded these files to test if the software could compress and restore them correctly.
   - **Why Fast?** Using existing tools to create test files (instead of making their own) saved time. Any file works, so they didn‚Äôt need special setups.

6. **Ran It in a Browser**:
   - The software runs in any modern browser (Chrome, Firefox) without needing to install anything.
   - The developer tested it by opening the web page on their computer, tweaking the code, and refreshing the browser.
   - **Why Fast?** Browsers are instant testing grounds. No need to compile or package the software like an app.

**Analogy**: It‚Äôs like building a simple lemonade stand. You use a ready-made table (web page), a lemon squeezer (Pako, browser tools), and a basic recipe (`.pxdigest` format). You test it with lemons from a store (test files from **pxdisk**) and serve customers right away (run in a browser). No need to grow your own lemons or build a fancy shop!

---

### **Why It Feels So Fast**

- **Modern Tools**: Libraries like `pako` and browser features do the hard work (compression, drawing) in a few lines of code.
- **No Setup**: It‚Äôs just one web page, not a big program that needs installing.
- **Reuse**: The developer reused standard tech (HTML, JavaScript) and didn‚Äôt reinvent the wheel.
- **Small Scope**: The software does one job well (digest files) without extra complexity.

---

### **Minimal Files Needed to Run or Recreate It**

To run or recreate the software, you need very few files because it‚Äôs so lightweight:

1. **One Main File: `pxdigest.html`**:
   - This is the web page containing:
     - **HTML**: The layout (file upload, buttons, canvas).
     - **CSS**: The look (dark theme, green text).
     - **JavaScript**: The logic (compressing, drawing, restoring).
   - Save the code you shared as `pxdigest.html` (or any name, e.g., `index.html`).
   - **Fix Needed**: The original code has a broken `<script>` tag for `pako`. Use this corrected version:
     ```html
     <!DOCTYPE html>
     <html lang="en">
     <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <title>PXDigest Lab ‚Äì Data Digester</title>
       <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
       <style>
         body { font-family: sans-serif; padding: 1rem; background: #111; color: #eee; }
         canvas { border: 1px solid #444; margin-top: 1rem; }
         .controls { margin-top: 1rem; }
         .controls button { margin-right: 1rem; }
         .metadata { font-size: 0.9rem; margin-top: 0.5rem; color: #ccc; }
         textarea { width: 100%; height: 150px; margin-top: 1rem; background: #222; color: #0f0; font-family: monospace; padding: 0.5rem; }
         pre { background: #222; padding: 1rem; color: #0ff; font-size: 0.85rem; white-space: pre-wrap; word-break: break-all; margin-top: 1rem; border: 1px solid #444; }
       </style>
     </head>
     <body>
       <h1>PXDigest Lab ‚Äì Data Digester</h1>
       <input type="file" id="fileInput">
       <div class="controls">
         <label><input type="checkbox" id="bootOnlyToggle"> Boot ID Only</label>
         <button onclick="digestAndExport()">üß™ Digest + Export (GZIP)</button>
         <button onclick="reconstructFromDigest()">‚ôªÔ∏è Reconstruct from Digest</button>
       </div>
       <button onclick="downloadDigest()">üíæ Save .pxdigest</button>
       <input type="file" id="loadDigestFile" accept=".pxdigest" style="margin-top: 1rem;">
       <canvas id="pxCanvas"></canvas>
       <div class="metadata" id="metadata"></div>
       <textarea id="digestOutput" placeholder="Digested data will appear here..."></textarea>
       <pre id="headerPreview"></pre>
       <pre id="ztxtEmitterOutput" style="color:#0f0;"></pre>

       <script>
         let fileBuffer = null;
         let originalBytes = null;

         document.getElementById('fileInput').addEventListener('change', (e) => {
           document.getElementById('loadDigestFile').value = '';
           const file = e.target.files[0];
           const reader = new FileReader();
           reader.onload = function(event) {
             fileBuffer = event.target.result;
             originalBytes = new Uint8Array(fileBuffer);
             document.getElementById('metadata').textContent = `Loaded ${file.name} (${originalBytes.length} bytes)`;
           };
           reader.readAsArrayBuffer(file);
         });

         document.getElementById('loadDigestFile').addEventListener('change', (e) => {
           const file = e.target.files[0];
           if (!file) return;
           const reader = new FileReader();
           reader.onload = function(event) {
             document.getElementById('digestOutput').value = event.target.result;
             reconstructFromDigest();
           };
           reader.readAsText(file);
         });

         async function digestAndExport() {
           if (!originalBytes) {
             alert('No file loaded. Please upload a file first.');
             return;
           }
           const compressed = pako.gzip(originalBytes);
           const base64 = btoa(String.fromCharCode(...compressed));
           const hex = Array.from(compressed).map(b => b.toString(16).padStart(2, '0')).join('');
           const headerHash = Array.from(new Uint8Array(await crypto.subtle.digest('SHA-256', originalBytes.buffer)))
             .map(b => b.toString(16).padStart(2, '0')).join('');
           const header = `PXDigest v2\ncompressed:${compressed.length}\noriginal:${originalBytes.length}\nchecksum:${headerHash}`;
           crypto.subtle.digest("SHA-256", originalBytes.buffer).then(hash => {
             const hashBytes = new Uint8Array(hash);
             const bootRGBs = [0, 3, 6, 9].map(i => [hashBytes[i], hashBytes[i+1], hashBytes[i+2]]);
             const bootText = bootRGBs.map((rgb, i) => `128,${i} = ${rgb[0]},${rgb[1]},${rgb[2]}`).join('\n');
             const digestIndex = {
               '28,63,165-177,95,8-103,48,213-229,77,212': 'pxgen/specs/run_tinycore_vm',
             };
             const bootKey = bootRGBs.map(rgb => rgb.join(',')).join('-');
             const matchedSpec = digestIndex[bootKey] || 'No match';
             const bootCanvas = document.getElementById('pxCanvas');
             const bootCtx = bootCanvas.getContext('2d');
             for (let i = 0; i < bootRGBs.length; i++) {
               const [r, g, b] = bootRGBs[i];
               bootCtx.fillStyle = `rgb(${r},${g},${b})`;
               bootCtx.fillRect(i * 10, 0, 10, 10);
             }
             const bootOnly = document.getElementById('bootOnlyToggle').checked;
             const digest = bootOnly
               ? `${header}\n${bootText}`
               : `${header}\n${bootText}\n\n[Base64]\n${base64}\n\n[Hex]\n${hex}`;
             document.getElementById('digestOutput').value = digest;
             document.getElementById('headerPreview').textContent = `// PXDigest Header Info\n${header}\n\n// Boot Pixels\n${bootText}\n\n// Bloom Match\n${bootKey} => ${matchedSpec}`;
             const ztxtSpec = `# pxgen/specs/restore_from_digest\nREAD_ZT pxgen/input/compressed_digest\nDECODE_GZIP_BASE64 TO CODE_FORGE_REGION\nHALT`;
             document.getElementById('ztxtEmitterOutput').textContent = ztxtSpec;
           });
         }

         function downloadDigest() {
           const digest = document.getElementById('digestOutput').value;
           const blob = new Blob([digest], { type: 'text/plain' });
           const a = document.createElement('a');
           a.href = URL.createObjectURL(blob);
           a.download = 'digest.pxdigest';
           a.click();
         }

         function reconstructFromDigest() {
           const digest = document.getElementById('digestOutput').value;
           const lines = digest.split('\n');
           const headerChecksum = lines[3]?.split(':')[1];
           if (!headerChecksum) {
             alert('Invalid digest format: Missing checksum.');
             return;
           }
           const base64Start = lines.indexOf('[Base64]');
           const hexStart = lines.indexOf('[Hex]');
           if (base64Start === -1) {
             alert('Invalid digest format: Missing [Base64] section.');
             return;
           }
           const base64Lines = hexStart === -1 
             ? lines.slice(base64Start + 1)
             : lines.slice(base64Start + 1, hexStart);
           const base64 = base64Lines.join('').trim();
           if (!base64) {
             alert('No Base64 data found in digest.');
             return;
           }
           try {
             const binary = atob(base64);
             const compressed = new Uint8Array(binary.length);
             for (let i = 0; i < binary.length; i++) {
               compressed[i] = binary.charCodeAt(i);
             }
             const bytes = pako.ungzip(compressed);
             originalBytes = bytes;
             drawFromBytes(bytes);
             crypto.subtle.digest('SHA-256', bytes.buffer).then(hash => {
               const verifyHash = Array.from(new Uint8Array(hash))
                 .map(b => b.toString(16).padStart(2, '0')).join('');
               const resultMsg = verifyHash === headerChecksum
                 ? `‚úÖ Reconstructed ${bytes.length} bytes (checksum OK)`
                 : `‚ö†Ô∏è Reconstructed ${bytes.length} bytes (checksum MISMATCH)`;
               document.getElementById('metadata').textContent = resultMsg;
             });
           } catch (e) {
             alert(`Error reconstructing digest: ${e.message}`);
           }
         }

         function drawFromBytes(bytes) {
           console.log('[PXDigest] Starting reconstruction of canvas from bytes.');
           const canvas = document.getElementById('pxCanvas');
           const ctx = canvas.getContext('2d');
           const totalPixels = Math.ceil(bytes.length / 3);
           const w = Math.ceil(Math.sqrt(totalPixels));
           const h = Math.ceil(totalPixels / w);
           canvas.width = w;
           canvas.height = h;
           console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);
           const bootPixels = [];
           for (let i = 0; i < 4; i++) {
             const offset = i * 3;
             bootPixels.push([bytes[offset], bytes[offset + 1] || 0, bytes[offset + 2] || 0]);
           }
           const entropyBin = new Array(256).fill(0);
           for (let b of bytes) entropyBin[b]++;
           const entropy = -entropyBin.reduce((acc, n) => {
             if (n === 0) return acc;
             const p = n / bytes.length;
             return acc + p * Math.log2(p);
           }, 0);
           console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);
           const imgData = ctx.createImageData(w, h);
           let j = 0;
           for (let i = 0; i < bytes.length; i += 3) {
             imgData.data[j++] = bytes[i];
             imgData.data[j++] = bytes[i+1] || 0;
             imgData.data[j++] = bytes[i+2] || 0;
             imgData.data[j++] = 255;
           }
           ctx.putImageData(imgData, 0, 0);
           ctx.font = '10px monospace';
           ctx.fillStyle = 'rgba(255,255,0,0.6)';
           ctx.fillText(`Entropy: ${entropy.toFixed(2)} bpb`, 5, h - 5);
           let radius = 1;
           function bloomStep() {
             ctx.beginPath();
             ctx.arc(20, 5, radius, 0, 2 * Math.PI);
             ctx.strokeStyle = 'lime';
             ctx.lineWidth = 2;
             ctx.stroke();
             radius += 5;
             if (radius < Math.max(w, h)) requestAnimationFrame(bloomStep);
           }
           bloomStep();
         }
       </script>
     </body>
     </html>
     ```
   - **Size**: ~10 KB.
   - **Purpose**: Contains everything needed to run the software.

2. **Pako Library (Optional for Offline Use)**:
   - The software uses `pako` for compression, loaded from the internet:
     ```html
     <script src="https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js"></script>
     ```
   - **Online**: No extra file needed; the browser fetches it.
   - **Offline**:
     - Download `pako.min.js` from `https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js`.
     - Save it in the same folder as `pxdigest.html`.
     - Update the `<script>` to:
       ```html
       <script src="pako.min.js"></script>
       ```
     - **Size**: ~37 KB.
     - **Purpose**: Compresses and decompresses files.

3. **Test Files (Optional)**:
   - Any file can be used (e.g., a `.txt`, `.jpg`, or `.img` file).
   - If **pxdisk** is a tool for making disk images (e.g., like `pdisk` or Win32 Disk Imager), you could use it to create a test file, such as a TinyCore Linux disk image (~16 MB).
   - **How to Get**:
     - Use `pdisk` (for Apple partitions, available on macOS/Linux).
     - Use QEMU or VirtualBox to create a VM disk image.
     - Or just use any file on your computer.
   - **Purpose**: Files to upload and test the software.

**Minimal Setup**:
- **Online**: Just `pxdigest.html` (with the CDN link for `pako`).
- **Offline**: `pxdigest.html` + `pako.min.js`.
- **Optional**: Test files (e.g., from **pxdisk**).

---

### **How to Run It**

1. **Save `pxdigest.html`**:
   - Copy the corrected code above into a file named `pxdigest.html`.

2. **Open It**:
   - **Best Way**: Host it on a local web server to avoid browser security issues:
     - Put `pxdigest.html` (and `pako.min.js` if offline) in a folder.
     - Run:
       ```bash
       python -m http.server 8000
       ```
     - Open `http://localhost:8000/pxdigest.html` in a browser.
   - **Alternative**: Double-click `pxdigest.html`, but file uploads may not work due to security restrictions.

3. **Use It**:
   - Upload a file (e.g., a text file or disk image).
   - Click ‚ÄúDigest + Export‚Äù to create a `.pxdigest`.
   - See the file as colored pixels on the canvas.
   - Save the `.pxdigest` or upload it to restore the file.

---

### **Explaining to Others**

To explain how it was made quickly to someone else (e.g., a friend or colleague):
- ‚ÄúIt‚Äôs a simple web page that uses free tools to shrink files into a special text format called `.pxdigest`. The developer wrote one file with code to read files, compress them, and show them as a picture. They used a ready-made compression tool (Pako) and browser features to avoid starting from scratch. They tested it with files like disk images, possibly made with a tool called **pxdisk**, and had it running in a browser in no time. It‚Äôs fast because it‚Äôs basic, reuses existing tools, and doesn‚Äôt need fancy setup.‚Äù

---

### **Clarifications Needed**

- **PxDisk**: I assumed **pxdisk** is a tool for creating test files (e.g., disk images), but it‚Äôs not in the code. Can you confirm what it is? For example:
  - A disk imaging tool (like `pdisk` or Win32 Disk Imager)?
  - A typo or custom tool in your project?
  - If you have details (e.g., what **pxdisk** does), I can explain its role better.
- **Issues**: Are you running the software and hitting problems (e.g., errors)? Or just curious about the process?
- **Goal**: Are you explaining this to someone technical or non-technical? Want help with a demo or simplified code?

---

### **Next Steps**

I can:
- Share a downloadable `pxdigest.html` file with all fixes (including the Base64 parsing issue from earlier).
- Provide a script to generate test disk images (e.g., with QEMU).
- Simplify the code further for a minimal version.
- Create a one-sentence explanation for a specific audience (e.g., a manager or student).

Let me know what you need or if you have more details about **pxdisk**!


















<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>PXDigest Lab ‚Äì Data Digester</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"></script>
  <style>
    body { 
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; 
      padding: 2rem; 
      background: linear-gradient(135deg, #0f0f23, #1a1a3a); 
      color: #e0e0e0; 
      margin: 0;
      min-height: 100vh;
    }
    
    h1 {
      text-align: center;
      color: #00ff88;
      text-shadow: 0 0 10px rgba(0, 255, 136, 0.3);
      margin-bottom: 2rem;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    
    .upload-section {
      background: rgba(255, 255, 255, 0.05);
      border: 2px dashed #00ff88;
      border-radius: 10px;
      padding: 2rem;
      text-align: center;
      margin-bottom: 2rem;
      transition: all 0.3s ease;
    }
    
    .upload-section:hover {
      background: rgba(0, 255, 136, 0.1);
      border-color: #00ffaa;
    }
    
    input[type="file"] {
      background: #2a2a4a;
      color: #e0e0e0;
      border: 1px solid #444;
      border-radius: 5px;
      padding: 0.5rem;
      margin: 0.5rem;
    }
    
    .controls { 
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      margin: 2rem 0;
      justify-content: center;
    }
    
    button {
      background: linear-gradient(45deg, #00ff88, #00cc66);
      color: #000;
      border: none;
      padding: 0.8rem 1.5rem;
      border-radius: 25px;
      font-weight: bold;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0, 255, 136, 0.3);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    label {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      background: rgba(255, 255, 255, 0.1);
      padding: 0.5rem 1rem;
      border-radius: 20px;
    }
    
    input[type="checkbox"] {
      accent-color: #00ff88;
    }
    
    #pxCanvas { 
      border: 2px solid #00ff88; 
      border-radius: 10px;
      margin: 2rem auto;
      display: block;
      max-width: 100%;
      box-shadow: 0 0 20px rgba(0, 255, 136, 0.2);
    }
    
    .metadata { 
      font-size: 1rem; 
      margin: 1rem 0; 
      color: #00ffaa;
      text-align: center;
      font-weight: bold;
    }
    
    textarea { 
      width: 100%; 
      height: 200px; 
      margin: 1rem 0; 
      background: #1a1a2e; 
      color: #00ff88; 
      font-family: 'Courier New', monospace; 
      padding: 1rem; 
      border: 1px solid #333;
      border-radius: 10px;
      resize: vertical;
    }
    
    pre { 
      background: #0f0f23; 
      padding: 1rem; 
      color: #00ddff; 
      font-size: 0.9rem; 
      white-space: pre-wrap; 
      word-break: break-all; 
      margin: 1rem 0; 
      border: 1px solid #333; 
      border-radius: 10px;
      overflow-x: auto;
    }
    
    .section {
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      padding: 1.5rem;
      margin: 1rem 0;
      border: 1px solid #333;
    }
    
    .section h3 {
      color: #00ff88;
      margin-top: 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>üß™ PXDigest Lab ‚Äì Data Digester</h1>
    
    <div class="upload-section">
      <h3>Upload File to Digest</h3>
      <input type="file" id="fileInput" />
      <p>Choose any file to convert into a visual digest</p>
    </div>
    
    <div class="controls">
      <label><input type="checkbox" id="bootOnlyToggle" /> Boot ID Only</label>
      <button onclick="digestAndExport()">üß™ Digest + Export (GZIP)</button>
      <button onclick="reconstructFromDigest()">‚ôªÔ∏è Reconstruct from Digest</button>
    </div>
    
    <div class="upload-section">
      <h3>Load Existing Digest</h3>
      <input type="file" id="loadDigestFile" accept=".pxdigest" />
      <p>Load a previously saved .pxdigest file</p>
    </div>

    <div class="section" id="canvasSection" style="display: none;">
      <h3>Visual Representation</h3>
      <div style="text-align: center; margin-bottom: 1rem;">
        <label for="canvasRenderMode">Render Mode:</label>
        <select id="canvasRenderMode">
          <option value="rgb">RGB (3 bytes/pixel)</option>
          <option value="grayscale">Grayscale (1 byte/pixel)</option>
          <option value="heatmap">Heatmap (1 byte/pixel)</option>
        </select>
        <label><input type="checkbox" id="pixelGridToggle" /> Pixel Grid</label>
        <button onclick="renderCanvas()">üé® Render Visual Canvas</button>
        <button onclick="downloadCanvasPNG()" id="downloadPNGBtn" style="display: none;">üì∏ Download PNG</button>
      </div>
      <div id="pxCanvasContainer" style="position: relative;">
        <canvas id="pxCanvas"></canvas>
        <div id="pixelInfo" style="position: absolute; top: 0; left: 0; background: rgba(0, 0, 0, 0.8); color: #fff; padding: 5px 10px; border-radius: 3px; font-family: monospace; font-size: 0.85rem; pointer-events: none; display: none; z-index: 10; white-space: pre; line-height: 1.2;"></div>
      </div>
      <div style="margin-top: 1rem;">
        <h4>Byte Distribution Histogram</h4>
        <canvas id="histogramCanvas" style="width: 100%; height: 150px; border: 1px solid #333;"></canvas>
      </div>
    </div>
    <div class="metadata" id="metadata">Ready to process files...</div>
    
    <div class="section" id="digestSection" style="display: none;">
      <h3>Digest Output</h3>
      <div style="text-align: center; margin-bottom: 1rem;">
        <button onclick="showDigestOutput()">üìã Show Digest Data</button>
        <button onclick="downloadDigest()" id="downloadDigestBtn" style="display: none;">üíæ Download .pxdigest</button>
      </div>
      <textarea id="digestOutput" placeholder="Digested data will appear here..." style="display: none;"></textarea>
    </div>
    
    <div class="section">
      <h3>Header Preview</h3>
      <div style="text-align: center; margin-bottom: 1rem;">
        <button onclick="copyHeaderPreview()">üìã Copy Header Info</button>
      </div>
      <pre id="headerPreview">No file processed yet...</pre>
    </div>
    
    <div class="section">
      <h3>zTXt Emitter Output</h3>
      <pre id="ztxtEmitterOutput">Waiting for file processing...</pre>
    </div>
  </div>

  <script>
    // Global variables
    let originalBytes = null;
    let currentRenderMode = 'rgb';

    // Canvas references
    const pxCanvas = document.getElementById('pxCanvas');
    const pxCtx = pxCanvas.getContext('2d');
    const histogramCanvas = document.getElementById('histogramCanvas');
    const histogramCtx = histogramCanvas.getContext('2d');
    const pixelInfoDisplay = document.getElementById('pixelInfo');
    const canvasRenderModeSelect = document.getElementById('canvasRenderMode');
    const pixelGridToggle = document.getElementById('pixelGridToggle');

    // File input handler
    document.getElementById('fileInput').addEventListener('change', (e) => {
      document.getElementById('loadDigestFile').value = '';
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        originalBytes = new Uint8Array(event.target.result);
        document.getElementById('metadata').textContent = `Loaded ${file.name} (${originalBytes.length} bytes)`;
        console.log(`File loaded: ${file.name}, ${originalBytes.length} bytes`);
        
        // Clear previous outputs
        document.getElementById('digestOutput').value = '';
        document.getElementById('headerPreview').textContent = '';
        document.getElementById('ztxtEmitterOutput').textContent = '';
      };
      reader.readAsArrayBuffer(file);
    });

    // Canvas render mode change handler
    canvasRenderModeSelect.addEventListener('change', () => {
      currentRenderMode = canvasRenderModeSelect.value;
      if (originalBytes && document.getElementById('pxCanvas').width > 0) {
        drawFromBytesOptimized(originalBytes);
      }
    });

    // Pixel grid toggle handler
    pixelGridToggle.addEventListener('change', () => {
      if (originalBytes && document.getElementById('pxCanvas').width > 0) {
        drawFromBytesOptimized(originalBytes);
      }
    });

    // Canvas hover for pixel info
    pxCanvas.addEventListener('mousemove', (e) => {
      if (!originalBytes || pxCanvas.width === 0 || pxCanvas.height === 0) {
        pixelInfoDisplay.style.display = 'none';
        return;
      }

      const rect = pxCanvas.getBoundingClientRect();
      const scaleX = pxCanvas.width / rect.width;
      const scaleY = pxCanvas.height / rect.height;
      const x = Math.floor((e.clientX - rect.left) * scaleX);
      const y = Math.floor((e.clientY - rect.top) * scaleY);

      let bytesPerPixel = currentRenderMode === 'rgb' ? 3 : 1;
      const pixelIndex = y * pxCanvas.width + x;
      const byteOffset = pixelIndex * bytesPerPixel;

      let pixelBytes = [];
      for (let i = 0; i < bytesPerPixel; i++) {
        if (byteOffset + i < originalBytes.length) {
          pixelBytes.push(originalBytes[byteOffset + i]);
        } else {
          pixelBytes.push(0);
        }
      }

      let pixelInfoText = `X: ${x}, Y: ${y}\nOffset: 0x${byteOffset.toString(16).padStart(6, '0')}`;
      if (bytesPerPixel === 3) {
        pixelInfoText += `\nRGB: ${pixelBytes[0]},${pixelBytes[1]},${pixelBytes[2]}`;
      } else {
        pixelInfoText += `\nValue: ${pixelBytes[0]}`;
      }
      pixelInfoText += `\nHex: 0x${pixelBytes.map(b => b.toString(16).padStart(2, '0')).join('')}`;

      pixelInfoDisplay.style.display = 'block';
      const containerRect = pxCanvas.parentElement.getBoundingClientRect();
      let displayX = e.clientX - containerRect.left + 10;
      let displayY = e.clientY - containerRect.top + 10;

      if (displayX + 200 > containerRect.width) {
        displayX = containerRect.width - 200;
      }
      if (displayY + 100 > containerRect.height) {
        displayY = containerRect.height - 100;
      }

      pixelInfoDisplay.style.left = `${displayX}px`;
      pixelInfoDisplay.style.top = `${displayY}px`;
      pixelInfoDisplay.innerText = pixelInfoText;
    });

    pxCanvas.addEventListener('mouseleave', () => {
      pixelInfoDisplay.style.display = 'none';
    });

    // Load digest file handler
    document.getElementById('loadDigestFile').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = function(event) {
        document.getElementById('digestOutput').value = event.target.result;
        document.getElementById('digestSection').style.display = 'block';
        showDigestOutput(); // Automatically show when loading from file
        reconstructFromDigest();
      };
      reader.readAsText(file);
    });

    // Download digest function
    function downloadDigest() {
      const digest = document.getElementById('digestOutput').value;
      if (!digest) {
        alert('No digest to download. Please show digest data first.');
        return;
      }
      
      const blob = new Blob([digest], { type: 'text/plain' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'digest.pxdigest';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
    }

    // Main digest and export function
    async function digestAndExport() {
      console.log('Digest button clicked.');
      if (!originalBytes) {
        alert('No file loaded. Please upload a file first.');
        return;
      }

      // Show processing indicator
      document.getElementById('metadata').textContent = `Processing ${originalBytes.length} bytes...`;

      try {
        // Compress the data
        const compressed = pako.gzip(originalBytes);
        
        // Convert to base64 in chunks to avoid stack overflow
        const base64 = arrayBufferToBase64(compressed);
        
        // Convert to hex in chunks
        const hex = arrayBufferToHex(compressed);
        
        // Generate checksum
        const hashBuffer = await crypto.subtle.digest('SHA-256', originalBytes.buffer);
        const headerHash = Array.from(new Uint8Array(hashBuffer))
          .map(b => b.toString(16).padStart(2, '0')).join('');
        
        const header = `PXDigest v2
compressed:${compressed.length}
original:${originalBytes.length}
checksum:${headerHash}`;

        // Compute 4-pixel boot signature (first 12 bytes of SHA-256)
        const hashBytes = new Uint8Array(hashBuffer);
        const bootRGBs = [0, 3, 6, 9].map(i => [hashBytes[i], hashBytes[i+1], hashBytes[i+2]]);
        const bootText = bootRGBs.map((rgb, i) => `128,${i} = ${rgb[0]},${rgb[1]},${rgb[2]}`).join('\n');

        // Auto-bloom registry
        const digestIndex = {
          '28,63,165-177,95,8-103,48,213-229,77,212': 'pxgen/specs/run_tinycore_vm',
          // Add more known digests here as needed
        };
        const bootKey = bootRGBs.map(rgb => rgb.join(',')).join('-');
        const matchedSpec = digestIndex[bootKey] || 'No match';

        // Draw boot pixels
        const bootCanvas = document.getElementById('pxCanvas');
        const bootCtx = bootCanvas.getContext('2d');
        bootCanvas.width = 200;
        bootCanvas.height = 50;
        
        // Clear canvas
        bootCtx.fillStyle = '#000';
        bootCtx.fillRect(0, 0, bootCanvas.width, bootCanvas.height);
        
        // Draw boot pixels
        for (let i = 0; i < bootRGBs.length; i++) {
          const [r, g, b] = bootRGBs[i];
          bootCtx.fillStyle = `rgb(${r},${g},${b})`;
          bootCtx.fillRect(i * 30, 10, 25, 25);
        }

        // Generate digest
        const bootOnly = document.getElementById('bootOnlyToggle').checked;
        const digest = bootOnly
          ? `${header}\n${bootText}`
          : `${header}\n${bootText}\n\n[Base64]\n${base64}\n\n[Hex]\n${hex}`;
        
        document.getElementById('digestOutput').value = digest;
        console.log('Digest output written to textarea.');
        
        // Update header preview
        document.getElementById('headerPreview').textContent = `// PXDigest Header Info
${header}

// Boot Pixels
${bootText}

// Bloom Match
${bootKey} => ${matchedSpec}`;

        // zTXt emitter output
        const ztxtSpec = `# pxgen/specs/restore_from_digest
READ_ZT pxgen/input/compressed_digest
DECODE_GZIP_BASE64 TO CODE_FORGE_REGION
HALT`;
        document.getElementById('ztxtEmitterOutput').textContent = ztxtSpec;

        // Show sections but keep digest hidden by default
        document.getElementById('canvasSection').style.display = 'block';
        document.getElementById('digestSection').style.display = 'block';
        document.getElementById('downloadPNGBtn').style.display = 'none';
        document.getElementById('downloadDigestBtn').style.display = 'none';

        document.getElementById('metadata').textContent = `‚úÖ Processed ${originalBytes.length} bytes successfully! Digest ready to view.`;

      } catch (error) {
        console.error('Error during digest:', error);
        alert('Error processing file: ' + error.message);
      }
    }

    // Reconstruct from digest
    function reconstructFromDigest() {
      const digest = document.getElementById('digestOutput').value;
      if (!digest) {
        alert('No digest to reconstruct from.');
        return;
      }

      try {
        const lines = digest.split('\n');
        let headerChecksum = '';
        let base64Data = '';
        let inBase64Section = false;

        // Parse the digest
        for (let line of lines) {
          if (line.startsWith('checksum:')) {
            headerChecksum = line.split(':')[1];
          } else if (line === '[Base64]') {
            inBase64Section = true;
          } else if (line === '[Hex]') {
            inBase64Section = false;
          } else if (inBase64Section && line.trim()) {
            base64Data += line.trim();
          }
        }

        if (!base64Data) {
          alert('No base64 data found in digest.');
          return;
        }

        // Decode and decompress
        const binary = base64ToArrayBuffer(base64Data);
        const compressed = new Uint8Array(binary);
        
        const bytes = pako.ungzip(compressed);
        originalBytes = bytes;
        
        // Verify checksum
        crypto.subtle.digest('SHA-256', bytes.buffer).then(hash => {
          const verifyHash = Array.from(new Uint8Array(hash))
            .map(b => b.toString(16).padStart(2, '0')).join('');
          const resultMsg = verifyHash === headerChecksum
            ? `‚úÖ Reconstructed ${bytes.length} bytes (checksum OK)`
            : `‚ö†Ô∏è Reconstructed ${bytes.length} bytes (checksum MISMATCH)`;
          document.getElementById('metadata').textContent = resultMsg;
        });

        // Show sections but keep digest hidden by default
        document.getElementById('canvasSection').style.display = 'block';
        document.getElementById('digestSection').style.display = 'block';
        document.getElementById('downloadPNGBtn').style.display = 'none';
        document.getElementById('downloadDigestBtn').style.display = 'none';

      } catch (error) {
        console.error('Error during reconstruction:', error);
        alert('Error reconstructing from digest: ' + error.message);
      }
    }

    // Draw pixels from bytes
    function drawFromBytes(bytes) {
      console.log('[PXDigest] Starting reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Calculate canvas dimensions
      const totalPixels = Math.ceil(bytes.length / 3);
      const w = Math.ceil(Math.sqrt(totalPixels));
      const h = Math.ceil(totalPixels / w);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy
      const entropyBin = new Array(256).fill(0);
      for (let b of bytes) entropyBin[b]++;
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / bytes.length;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < bytes.length; i += 3) {
        imgData.data[j++] = bytes[i];           // R
        imgData.data[j++] = bytes[i+1] || 0;    // G
        imgData.data[j++] = bytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Animate bloom effect
      let radius = 1;
      function bloomStep() {
        ctx.beginPath();
        ctx.arc(20, 20, radius, 0, 2 * Math.PI);
        ctx.strokeStyle = 'lime';
        ctx.lineWidth = 2;
        ctx.stroke();
        radius += 3;
        if (radius < 50) requestAnimationFrame(bloomStep);
      }
      bloomStep();
    }

    // Function to copy header preview to clipboard
    function copyHeaderPreview() {
      const headerText = document.getElementById('headerPreview').textContent;
      if (!headerText || headerText === 'No file processed yet...') {
        alert('No header data to copy. Please process a file first.');
        return;
      }
      
      navigator.clipboard.writeText(headerText).then(function() {
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '‚úÖ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      }).catch(function(err) {
        // Fallback for older browsers
        const textArea = document.createElement('textarea');
        textArea.value = headerText;
        document.body.appendChild(textArea);
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
        
        // Visual feedback
        const button = event.target;
        const originalText = button.textContent;
        button.textContent = '‚úÖ Copied!';
        button.style.background = 'linear-gradient(45deg, #00cc66, #00ff88)';
        
        setTimeout(() => {
          button.textContent = originalText;
          button.style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
        }, 2000);
      });
    }

    // Function to show digest output on demand
    function showDigestOutput() {
      const digestTextarea = document.getElementById('digestOutput');
      if (!digestTextarea.value) {
        alert('No digest data available to show.');
        return;
      }
      
      digestTextarea.style.display = 'block';
      document.getElementById('downloadDigestBtn').style.display = 'inline-block';
      document.getElementById('metadata').textContent = `‚úÖ Digest data displayed! (${digestTextarea.value.length} characters)`;
    }

    // Function to render the canvas on demand
    function renderCanvas() {
      if (!originalBytes) {
        alert('No file data available to render.');
        return;
      }
      
      document.getElementById('metadata').textContent = 'Rendering visual representation...';
      
      // Use setTimeout to allow UI to update
      setTimeout(() => {
        drawFromBytesOptimized(originalBytes);
        document.getElementById('downloadPNGBtn').style.display = 'inline-block';
        document.getElementById('metadata').textContent = `‚úÖ Canvas rendered! (${originalBytes.length} bytes visualized)`;
      }, 100);
    }

    // Function to download canvas as PNG
    function downloadCanvasPNG() {
      const canvas = document.getElementById('pxCanvas');
      if (!canvas.width || !canvas.height) {
        alert('No canvas to download. Please render the canvas first.');
        return;
      }
      
      // Create download link
      canvas.toBlob(function(blob) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'pxdigest_visualization.png';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }, 'image/png');
    }

    // Helper function to convert ArrayBuffer to Base64 in chunks
    function arrayBufferToBase64(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += btoa(String.fromCharCode.apply(null, chunk));
      }
      
      return result;
    }

    // Helper function to convert ArrayBuffer to Hex in chunks
    function arrayBufferToHex(buffer) {
      const bytes = new Uint8Array(buffer);
      const chunkSize = 8192; // Process in 8KB chunks
      let result = '';
      
      for (let i = 0; i < bytes.length; i += chunkSize) {
        const chunk = bytes.slice(i, i + chunkSize);
        result += Array.from(chunk).map(b => b.toString(16).padStart(2, '0')).join('');
      }
      
      return result;
    }

    // Helper function to convert Base64 to ArrayBuffer in chunks
    function base64ToArrayBuffer(base64) {
      const chunkSize = 8192; // Process in 8KB chunks
      const chunks = [];
      
      for (let i = 0; i < base64.length; i += chunkSize) {
        const chunk = base64.slice(i, i + chunkSize);
        const binary = atob(chunk);
        const bytes = new Uint8Array(binary.length);
        
        for (let j = 0; j < binary.length; j++) {
          bytes[j] = binary.charCodeAt(j);
        }
        
        chunks.push(bytes);
      }
      
      // Combine all chunks
      const totalLength = chunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const result = new Uint8Array(totalLength);
      let offset = 0;
      
      for (const chunk of chunks) {
        result.set(chunk, offset);
        offset += chunk.length;
      }
      
      return result.buffer;
    }

    // Optimized drawFromBytes function for large files
    function drawFromBytesOptimized(bytes) {
      console.log('[PXDigest] Starting optimized reconstruction of canvas from bytes.');
      
      const canvas = document.getElementById('pxCanvas');
      const ctx = canvas.getContext('2d');
      
      // Limit canvas size for performance
      const maxDimension = 1024;
      let totalPixels = Math.ceil(bytes.length / 3);
      
      // Sample data if too large
      let sampledBytes = bytes;
      if (bytes.length > maxDimension * maxDimension * 3) {
        const sampleRate = Math.ceil(bytes.length / (maxDimension * maxDimension * 3));
        sampledBytes = new Uint8Array(Math.floor(bytes.length / sampleRate));
        for (let i = 0; i < sampledBytes.length; i++) {
          sampledBytes[i] = bytes[i * sampleRate];
        }
        totalPixels = Math.ceil(sampledBytes.length / 3);
        console.log(`[PXDigest] Sampled ${sampledBytes.length} bytes (rate: 1/${sampleRate})`);
      }
      
      // Calculate canvas dimensions
      const w = Math.min(Math.ceil(Math.sqrt(totalPixels)), maxDimension);
      const h = Math.min(Math.ceil(totalPixels / w), maxDimension);
      canvas.width = w;
      canvas.height = h;
      
      console.log(`[PXDigest] Canvas size set to ${w} x ${h}`);

      // Calculate entropy on a sample
      const sampleSize = Math.min(sampledBytes.length, 100000);
      const entropyBin = new Array(256).fill(0);
      for (let i = 0; i < sampleSize; i++) {
        entropyBin[sampledBytes[i]]++;
      }
      const entropy = -entropyBin.reduce((acc, n) => {
        if (n === 0) return acc;
        const p = n / sampleSize;
        return acc + p * Math.log2(p);
      }, 0);
      
      console.log(`[PXDigest] File entropy: ${entropy.toFixed(3)} bits per byte`);

      // Create image data
      const imgData = ctx.createImageData(w, h);
      let j = 0;
      for (let i = 0; i < sampledBytes.length && j < imgData.data.length; i += 3) {
        imgData.data[j++] = sampledBytes[i];           // R
        imgData.data[j++] = sampledBytes[i+1] || 0;    // G
        imgData.data[j++] = sampledBytes[i+2] || 0;    // B
        imgData.data[j++] = 255;                       // A
      }
      
      // Fill remaining pixels with black
      while (j < imgData.data.length) {
        imgData.data[j++] = 0;   // R
        imgData.data[j++] = 0;   // G
        imgData.data[j++] = 0;   // B
        imgData.data[j++] = 255; // A
      }
      
      ctx.putImageData(imgData, 0, 0);
      
      // Add entropy text overlay
      ctx.font = '12px monospace';
      ctx.fillStyle = 'rgba(255,255,0,0.8)';
      ctx.strokeStyle = 'rgba(0,0,0,0.8)';
      ctx.lineWidth = 2;
      const text = `Entropy: ${entropy.toFixed(2)} bpb`;
      ctx.strokeText(text, 5, h - 10);
      ctx.fillText(text, 5, h - 10);
      
      console.log('[PXDigest] Pixel data rendered to canvas.');

      // Simple bloom effect
      ctx.beginPath();
      ctx.arc(20, 20, 10, 0, 2 * Math.PI);
      ctx.strokeStyle = 'lime';
      ctx.lineWidth = 3;
      ctx.stroke();
    }
  </script>
</body>
</html>