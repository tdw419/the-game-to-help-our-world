<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>PXLDISK Lab v0.6 ‚Äì With Scoring + Agent Tagging</title>
  <style>
    body { font-family: monospace; background: #111; color: #0f0; padding: 1rem; }
    canvas { border: 1px solid #0f0; margin-bottom: 1rem; }
    button, input { background: #000; color: #0f0; border: 1px solid #0f0; padding: 6px; margin: 5px; }
    #log { height: 200px; overflow-y: auto; background: #000; padding: 10px; border: 1px solid #0f0; }
    .agentTag { color: #ff0; font-weight: bold; }
  </style>
</head>
<body>
  <h1>PXLDISK Lab v0.6</h1>
  <input type="file" id="imageInput" accept="image/png">
  <button onclick="startLoop()">Start Loop</button>
  <button onclick="stopLoop()">Stop</button>
  <button onclick="rollback()">Rollback</button>
  <button onclick="validateScroll()">Validate</button>
  <canvas id="canvas"></canvas>
  <div id="log"></div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const logDiv = document.getElementById("log");
    let pxData, timer = null, history = [], agentTag = {};
    const agents = ["gpt4o", "claude", "gemini", "grok", "gpt35", "tinyllama", "mistral"];
    let currentAgent = 0;

    function log(msg) {
      logDiv.innerHTML += `[${new Date().toLocaleTimeString()}] ${msg}<br>`;
      logDiv.scrollTop = logDiv.scrollHeight;
    }

    function getIdx(x, y, w) { return (y * w + x) * 4; }

    document.getElementById("imageInput").addEventListener("change", e => {
      const file = e.target.files[0];
      const img = new Image();
      img.onload = () => {
        canvas.width = img.width;
        canvas.height = img.height;
        ctx.drawImage(img, 0, 0);
        pxData = ctx.getImageData(0, 0, img.width, img.height);
        log(`Loaded ${file.name}`);
      };
      img.src = URL.createObjectURL(file);
    });

    function snapshot() {
      return new Uint8ClampedArray(pxData.data);
    }

    function diff(before, after) {
      const out = [];
      for (let y = 64; y <= 80; y++) {
        const idx = getIdx(64, y, pxData.width);
        const oldRGB = before.slice(idx, idx+3);
        const newRGB = after.slice(idx, idx+3);
        if (!oldRGB.every((v,i) => v === newRGB[i]))
          out.push({y, from: [...oldRGB], to: [...newRGB]});
      }
      return out;
    }

    function validateScroll() {
      const valid = new Set([9,10,11,12,14,15,255]);
      let halt = false, issues = 0;
      for (let y = 64; y <= 80; y++) {
        const i = getIdx(64, y, pxData.width);
        const r = pxData.data[i], g = pxData.data[i+1], b = pxData.data[i+2];
        if (r === 255 && g === 0 && b === 0) halt = true;
        if (!valid.has(r)) {
          log(`‚ùå Invalid opcode R=${r} @ Y=${y}`);
          issues++;
        }
        if (r === 10) {
          const j = y + (g - b);
          if (j < 64 || j > 80) {
            log(`‚ö†Ô∏è JMP @ Y=${y} to out-of-bounds Y=${j}`);
            issues++;
          }
        }
      }
      if (!halt) log("‚ö†Ô∏è Missing HALT opcode");
      if (issues === 0) log("‚úÖ Scroll valid");
    }

    function rollback() {
      if (history.length === 0) return;
      const last = history.pop();
      pxData.data.set(last);
      ctx.putImageData(pxData, 0, 0);
      log(`‚è™ Rollback to previous scroll state`);
    }

    function mutate() {
      const yStart = 64;
      const yEnd = 80;
      const before = snapshot();

      const agent = agents[currentAgent % agents.length];
      currentAgent++;

      for (let i = 0; i < 4; i++) {
        const y = yStart + i * 4 + (currentAgent % 4);
        const idx = getIdx(64, y, pxData.width);
        const r = Math.floor(Math.random() * 16);
        const g = Math.floor(Math.random() * 256);
        const b = Math.floor(Math.random() * 256);
        pxData.data[idx] = r;
        pxData.data[idx+1] = g;
        pxData.data[idx+2] = b;
        agentTag[y] = agent;
      }

      const after = snapshot();
      const d = diff(before, after);
      ctx.putImageData(pxData, 0, 0);
      history.push(before);
      log(`üß¨ ${agent} mutated ${d.length} line(s):`);
      d.forEach(dif => {
        log(`  Y=${dif.y}: [${dif.from}] ‚Üí [${dif.to}] <span class='agentTag'>(${agent})</span>`);
      });
    }

    function startLoop() {
      if (!timer) {
        timer = setInterval(mutate, 5000);
        log("‚ñ∂Ô∏è Loop started");
      }
    }
    function stopLoop() {
      if (timer) {
        clearInterval(timer);
        timer = null;
        log("‚è∏Ô∏è Loop stopped");
      }
    }
  </script>
</body>
</html>















<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PXLDISK Lab: ColorOS Evolution Sandbox (v0.5)</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #1a1a2e;
            color: #e0e0e0;
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        .container {
            background-color: #2a2a4a;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
            width: 90%;
            max-width: 1200px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        h1 {
            color: #e94560;
            text-align: center;
            margin-bottom: 20px;
            width: 100%;
        }
        .panel {
            background-color: #16213e;
            border-radius: 8px;
            padding: 20px;
            box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
            flex: 1;
            min-width: 300px;
        }
        #canvasContainer {
            flex: 2;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background-color: #0f3460;
            padding: 15px;
            border-radius: 8px;
        }
        canvas {
            border: 2px solid #533483;
            background-color: #000000;
            display: block;
            margin-top: 15px;
        }
        input[type="file"], input[type="text"] {
            display: block;
            margin-bottom: 15px;
            padding: 10px;
            background-color: #3e206b;
            color: #e0e0e0;
            border: 1px solid #533483;
            border-radius: 5px;
            width: calc(100% - 22px);
        }
        input[type="file"]::-webkit-file-upload-button {
            background-color: #e94560;
            color: white;
            padding: 8px 15px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button {
            background-color: #e94560;
            color: white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1em;
            margin-right: 10px;
            transition: background-color 0.3s ease;
        }
        button:hover {
            background-color: #b31d3f;
        }
        .controls button, #askJuniorBtn {
            margin-bottom: 10px;
        }
        .log-panel {
            flex: 1;
            min-width: 300px;
            max-height: 400px;
            overflow-y: auto;
            background-color: #0f3460;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #a0a0a0;
        }
        .log-entry {
            margin-bottom: 5px;
            border-bottom: 1px dashed #2a2a4a;
            padding-bottom: 3px;
        }
        .log-entry.info { color: #88c0d0; }
        .log-entry.mutation { color: #a3be8c; }
        .log-entry.error { color: #bf616a; }
        .log-entry.system { color: #b48ead; }
        .log-entry.junior-io { color: #8BE9F9; } /* Light blue for Junior I/O */
        .log-entry.mutation .agent-name {
            font-weight: bold;
            color: #ffd700; /* Gold for agent name in mutation log */
        }

        .metric-display {
            display: flex;
            gap: 15px;
            margin-top: 15px;
            flex-wrap: wrap;
        }
        .metric-card {
            background-color: #2a2a4a;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 0.85em;
            border: 1px solid #533483;
        }
        .metric-value {
            font-weight: bold;
            color: #ffd700; /* Gold */
        }
        #ztxtDisplay {
            margin-top: 20px;
            padding: 15px;
            background-color: #1a1a2e;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.8em;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #533483;
        }
        #ztxtDisplay h3 {
            color: #e94560;
            margin-bottom: 10px;
        }
        #ztxtDisplay pre {
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <h1>PXLDISK Lab: ColorOS Evolution Sandbox</h1>

    <div class="container">
        <div class="panel">
            <h2>üì¶ PXLDISK Loader</h2>
            <input type="file" id="pxldiskFileInput" accept=".png" />
            <p>Load your 8.png or pxldisk_v2_1000x1000.png here.</p>
            <div class="metric-display">
                <div class="metric-card">Current PXLDISK: <span id="currentDiskName">None Loaded</span></div>
                <div class="metric-card">Dimensions: <span id="diskDimensions">0x0</span></div>
                <div class="metric-card">Total Mutations: <span id="mutationCount">0</span></div>
            </div>
            <div id="ztxtDisplay">
                <h3>zTXt Metadata</h3>
                <pre id="ztxtContent">No zTXt loaded.</pre>
            </div>
        </div>

        <div id="canvasContainer" class="panel">
            <h2>üñºÔ∏è PXLDISK Visualizer</h2>
            <canvas id="pxldiskCanvas"></canvas>
            <div class="metric-display">
                <div class="metric-card">Active Agent: <span id="activeAgent">None</span></div>
                <div class="metric-card">Next Mutation Start Y: <span id="nextMutationY">N/A</span></div>
            </div>
        </div>
    </div>

    <div class="container">
        <div class="panel controls">
            <h2>‚öôÔ∏è Evolution Controls</h2>
            <button id="startEvolutionBtn">üöÄ Start Evolution</button>
            <button id="pauseEvolutionBtn">‚è∏Ô∏è Pause Evolution</button>
            <button id="savePXLDISKBtn">üíæ Save Evolved PXLDISK</button>
            <p>Mutation Cycle Interval: <span id="cycleInterval">5000</span> ms</p>
            <label for="agentSelect">Agent to Simulate:</label>
            <select id="agentSelect">
                <option value="gpt4o">GPT-4o</option>
                <option value="claude">Claude</option>
                <option value="gemini">Gemini</option>
                <option value="grok">Grok</option>
                <option value="gpt35">GPT-3.5</option>
                <option value="tinyllama">TinyLLaMA</option>
                <option value="mistral">Mistral</option>
            </select>

            <h3 style="margin-top:20px;">‚úçÔ∏è Junior Text I/O</h3>
            <input type="text" id="juniorUserInput" placeholder="Ask Junior a question..." />
            <button id="askJuniorBtn">Send to Junior</button>
        </div>

        <div class="log-panel">
            <h2>üìù Evolution Log</h2>
            <div id="logOutput"></div>
        </div>
    </div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            MUTATION_INTERVAL_MS: 5000,
            PIXEL_X_CENTER: 64, // Common X-coordinate for main logic blocks
            MUTATION_ZONE_HEIGHT: 8, // Each agent mutates a block of 8 vertical pixels
            JUNIOR_INPUT_ROW: 1, // Y coord for Junior's text input (top of image)
            JUNIOR_OUTPUT_ROW: 2, // Y coord for Junior's text output (top of image)
            JUNIOR_IO_ZONE_HEIGHT: 5, // Height of Junior's I/O zones
            JUNIOR_TEXT_PX_X_START: 0, // X start for text representation in Junior's I/O rows
            JUNIOR_MAX_TEXT_LEN: 100, // Max characters Junior can handle per line (for this simple encoding)
            OPCODE_MAP: {
                0: "NOP", 1: "MOV", 2: "ADD", 3: "SUB", 4: "HALT", 5: "JMP",
                6: "CMP", 7: "LOAD", 8: "STORE", 9: "PUSH", 10: "POP",
                11: "CALL", 12: "RET", 13: "DEBUG", 14: "AND", 15: "OR", 16: "XOR"
            },
            ZONE_COLORS: { // Colors for visual debugging zones
                GPT4O: 'rgba(255, 99, 132, 0.3)', // Red
                CLAUDE: 'rgba(54, 162, 235, 0.3)', // Blue
                GEMINI: 'rgba(255, 206, 86, 0.3)', // Yellow
                GROK: 'rgba(75, 192, 192, 0.3)', // Green
                GPT35: 'rgba(153, 102, 255, 0.3)', // Purple
                TINYLLAMA: 'rgba(255, 159, 64, 0.3)', // Orange
                MISTRAL: 'rgba(201, 203, 207, 0.3)', // Grey
                JUNIOR_IO_INPUT: 'rgba(139, 233, 253, 0.2)', // Light Blue (Junior Input)
                JUNIOR_IO_OUTPUT: 'rgba(80, 250, 123, 0.2)', // Light Green (Junior Output)
                HIGHLIGHT: 'rgba(255, 255, 0, 0.7)' // Bright Yellow for active mutation
            }
        };
        CONFIG.REVERSE_OPCODE_MAP = Object.fromEntries(Object.entries(CONFIG.OPCODE_MAP).map(([key, value]) => [value, parseInt(key)]));
        // --- END CONFIGURATION ---

        // --- DOM Elements ---
        const canvas = document.getElementById('pxldiskCanvas');
        const ctx = canvas.getContext('2d');
        const pxldiskFileInput = document.getElementById('pxldiskFileInput');
        const startEvolutionBtn = document.getElementById('startEvolutionBtn');
        const pauseEvolutionBtn = document.getElementById('pauseEvolutionBtn');
        const savePXLDISKBtn = document.getElementById('savePXLDISKBtn');
        const logOutput = document.getElementById('logOutput');
        const agentSelect = document.getElementById('agentSelect');
        const juniorUserInput = document.getElementById('juniorUserInput');
        const askJuniorBtn = document.getElementById('askJuniorBtn');
        const ztxtContentPre = document.getElementById('ztxtContent');

        // Metrics display
        const currentDiskNameSpan = document.getElementById('currentDiskName');
        const diskDimensionsSpan = document.getElementById('diskDimensions');
        const mutationCountSpan = document.getElementById('mutationCount');
        const activeAgentSpan = document.getElementById('activeAgent');
        const nextMutationYSpan = document.getElementById('nextMutationY');
        const cycleIntervalSpan = document.getElementById('cycleInterval');

        // --- Global State ---
        let pxldiskImage = null;
        let pxldiskData = null; // Uint8ClampedArray for pixel data
        let evolutionInterval = null;
        let currentMutationId = 0; // Total pixels mutated
        // Start PXTalk mutations from Y=CONFIG.JUNIOR_IO_ZONE_HEIGHT*2 + 1 to leave space for Junior I/O rows (0,1,2, etc. depending on height)
        let currentNextMutationY = CONFIG.JUNIOR_IO_ZONE_HEIGHT * 2 + 1; 
        let mutationHistory = []; // Stores {imageData: ImageData, pxTalkBlock: string, agent: string, yStart: number} after each cycle
        let pxldiskMetadata = {}; // Stores ZT key-value pairs

        // --- Utility Functions ---
        function logMessage(message, type = 'info', agentName = null) {
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            const timestamp = new Date().toLocaleTimeString();
            if (agentName && type === 'mutation') {
                entry.innerHTML = `[${timestamp}] <span class="agent-name">${agentName.toUpperCase()}</span>: ${message}`;
            } else {
                entry.textContent = `[${timestamp}] ${message}`;
            }
            logOutput.appendChild(entry);
            logOutput.scrollTop = logOutput.scrollHeight;
        }

        function drawPXLDISK(highlightZone = null) {
            if (pxldiskData) {
                const imageData = new ImageData(pxldiskData, canvas.width, canvas.height);
                ctx.putImageData(imageData, 0, 0);

                // Draw mutation zones
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)'; // White semi-transparent for outline
                ctx.lineWidth = 1;

                // Draw active agent's mutation zone
                if (highlightZone) {
                    ctx.fillStyle = highlightZone.color;
                    ctx.fillRect(highlightZone.x, highlightZone.y, CONFIG.PIXEL_X_CENTER * 2, highlightZone.height);
                    ctx.strokeStyle = CONFIG.ZONE_COLORS.HIGHLIGHT;
                    ctx.lineWidth = 2;
                    ctx.strokeRect(highlightZone.x, highlightZone.y, CONFIG.PIXEL_X_CENTER * 2, highlightZone.height);
                }

                // Draw Junior I/O zones (now multi-pixel height)
                ctx.fillStyle = CONFIG.ZONE_COLORS.JUNIOR_IO_INPUT;
                ctx.fillRect(CONFIG.JUNIOR_TEXT_PX_X_START, CONFIG.JUNIOR_INPUT_ROW, canvas.width, CONFIG.JUNIOR_IO_ZONE_HEIGHT);
                ctx.fillStyle = CONFIG.ZONE_COLORS.JUNIOR_IO_OUTPUT;
                ctx.fillRect(CONFIG.JUNIOR_TEXT_PX_X_START, CONFIG.JUNIOR_OUTPUT_ROW, canvas.width, CONFIG.JUNIOR_IO_ZONE_HEIGHT);
            }
        }

        // --- PXTalk v1 Interpreter ---
        function decodePXTalkRGB(r, g, b) {
            const opcode = r;
            const opName = CONFIG.OPCODE_MAP[opcode] || "UNKNOWN_OP";
            return `${opName} R${g}, ${b}`;
        }

        // Modified parsePXTalk to handle ZT commands and return both pixel mutations and ZT updates
        function parsePXTalk(pxTalkBlock) {
            let agentName = "unknown";
            const pixelMutations = [];
            const ztMutations = {};
            const lines = pxTalkBlock.split('\n');

            lines.forEach(line => {
                const trimmedLine = line.trim();
                if (trimmedLine.startsWith('#') || trimmedLine === '') {
                    return; // Ignore comments and empty lines
                }
                if (trimmedLine.startsWith('@agent:')) {
                    agentName = trimmedLine.substring(7).trim();
                    return;
                }
                
                // Handle ZT command
                if (trimmedLine.startsWith('ZT ')) {
                    const parts = trimmedLine.substring(3).trim().split('"');
                    if (parts.length >= 2) {
                        const key = parts[0].trim();
                        const value = parts[1]; // Value is inside the first pair of quotes
                        ztMutations[key] = value;
                    } else {
                        logMessage(`Error parsing ZT line: ${trimmedLine} - Invalid format.`, 'error');
                    }
                    return;
                }

                // Handle PX command (pixel mutation)
                const parts = trimmedLine.split('=');
                if (parts.length === 2) {
                    const coordsStr = parts[0].trim();
                    const rgbStr = parts[1].split('#')[0].trim(); // Remove inline comments
                    const [x, y] = coordsStr.split(',').map(Number);
                    const rgb = rgbStr.replace(/[()]/g, '').split(',').map(Number);

                    if (!isNaN(x) && !isNaN(y) && rgb.length === 3 && rgb.every(n => !isNaN(n) && n >= 0 && n <= 255)) {
                        pixelMutations.push({ x, y, rgb, pxTalk: decodePXTalkRGB(rgb[0], rgb[1], rgb[2]) });
                    } else {
                        logMessage(`Error parsing PX line: ${trimmedLine} - Invalid coordinates or RGB.`, 'error');
                    }
                } else {
                    logMessage(`Error parsing line: ${trimmedLine} - Unexpected format (neither PX nor ZT).`, 'error');
                }
            });
            return { agent: agentName, pixelMutations: pixelMutations, ztMutations: ztMutations, pxTalkBlock: pxTalkBlock };
        }

        function applyMutationsToPixelData(pixelMutations, ztMutations) {
            if (!pxldiskData) {
                logMessage("No PXLDISK loaded to apply mutations.", 'error');
                return;
            }

            // Apply pixel mutations
            const width = canvas.width;
            let appliedPixelsCount = 0;
            pixelMutations.forEach(({ x, y, rgb, pxTalk }) => {
                const index = (y * width + x) * 4; // *4 for RGBA
                if (x >= 0 && x < width && y >= 0 && y < canvas.height && index >= 0 && index + 3 < pxldiskData.length) {
                    pxldiskData[index + 0] = rgb[0]; // R
                    pxldiskData[index + 1] = rgb[1]; // G
                    pxldiskData[index + 2] = rgb[2]; // B
                    pxldiskData[index + 3] = 255; // Ensure full opacity
                    logMessage(`Mutated (${x},${y}) to [${rgb}] -> ${pxTalk}`, 'mutation', 'System'); // Log individual pixel mutation
                    appliedPixelsCount++;
                } else {
                    logMessage(`Mutation out of bounds: (${x},${y}) - Not applied.`, 'error');
                }
            });

            // Apply ZT mutations
            for (const key in ztMutations) {
                pxldiskMetadata[key] = ztMutations[key];
                logMessage(`ZT: ${key} = "${ztMutations[key]}"`, 'info', 'System');
            }
            updateZtxtDisplay(); // Refresh ZT display

            logMessage(`Applied ${appliedPixelsCount} pixel mutations and ${Object.keys(ztMutations).length} ZT entries.`, 'system');
            currentMutationId += appliedPixelsCount; // Only count pixel changes for total mutations
            mutationCountSpan.textContent = currentMutationId;
        }

        function updateZtxtDisplay() {
            let ztText = '';
            for (const key in pxldiskMetadata) {
                ztText += `${key}: ${pxldiskMetadata[key]}\n`;
            }
            ztxtContentPre.textContent = ztText || 'No zTXt loaded or found.';
        }

        function getPixelRGB(x, y) {
            if (!pxldiskData || x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) {
                return [0, 0, 0]; // Return black for out of bounds
            }
            const index = (y * canvas.width + x) * 4;
            return [pxldiskData[index], pxldiskData[index + 1], pxldiskData[index + 2]];
        }

        // --- Agent Stubs with Scoped Mutation Zones & Basic Pixel Reading ---
        const agents = {
            gpt4o: (pxData, yOffset) => {
                const instructions = [];
                // GPT-4o: Core Logic - Read a value from a "shared register" pixel and use it.
                const sharedRegisterX = CONFIG.PIXEL_X_CENTER + 10; // Example: R0 is at X+10, Y=0
                const sharedRegisterY = 0;
                const [rVal, gVal, bVal] = getPixelRGB(sharedRegisterX, sharedRegisterY);
                const valueToUse = rVal; // Use Red channel as value from shared register

                logMessage(`GPT-4o reads shared register (${sharedRegisterX},${sharedRegisterY}): ${valueToUse}`, 'info', 'gpt-4o');

                for (let i = 0; i < CONFIG.MUTATION_ZONE_HEIGHT; i++) {
                    const y = yOffset + i;
                    // Example: MOV to R0, value based on read shared register + random offset
                    instructions.push(`${CONFIG.PIXEL_X_CENTER},${y} = ${CONFIG.REVERSE_OPCODE_MAP.MOV},${0},${(valueToUse + i) % 256} # Core Logic MOV to R0`);
                }
                // Also update a ZT entry
                instructions.push(`ZT ai/gpt4o-last-run-y "${yOffset}"`);
                instructions.push(`ZT ai/gpt4o-shared-read "${valueToUse}"`);
                return `#PXTalk v1\n@agent: gpt-4o\n${instructions.join('\n')}\n# Summary: Core logic extending with value from shared register.`;
            },
            claude: (pxData, yOffset) => {
                const instructions = [];
                instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset} = ${CONFIG.REVERSE_OPCODE_MAP.JMP},${Math.floor(Math.random() * canvas.width)},${Math.floor(Math.random() * yOffset)} # JMP Conditional`);
                instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset + 1} = ${CONFIG.REVERSE_OPCODE_MAP.CMP},${Math.floor(Math.random() * 16)},${Math.floor(Math.random() * 16)} # CMP Regs`);
                for (let i = 2; i < CONFIG.MUTATION_ZONE_HEIGHT; i++) { instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset + i} = ${CONFIG.REVERSE_OPCODE_MAP.NOP},0,0 # NOP`); }
                instructions.push(`ZT ai/claude-status "Active control flow injection at Y=${yOffset}"`);
                return `#PXTalk v1\n@agent: claude\n${instructions.join('\n')}\n# Summary: Added complex control flow.`;
            },
            gemini: (pxData, yOffset) => {
                const instructions = [];
                instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset} = ${CONFIG.REVERSE_OPCODE_MAP.DEBUG},0,0 # DEBUG Emit State`);
                instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset + 1} = ${CONFIG.REVERSE_OPCODE_MAP.STORE},${Math.floor(Math.random() * 16)},${Math.floor(Math.random() * 200)} # STORE Log to Mem`);
                for (let i = 2; i < CONFIG.MUTATION_ZONE_HEIGHT; i++) { instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset + i} = ${CONFIG.REVERSE_OPCODE_MAP.NOP},0,0 # NOP`); }
                instructions.push(`ZT ai/gemini-debug-enabled "true"`);
                return `#PXTalk v1\n@agent: gemini\n${instructions.join('\n')}\n# Summary: Enhanced introspection & debugging.`;
            },
            grok: (pxData, yOffset) => {
                const instructions = [];
                instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset} = ${CONFIG.REVERSE_OPCODE_MAP.LOAD},${Math.floor(Math.random() * 200)},${Math.floor(Math.random() * 256)} # LOAD from Mem Address`);
                instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset + 1} = ${CONFIG.REVERSE_OPCODE_MAP.STORE},${Math.floor(Math.random() * 200)},${Math.floor(Math.random() * 256)} # STORE to Mem Address`);
                for (let i = 2; i < CONFIG.MUTATION_ZONE_HEIGHT; i++) { instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset + i} = ${CONFIG.REVERSE_OPCODE_MAP.NOP},0,0 # NOP`); }
                instructions.push(`ZT ai/grok-mem-ops-active "Y=${yOffset}"`);
                return `#PXTalk v1\n@agent: grok\n${instructions.join('\n')}\n# Summary: Optimized memory operations.`;
            },
            gpt35: (pxData, yOffset) => {
                const instructions = [];
                instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset} = ${CONFIG.REVERSE_OPCODE_MAP.MOV},${Math.floor(Math.random() * 16)},${Math.floor(Math.random() * 16)} # MOV Refactored Reg to Reg`);
                for (let i = 1; i < CONFIG.MUTATION_ZONE_HEIGHT; i++) { instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset + i} = ${CONFIG.REVERSE_OPCODE_MAP.NOP},0,0 # NOP`); }
                instructions.push(`ZT ai/gpt35-optimizations "last_y_optimized:${yOffset}"`);
                return `#PXTalk v1\n@agent: gpt-3.5\n${instructions.join('\n')}\n# Summary: Code path optimization.`;
            },
            tinyllama: (pxData, yOffset) => {
                const instructions = [];
                instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset} = ${CONFIG.REVERSE_OPCODE_MAP.HALT},0,0 # HALT Error`);
                instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset + 1} = ${CONFIG.REVERSE_OPCODE_MAP.JMP},${Math.floor(Math.random() * canvas.width)},${Math.floor(Math.random() * yOffset)} # JMP Fallback`);
                for (let i = 2; i < CONFIG.MUTATION_ZONE_HEIGHT; i++) { instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset + i} = ${CONFIG.REVERSE_OPCODE_MAP.NOP},0,0 # NOP`); }
                instructions.push(`ZT ai/tinyllama-error-status "Active at Y=${yOffset}"`);
                return `#PXTalk v1\n@agent: tinyllama\n${instructions.join('\n')}\n# Summary: Error handling and self-healing.`;
            },
            mistral: (pxData, yOffset) => {
                const instructions = [];
                instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset} = ${CONFIG.REVERSE_OPCODE_MAP.ADD},${Math.floor(Math.random() * 16)},${Math.floor(Math.random() * 256)} # Experimental ADD`);
                instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset + 1} = ${CONFIG.REVERSE_OPCODE_MAP.XOR},${Math.floor(Math.random() * 16)},${Math.floor(Math.random() * 16)} # Experimental XOR`);
                for (let i = 2; i < CONFIG.MUTATION_ZONE_HEIGHT; i++) { instructions.push(`${CONFIG.PIXEL_X_CENTER},${yOffset + i} = ${CONFIG.REVERSE_OPCODE_MAP.NOP},0,0 # NOP`); }
                instructions.push(`ZT ai/mistral-experiment "Y=${yOffset}"`);
                return `#PXTalk v1\n@agent: mistral\n${instructions.join('\n')}\n# Summary: Entropy injection for novel behavior.`;
            }
        };

        // --- Core Mutation Logic ---
        function mutateCycle() {
            if (!pxldiskImage) {
                logMessage("Please load a PXLDISK image first.", 'error');
                return;
            }

            const activeAgentName = agentSelect.value;
            activeAgentSpan.textContent = activeAgentName;
            
            // Determine the Y-range for this agent's mutation block
            const startYForAgent = currentNextMutationY;
            const endYForAgent = startYForAgent + CONFIG.MUTATION_ZONE_HEIGHT;

            if (endYForAgent >= canvas.height) {
                logMessage("Reached end of canvas height. Pausing evolution. Consider expanding image or resetting Y.", 'system');
                pauseEvolution();
                return;
            }

            logMessage(`--- Starting mutation by ${activeAgentName} at Y=${startYForAgent} ---`, 'system');

            // --- Store current state to history BEFORE mutation ---
            const currentImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            mutationHistory.push({
                imageData: new ImageData(new Uint8ClampedArray(currentImageData.data), canvas.width, canvas.height), // Deep copy
                pxTalkBlock: null, // This will be filled after agent generates it
                agent: null,
                yStart: startYForAgent,
                ztMetadataSnapshot: JSON.parse(JSON.stringify(pxldiskMetadata)) // Snapshot of metadata
            });
            logMessage(`Saved state to history. Total history entries: ${mutationHistory.length}`, 'system');


            // Generate PXTalk from the selected agent stub
            const agentMutationPXTalk = agents[activeAgentName](pxldiskData, startYForAgent);
            
            // Parse and apply the mutations (updates pxldiskData and pxldiskMetadata)
            const { agent, pixelMutations, ztMutations, pxTalkBlock } = parsePXTalk(agentMutationPXTalk);
            
            // Apply mutations
            applyMutationsToPixelData(pixelMutations, ztMutations);
            
            // Update history with the generated block and agent
            mutationHistory[mutationHistory.length - 1].pxTalkBlock = pxTalkBlock;
            mutationHistory[mutationHistory.length - 1].agent = agent;


            // Draw with highlighting
            const highlightZone = {
                x: 0, // Highlight from X=0 to canvas.width for the entire Y-zone
                y: startYForAgent,
                width: canvas.width,
                height: CONFIG.MUTATION_ZONE_HEIGHT,
                color: CONFIG.ZONE_COLORS[activeAgentName.toUpperCase()] || 'rgba(255,255,255,0.3)'
            };
            drawPXLDISK(highlightZone); // Re-render canvas with new data and highlighting

            // Clear highlight after a short delay
            setTimeout(() => { drawPXLDISK(); }, CONFIG.MUTATION_INTERVAL_MS * 0.4); // Clear after 40% of interval
            
            // Update the global next mutation Y for the next agent
            currentNextMutationY = endYForAgent; 

            logMessage(`Mutation by <span class="agent-name">${agent.toUpperCase()}</span> applied. Next Y: ${currentNextMutationY}.`, 'info', agent); // Use agent name in log

            // Select next agent in a round-robin fashion
            const currentAgentIndex = Array.from(agentSelect.options).findIndex(option => option.value === activeAgentName);
            const nextAgentIndex = (currentAgentIndex + 1) % agentSelect.options.length;
            agentSelect.value = agentSelect.options[nextAgentIndex].value;

            nextMutationYSpan.textContent = currentNextMutationY; // Update UI after Y is advanced
        }

        function startEvolution() {
            if (!pxldiskImage) {
                logMessage("Load a PXLDISK image to start evolution.", 'error');
                return;
            }
            if (evolutionInterval === null) {
                logMessage("Evolution started.", 'system');
                evolutionInterval = setInterval(mutateCycle, CONFIG.MUTATION_INTERVAL_MS);
                mutateCycle(); // Run one cycle immediately
            }
            startEvolutionBtn.disabled = true;
            pauseEvolutionBtn.disabled = false;
            askJuniorBtn.disabled = true; // Disable during automated evolution
            juniorUserInput.disabled = true;
        }

        function pauseEvolution() {
            if (evolutionInterval !== null) {
                clearInterval(evolutionInterval);
                evolutionInterval = null;
                logMessage("Evolution paused.", 'system');
            }
            startEvolutionBtn.disabled = false;
            pauseEvolutionBtn.disabled = true;
            askJuniorBtn.disabled = false; // Re-enable when paused
            juniorUserInput.disabled = false;
        }

        function savePXLDISK() {
            if (!pxldiskImage) {
                logMessage("No PXLDISK loaded to save.", 'error');
                return;
            }

            const link = document.createElement('a');
            link.download = `pxldisk_evolved_${currentMutationId}_${Date.now()}.png`;
            canvas.toBlob(function(blob) {
                link.href = URL.createObjectURL(blob);
                link.click();
                logMessage(`PXLDISK saved as ${link.download}`, 'system');
            }, 'image/png'); // Specify PNG format
        }

        // --- Junior Text I/O ---
        // Converts a string to pixels in a specific row. Overwrites the row.
        function stringToPixels(str, startX, startY, pxData, width) {
            // Clear the entire line first to remove previous text
            for (let i = 0; i < width; i++) {
                // For a zone height, clear the full zone
                for (let j = 0; j < CONFIG.JUNIOR_IO_ZONE_HEIGHT; j++) {
                    const clearIndex = ((startY + j) * width + i) * 4;
                    if (clearIndex + 3 < pxData.length) {
                        pxData[clearIndex + 0] = 0; pxData[clearIndex + 1] = 0; pxData[clearIndex + 2] = 0;
                        pxData[clearIndex + 3] = 255; // Keep opaque
                    }
                }
            }

            const chars = str.split('');
            for (let i = 0; i < chars.length; i++) {
                if (i >= CONFIG.JUNIOR_MAX_TEXT_LEN) break; 
                // Write each character into the first pixel of the zone row
                const charCode = chars[i].charCodeAt(0);
                const index = (startY * width + (startX + i)) * 4; // One pixel per char
                if (index + 2 < pxData.length) {
                    pxData[index + 0] = charCode; // Store charCode in Red channel
                    pxData[index + 1] = 0; 
                    pxData[index + 2] = 0; 
                    pxData[index + 3] = 255; // Ensure full opacity
                }
            }
        }

        // Converts pixels in a specific row range to a string.
        function pixelsToString(pxData, startX, startY, width, maxLength) {
            let result = "";
            for (let i = 0; i < maxLength; i++) {
                const index = (startY * width + (startX + i)) * 4;
                if (index + 0 < pxData.length) {
                    const charCode = pxData[index + 0];
                    if (charCode === 0) break; 
                    result += String.fromCharCode(charCode);
                } else {
                    break;
                }
            }
            return result;
        }

        // --- Junior's Simulated AI Brain ---
        function juniorAIBrain(inputPixels, currentPXLDISKData) {
            const juniorInputText = pixelsToString(currentPXLDISKData, CONFIG.JUNIOR_TEXT_PX_X_START, CONFIG.JUNIOR_INPUT_ROW, canvas.width, CONFIG.JUNIOR_MAX_TEXT_LEN);
            logMessage(`Junior (reads): "${juniorInputText}"`, 'junior-io');

            let juniorResponseText = "";
            if (juniorInputText.toLowerCase().includes("status")) {
                const totalPixels = canvas.width * canvas.height;
                const mutatedPercentage = Math.floor(currentMutationId / totalPixels * 100);
                juniorResponseText = `Junior's systems are nominal. Pixels compute, ${mutatedPercentage}% mutated.`;
            } else if (juniorInputText.toLowerCase().includes("memory")) {
                const totalPixels = canvas.width * canvas.height;
                const mutatedPercentage = Math.floor(currentMutationId / totalPixels * 100);
                juniorResponseText = `Memory usage: ${mutatedPercentage}% approx. Allocating pixels as needed.`;
            } else if (juniorInputText.toLowerCase().includes("hello")) {
                juniorResponseText = "Greetings, human! How may I assist PXLDISK's evolution today?";
            } else if (juniorInputText.toLowerCase().includes("evolve")) {
                juniorResponseText = "Evolution is continuous. Submit new PXTalk blocks. I am ready.";
            } else if (juniorInputText.toLowerCase().includes("opcode")) {
                const opcodeMatch = juniorInputText.toLowerCase().match(/opcode (\d+)/);
                if (opcodeMatch && !isNaN(parseInt(opcodeMatch[1]))) {
                    const opVal = parseInt(opcodeMatch[1]);
                    juniorResponseText = `Opcode ${opVal} is: ${CONFIG.OPCODE_MAP[opVal] || "UNKNOWN"}.`;
                } else {
                    juniorResponseText = "Please specify the opcode value. (e.g., 'What is opcode 5?')";
                }
            } else if (juniorInputText.toLowerCase().includes("time")) {
                juniorResponseText = `Current PXLDISK time: ${new Date().toLocaleTimeString()}.`;
            }
            else {
                juniorResponseText = "Junior is processing your query. Query too complex for simple I/O. Please clarify.";
            }
            return juniorResponseText;
        }

        function askJunior() {
            const question = juniorUserInput.value;
            if (!question.trim()) {
                logMessage("Please type a question for Junior.", 'warning');
                return;
            }
            if (!pxldiskData) {
                logMessage("Load a PXLDISK image first to ask Junior questions.", 'error');
                return;
            }
            if (evolutionInterval !== null) { 
                pauseEvolution(); // Pause automated evolution for manual interaction
            }

            logMessage(`You (write): "${question}"`, 'junior-io');
            
            // Write question to Junior's input pixel row
            stringToPixels(question, CONFIG.JUNIOR_TEXT_PX_X_START, CONFIG.JUNIOR_INPUT_ROW, pxldiskData, canvas.width);
            drawPXLDISK(); 

            // Get Junior's response from its simulated brain
            const juniorResponse = juniorAIBrain(pxldiskData, pxldiskData);

            // Write Junior's response to its output pixel row
            stringToPixels(juniorResponse, CONFIG.JUNIOR_TEXT_PX_X_START, CONFIG.JUNIOR_OUTPUT_ROW, pxldiskData, canvas.width);
            drawPXLDISK(); 

            logMessage(`Junior (writes): "${juniorResponse}"`, 'junior-io');
            juniorUserInput.value = ''; 
        }

        // --- Event Listeners ---
        pxldiskFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    pxldiskImage = new Image();
                    pxldiskImage.onload = () => {
                        canvas.width = pxldiskImage.width;
                        canvas.height = pxldiskImage.height;
                        ctx.drawImage(pxldiskImage, 0, 0);

                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        pxldiskData = new Uint8ClampedArray(imageData.data); // Make a copy

                        // Reset state for new image
                        currentDiskNameSpan.textContent = file.name;
                        diskDimensionsSpan.textContent = `${canvas.width}x${canvas.height}`;
                        mutationCountSpan.textContent = '0';
                        currentMutationId = 0;
                        // Start PXTalk mutations from Y=3 to leave space for Junior I/O rows (0,1,2, etc. depending on height)
                        currentNextMutationY = CONFIG.JUNIOR_IO_ZONE_HEIGHT * 2 + 1; 
                        logOutput.innerHTML = ''; // Clear logs
                        mutationHistory = []; // Clear history for new image
                        pxldiskMetadata = {}; // Clear metadata for new image
                        updateZtxtDisplay(); // Clear ZT display

                        logMessage(`PXLDISK '${file.name}' loaded. Ready for evolution.`, 'system');
                        // Enable controls
                        startEvolutionBtn.disabled = false;
                        savePXLDISKBtn.disabled = false;
                        pauseEvolutionBtn.disabled = true; 
                        askJuniorBtn.disabled = false; 
                        juniorUserInput.disabled = false;

                        // Initial clear of Junior I/O rows and redraw to show empty zones
                        stringToPixels("", CONFIG.JUNIOR_TEXT_PX_X_START, CONFIG.JUNIOR_INPUT_ROW, pxldiskData, canvas.width);
                        stringToPixels("", CONFIG.JUNIOR_TEXT_PX_X_START, CONFIG.JUNIOR_OUTPUT_ROW, pxldiskData, canvas.width);
                        drawPXLDISK(); 
                    };
                    pxldiskImage.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }
        });

        startEvolutionBtn.addEventListener('click', startEvolution);
        pauseEvolutionBtn.addEventListener('click', pauseEvolution);
        savePXLDISKBtn.addEventListener('click', savePXLDISK);
        askJuniorBtn.addEventListener('click', askJunior);
        
        // Initial UI state setup
        startEvolutionBtn.disabled = true;
        pauseEvolutionBtn.disabled = true;
        savePXLDISKBtn.disabled = true;
        askJuniorBtn.disabled = true;
        juniorUserInput.disabled = true;

        cycleIntervalSpan.textContent = CONFIG.MUTATION_INTERVAL_MS;
        logMessage("Welcome to PXLDISK Lab. Load an image (like pxldisk_v2_1000x1000.png) to begin.", 'system');

    </script>
</body>
</html>



















<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>PXLDISK Evolution Sandbox</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 20px;
      background-color: #f0f0f0;
    }
    canvas {
      border: 1px solid #000;
      image-rendering: pixelated;
    }
    #controls {
      margin-top: 20px;
    }
    #console {
      width: 100%;
      height: 200px;
      background: #222;
      color: #0f0;
      font-family: monospace;
      padding: 10px;
      overflow-y: auto;
      margin-top: 20px;
    }
    button, input {
      margin: 5px;
      padding: 8px;
    }
  </style>
</head>
<body>
  <h1>PXLDISK Evolution Sandbox</h1>
  <input type="file" id="imageLoader" accept="image/png">
  <div>
    <canvas id="canvas"></canvas>
  </div>
  <div id="controls">
    <button onclick="startMutation
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	