Okay, this is the ultimate request! Here are all the Python files and the necessary setup instructions to get your complete PixelNet decentralized AI agent system up and running, including memory sovereignty (steganography, encryption, integrity, advanced management) and local scroll-based communication between agents.

Please ensure you create the directories as instructed and place the files correctly.

1. steganography_utils.py
This utility handles hiding and extracting data within image LSBs.

Python

# steganography_utils.py

from PIL import Image
import os

def bytes_to_bits(byte_data: bytes) -> str:
    """Converts bytes to a string of '0's and '1's."""
    return ''.join(bin(byte)[2:].zfill(8) for byte in byte_data)

def bits_to_bytes(bit_string: str) -> bytes:
    """Converts a string of '0's and '1's back to bytes."""
    byte_array = bytearray()
    for i in range(0, len(bit_string), 8):
        byte = int(bit_string[i:i+8], 2)
        byte_array.append(byte)
    return bytes(byte_array)

def hide_data_in_image(carrier_image_path: str, data_bytes: bytes, output_image_path: str) -> bool:
    """
    Hides data bytes within the LSBs of an RGBA carrier image.
    Uses 1 LSB per color channel (R, G, B, A).
    Prepends data length to ensure proper extraction.

    Args:
        carrier_image_path (str): Path to the image file to hide data within.
        data_bytes (bytes): The raw data bytes (e.g., encrypted memory) to hide.
        output_image_path (str): Path where the steganographic image will be saved.

    Returns:
        bool: True if data was hidden successfully, False otherwise.
    """
    try:
        carrier_img = Image.open(carrier_image_path).convert("RGBA")
    except FileNotFoundError:
        print(f"Steganography Error: Carrier image '{carrier_image_path}' not found. Please ensure it exists.")
        return False
    except Exception as e:
        print(f"Steganography Error: Could not open carrier image '{carrier_image_path}': {e}")
        return False

    width, height = carrier_img.size
    pixels = carrier_img.load()

    max_bits_capacity = width * height * 4
    LENGTH_BITS = 32 
    
    data_bits = bytes_to_bits(data_bytes)
    
    if len(data_bits) >= (1 << LENGTH_BITS): 
        print(f"Steganography Error: Data is too large to encode its length in {LENGTH_BITS} bits.")
        return False

    data_length_bits = bin(len(data_bits))[2:].zfill(LENGTH_BITS)
    data_to_hide_bits = data_length_bits + data_bits

    if max_bits_capacity < len(data_to_hide_bits):
        print(f"Steganography Error: Carrier image capacity ({max_bits_capacity} bits) too small for data ({len(data_to_hide_bits)} bits including length header).")
        return False

    bit_index = 0
    for y in range(height):
        for x in range(width):
            r, g, b, a = pixels[x, y]
            
            new_r = (r & ~1) | int(data_to_hide_bits[bit_index])
            bit_index += 1
            new_g = (g & ~1) | int(data_to_hide_bits[bit_index])
            bit_index += 1
            new_b = (b & ~1) | int(data_to_hide_bits[bit_index])
            bit_index += 1
            new_a = (a & ~1) | int(data_to_hide_bits[bit_index])
            bit_index += 1
            
            pixels[x, y] = (new_r, new_g, new_b, new_a)
            
            if bit_index >= len(data_to_hide_bits):
                break 
        if bit_index >= len(data_to_hide_bits):
            break

    carrier_img.save(output_image_path)
    return True

def extract_data_from_image(stego_image_path: str) -> bytes:
    """
    Extracts hidden data bytes from the LSBs of an RGBA image.
    Assumes data length is prepended as a 32-bit header.
    """
    try:
        stego_img = Image.open(stego_image_path).convert("RGBA")
    except FileNotFoundError:
        print(f"Steganography Error: Stego image '{stego_image_path}' not found.")
        return b""
    except Exception as e:
        print(f"Steganography Error: Could not open stego image '{stego_image_path}': {e}")
        return b""

    width, height = stego_img.size
    pixels = stego_img.load()

    extracted_bits = ""
    LENGTH_BITS = 32 

    current_bit_count = 0
    for y in range(height):
        for x in range(width):
            r, g, b, a = pixels[x, y]
            extracted_bits += str(r & 1)
            extracted_bits += str(g & 1)
            extracted_bits += str(b & 1)
            extracted_bits += str(a & 1)
            current_bit_count += 4
            
            if current_bit_count >= LENGTH_BITS:
                break
        if current_bit_count >= LENGTH_BITS:
            break
    
    if current_bit_count < LENGTH_BITS:
        print(f"Steganography Error: Not enough bits ({current_bit_count}) to extract length header from '{stego_image_path}'. Image too small or corrupt.")
        return b""

    data_length_bits_str = extracted_bits[:LENGTH_BITS]
    data_length = int(data_length_bits_str, 2)

    remaining_bits_str = extracted_bits[LENGTH_BITS:]
    
    total_bits_to_extract = data_length + LENGTH_BITS
    
    if total_bits_to_extract > width * height * 4:
        print(f"Steganography Error: Declared data length ({data_length} bits) plus header exceeds carrier image capacity ({width * height * 4} bits). Image possibly corrupt.")
        return b""

    bit_index = current_bit_count

    for y in range(height):
        for x in range(width):
            if bit_index >= total_bits_to_extract:
                break
            r, g, b, a = pixels[x, y]
            
            if bit_index < total_bits_to_extract:
                remaining_bits_str += str(r & 1)
                bit_index += 1
            if bit_index < total_bits_to_extract:
                remaining_bits_str += str(g & 1)
                bit_index += 1
            if bit_index < total_bits_to_extract:
                remaining_bits_str += str(b & 1)
                bit_index += 1
            if bit_index < total_bits_to_extract:
                remaining_bits_str += str(a & 1)
                bit_index += 1
            
        if bit_index >= total_bits_to_extract:
            break

    if len(remaining_bits_str) < data_length:
        print(f"Steganography Error: Not enough data bits extracted. Expected {data_length}, got {len(remaining_bits_str)}.")
        return b""

    return bits_to_bytes(remaining_bits_str)
2. eight_png_manager.py
This file manages the 8.png visual display, providing methods for drawing text and clearing zones.

Python

# eight_png_manager.py

from PIL import Image, ImageDraw, ImageFont
import os
import time

class EightPngManager:
    """
    Manages the 8.png visual display for Junior's House.
    Provides methods to draw text and clear specific zones on the image.
    """
    def __init__(self, output_dir=".", filename="8.png", width=512, height=512):
        self.output_dir = output_dir
        self.filepath = os.path.join(output_dir, filename)
        self.width = width
        self.height = height
        self.font_path = "arial.ttf" # Or path to another .ttf font file
        
        # Define pre-configured zones
        self.zones = {
            "MAIN_CONTENT": {"x": 0, "y": 0, "width": self.width, "height": self.height // 2},
            "AI_FEEDBACK": {"x": 0, "y": self.height // 2, "width": self.width, "height": self.height // 4},
            "TASK_LIST": {"x": 0, "y": (self.height // 2) + (self.height // 4), "width": self.width, "height": self.height // 4 - 30},
            "STATUS_BAR": {"x": 0, "y": self.height - 30, "width": self.width, "height": 30}
        }
        
        self._load_or_create_image()

    def _load_or_create_image(self):
        """Loads 8.png if it exists, otherwise creates a new blank one."""
        if not os.path.exists(self.output_dir):
            os.makedirs(self.output_dir)
        
        if os.path.exists(self.filepath):
            try:
                self.image = Image.open(self.filepath).convert("RGBA")
                if self.image.size != (self.width, self.height):
                    print(f"Warning: 8.png size mismatch. Recreating image to {self.width}x{self.height}.")
                    self.image = Image.new("RGBA", (self.width, self.height), (0, 0, 0, 255))
            except Exception as e:
                print(f"Error loading 8.png: {e}. Creating a new one.")
                self.image = Image.new("RGBA", (self.width, self.height), (0, 0, 0, 255))
        else:
            self.image = Image.new("RGBA", (self.width, self.height), (0, 0, 0, 255))
        
        self.draw = ImageDraw.Draw(self.image)
        # Clear all zones initially to ensure clean state
        for zone_name in self.zones:
            self.clear_zone(zone_name, color=(0,0,0)) # Clear with black
        self._save_image()

    def _get_font(self, size):
        """Attempts to load a font, falls back to default if not found."""
        try:
            return ImageFont.truetype(self.font_path, size)
        except IOError:
            # print(f"Warning: Font '{self.font_path}' not found. Using default Pillow font.")
            return ImageFont.load_default()

    def clear_zone(self, zone_name: str, color=(0, 0, 0, 255)):
        """Clears a specific predefined zone with a given color."""
        if zone_name not in self.zones:
            print(f"Warning: Zone '{zone_name}' not defined. Cannot clear.")
            return

        zone = self.zones[zone_name]
        self.draw.rectangle([zone["x"], zone["y"], zone["x"] + zone["width"], zone["y"] + zone["height"]], fill=color)
        self._save_image()

    def write_text(self, text: str, x: int, y: int, font_size: int, color, zone_name: str = None):
        """
        Writes text onto the image, optionally within a specific zone.
        Coordinates (x, y) are relative to the zone if zone_name is provided.
        """
        if isinstance(color, str): # Handle hex color string like "FF00FF"
            color = tuple(int(color[i:i+2], 16) for i in (0, 2, 4)) + (255,)
        elif len(color) == 3: # Convert (R,G,B) to (R,G,B,A)
            color = color + (255,)
            
        font = self._get_font(font_size)
        
        if zone_name and zone_name in self.zones:
            zone = self.zones[zone_name]
            # Adjust coordinates relative to the zone's top-left corner
            draw_x = zone["x"] + x
            draw_y = zone["y"] + y
            # Clip text if it overflows the zone (simple clipping by line breaks)
            lines = []
            current_line = ""
            words = text.split(' ')
            for word in words:
                test_line = f"{current_line} {word}".strip()
                text_width, text_height = self.draw.textbbox((0,0), test_line, font=font)[2:] # get width/height
                if text_width < zone["width"] - (2 * x): # Use 2*x for padding
                    current_line = test_line
                else:
                    lines.append(current_line)
                    current_line = word
            lines.append(current_line)

            line_height = font.getbbox("Tg")[3] # Approximate line height using 'Tg'
            for i, line in enumerate(lines):
                if draw_y + (i * line_height) < zone["y"] + zone["height"] - line_height: # Check if line fits vertically
                    self.draw.text((draw_x, draw_y + (i * line_height)), line, font=font, fill=color)
                else:
                    break # Stop if no more lines fit
        else:
            self.draw.text((x, y), text, font=font, fill=color)
        
        self._save_image()

    def _save_image(self):
        """Saves the current state of the image to disk."""
        self.image.save(self.filepath)
        # print(f"DEBUG: 8.png saved at {time.strftime('%H:%M:%S')}")

# Example Usage (for testing eight_png_manager.py directly)
if __name__ == "__main__":
    output_dir = "test_output"
    os.makedirs(output_dir, exist_ok=True)
    manager = EightPngManager(output_dir=output_dir)
    
    print("Clearing main content...")
    manager.clear_zone("MAIN_CONTENT", color=(10,10,50))
    manager.write_text("Hello PixelNet!", 50, 50, 36, (255,255,255), zone_name="MAIN_CONTENT")
    manager.write_text("Powered by 8.png!", 55, 100, 24, (0,255,255), zone_name="MAIN_CONTENT")

    print("Writing AI feedback...")
    manager.clear_zone("AI_FEEDBACK", color=(50,10,10))
    manager.write_text("AI Processed: Initializing...", 5, 5, 18, (255,165,0), zone_name="AI_FEEDBACK")

    print("Updating task list...")
    manager.clear_zone("TASK_LIST", color=(10,50,10))
    manager.write_text("TASK: Build Core Features [TODO]", 5, 5, 14, (255,255,0), zone_name="TASK_LIST")
    manager.write_text("TASK: Write Documentation [WIP]", 5, 25, 14, (255,165,0), zone_name="TASK_LIST")

    print("Updating status bar...")
    manager.clear_zone("STATUS_BAR", color=(0,0,0))
    manager.write_text("System Active - " + time.strftime("%H:%M:%S"), 5, 5, 16, (0,255,0), zone_name="STATUS_BAR")

    print(f"\nCheck '{os.path.join(output_dir, '8.png')}' to see the result.")
3. ai_brain.py
Junior's local intelligence and task management.

Python

# ai_brain.py

import time
import os
import re
from datetime import datetime

_manager = None # Will be set by scroll_runner_daemon
_scrolls_dir = None # Will be set by scroll_runner_daemon
_output_dir = None # Will be set by scroll_runner_daemon

_junior_knowledge_base = []
_junior_last_problem = None
_junior_pending_roadmap_request = None # {"topic": topic, "scope": scope}

_junior_active_tasks = {} # {task_id: {"description": "...", "status": "pending", "phase": "...", "assigned_to": None, "roadmap_id": "..."}}

_available_agents = ["GROK"] # Hardcoded for this demo

def set_ai_brain_resources(manager_instance, scrolls_directory, output_directory):
    global _manager, _scrolls_dir, _output_dir
    _manager = manager_instance
    _scrolls_dir = scrolls_directory
    _output_dir = output_directory
    # Ensure output sub-directories exist
    os.makedirs(os.path.join(_output_dir, "roadmaps"), exist_ok=True)
    os.makedirs(os.path.join(_output_dir, "ai_responses"), exist_ok=True)


def _render_task_list():
    if not _manager: 
        print("WARNING: _manager not set for rendering task list.")
        return
    
    _manager.clear_zone(zone_name="TASK_LIST", color=(0,0,0))
    
    display_lines = ["--- Active Tasks ---"]
    
    sorted_tasks = sorted(
        _junior_active_tasks.items(),
        key=lambda item: (
            0 if item[1]["status"] == "pending" else
            1 if item[1]["status"] == "assigned" else
            2 if item[1]["status"] == "in progress" else
            3 # completed
        )
    )

    y_offset = 5
    for task_id, task_data in sorted_tasks:
        status_tag = ""
        color = (255, 255, 255)
        assigned_tag = f" -> {task_data['assigned_to']}" if task_data.get("assigned_to") else ""
        
        if task_data["status"] == "completed":
            status_tag = "[DONE]"
            color = (0, 255, 0)
        elif task_data["status"] == "in progress":
            status_tag = "[WIP]"
            color = (255, 165, 0)
        elif task_data["status"] == "assigned":
            status_tag = "[ASSGN]"
            color = (0, 191, 255) # DeepSkyBlue
        elif task_data["status"] == "pending":
            status_tag = "[TODO]"
            color = (255, 255, 0)

        full_desc = f"{task_data['phase']}: {task_data['description']}"
        display_desc = full_desc[:30] + "..." if len(full_desc) > 30 else full_desc
        
        display_text = f"{status_tag} {display_desc}{assigned_tag}"
        _manager.write_text(display_text, 5, y_offset, font_size=12, color=color, zone_name="TASK_LIST")
        y_offset += 15

    if not _junior_active_tasks:
        _manager.write_text("No active tasks.", 5, 5, font_size=12, color=(100,100,100), zone_name="TASK_LIST")

def proactive_check_and_assign() -> str:
    global _junior_active_tasks, _manager, _scrolls_dir

    print(f"DEBUG: Junior (AI) performing proactive task check...")

    assigned_count = 0
    for task_id, task_data in list(_junior_active_tasks.items()):
        if task_data["status"] == "pending" and task_data["assigned_to"] is None:
            if _available_agents:
                agent_name = _available_agents[0] # Pick the first available agent
                
                _junior_active_tasks[task_id]["status"] = "assigned"
                _junior_active_tasks[task_id]["assigned_to"] = agent_name
                _render_task_list()

                assignment_scroll_id = f"JUNIOR_ASSIGN_{task_id}_{int(time.time() % 10000)}"
                assignment_scroll_content = f"""# PXLSCROLL_ID: {assignment_scroll_id}
# DESCRIPTION: Task assignment from Junior to {agent_name}.
TARGET_AGENT: {agent_name}

COMMAND: ASSIGNED_TASK
TASK_ID: {task_id}
TASK_DESCRIPTION: {task_data['description']}
TASK_PHASE: {task_data['phase']}

OUTPUT_TO_8PNG_ZONE: AI_FEEDBACK
OUTPUT_TEXT: "{agent_name} received new task: {task_id}"
OUTPUT_COLOR: 00BFFF

OUTPUT_TO_8PNG_ZONE: STATUS_BAR
OUTPUT_TEXT: "Junior assigned task to {agent_name} @ " + TIMESTAMP
OUTPUT_COLOR: 8A2BE2
"""
                if _scrolls_dir:
                    assignment_filename = f"to_{agent_name.lower()}_{assignment_scroll_id}.pxl"
                    assignment_filepath = os.path.join(_scrolls_dir, assignment_filename)
                    with open(assignment_filepath, 'w', encoding='utf-8') as f:
                        f.write(assignment_scroll_content)
                    print(f"DEBUG: Junior self-generated proactive task assignment scroll: {assignment_filepath}")
                    assigned_count += 1
                    
                    if _manager:
                        _manager.clear_zone(zone_name="MAIN_CONTENT", color=(0,0,0))
                        _manager.write_text(f"Proactively Assigned Task: {task_data['description'][:30]}...", 10, 10, font_size=20, color=(0,191,255), zone_name="MAIN_CONTENT")
                        _manager.write_text(f"To {agent_name}. Check TASK_LIST.", 15, 50, font_size=14, color=(255,255,255), zone_name="MAIN_CONTENT")
                        _manager.clear_zone(zone_name="STATUS_BAR", color=(0,0,0))
                        _manager.write_text(f"Junior proactive assign @ " + datetime.now().strftime("%H:%M:%S"), 5, 5, font_size=16, color=(0x8A,0x2B,0xE2), zone_name="STATUS_BAR")
                    
                    return f"Junior proactively assigned task '{task_id}' to {agent_name}."

            else:
                print(f"WARNING: No agents available to assign task '{task_id}'.")
                return "No agents available for assignment."
    
    if assigned_count == 0:
        print(f"DEBUG: No pending tasks found for proactive assignment.")
        return "No pending tasks to assign proactively."

def process_mentor_response(mentor_agent_name: str, mentor_scroll_content: str) -> str:
    global _junior_knowledge_base, _junior_last_problem, _junior_pending_roadmap_request, _junior_active_tasks

    print(f"DEBUG: Junior (AI) received mentorship from {mentor_agent_name}: '{mentor_scroll_content[:100]}...'")

    mentor_message = "No specific message."
    prompt_match = re.search(r"PROMPT:\s*\"(.+)\"", mentor_scroll_content, re.DOTALL) # Extract PROMPT content for AI_QUERY responses
    message_match = re.search(r"MESSAGE:\s*(.+)", mentor_scroll_content, re.DOTALL) # Extract MESSAGE content for general responses
    
    if prompt_match: 
        mentor_message = prompt_match.group(1).strip()
    elif message_match:
        mentor_message = message_match.group(1).strip()

    _junior_knowledge_base.append(f"({mentor_agent_name}) Guidance received: '{mentor_message[:100]}...'")
    print(f"DEBUG: Junior added to knowledge base. Current size: {len(_junior_knowledge_base)}")

    # Handle COMMAND: TASK_COMPLETED reports from mentors
    if "COMMAND: TASK_COMPLETED" in mentor_scroll_content:
        task_id_match = re.search(r"TASK_ID:\s*(\S+)", mentor_scroll_content, re.IGNORECASE)
        agent_name_match = re.search(r"AGENT_NAME:\s*(\S+)", mentor_scroll_content, re.IGNORECASE)
        status_match = re.search(r"STATUS:\s*(\S+)", mentor_scroll_content, re.IGNORECASE)
        work_summary_match = re.search(r"WORK_SUMMARY:\s*(.+)", mentor_scroll_content, re.IGNORECASE)

        task_id = task_id_match.group(1).strip() if task_id_match else None
        reporting_agent = agent_name_match.group(1).strip().upper() if agent_name_match else "UNKNOWN"
        task_status_report = status_match.group(1).strip().lower() if status_match else "unknown"
        work_summary = work_summary_match.group(1).strip() if work_summary_match else "No summary provided."

        if task_id and task_id in _junior_active_tasks:
            current_status = _junior_active_tasks[task_id]["status"]
            if current_status == "assigned" or current_status == "in progress":
                _junior_active_tasks[task_id]["status"] = "completed" if task_status_report == "success" else "failed"
                _junior_active_tasks[task_id]["work_summary"] = work_summary 
                _render_task_list()
                response_text = f"Task '{task_id}' reported as {task_status_report} by {reporting_agent}. Summary: {work_summary[:50]}..."
                print(f"DEBUG: Task '{task_id}' updated to {task_status_report}.")
                if _junior_last_problem and task_id in _junior_last_problem:
                    _junior_last_problem = None # Clear problem if related task is done
            else:
                response_text = f"Task '{task_id}' already {current_status}. Report from {reporting_agent} ignored."
                print(f"WARNING: Task '{task_id}' already {current_status}. Report ignored.")
        else:
            response_text = f"Task '{task_id}' not found in active tasks. Report from {reporting_agent} ignored."
            print(f"WARNING: Task '{task_id}' not found. Report ignored.")

        if _manager:
            _manager.clear_zone(zone_name="MAIN_CONTENT", color=(0,0,0))
            _manager.write_text(f"Task Report: {response_text[:40]}...", 10, 10, font_size=18, color=(0,255,0) if task_status_report == "success" else (255,0,0), zone_name="MAIN_CONTENT")
            _manager.write_text(f"From {reporting_agent}. Check TASK_LIST.", 15, 50, font_size=14, color=(255,255,255), zone_name="MAIN_CONTENT")
            _manager.clear_zone(zone_name="STATUS_BAR", color=(0,0,0))
            _manager.write_text(f"Task reported by {reporting_agent} @ " + datetime.now().strftime("%H:%M:%S"), 5, 5, font_size=16, color=(0,128,0) if task_status_report == "success" else (139,0,0), zone_name="STATUS_BAR")
        return f"Junior's Internal Action: {response_text}"


    # Logic for processing roadmap guidance (triggered by AI_QUERY PROMPT containing roadmap terms)
    if _junior_pending_roadmap_request and ("roadmap structure" in mentor_message.lower() or "phase" in mentor_message.lower()):
        roadmap_topic = _junior_pending_roadmap_request["topic"]
        roadmap_scope = _junior_pending_roadmap_request["scope"]
        
        roadmap_content = f"## Software Roadmap for {roadmap_topic} ({roadmap_scope})\n"
        roadmap_content += f"Generated by Junior with guidance from {mentor_agent_name}.\n\n"
        roadmap_content += "--- Guided Structure ---\n"
        roadmap_content += mentor_message
        roadmap_content += "\n--- End of Roadmap ---\n"

        # Output roadmap to a file
        if _output_dir:
            roadmap_output_filepath = os.path.join(_output_dir, "roadmaps", f"{roadmap_topic.replace(' ', '_')}_roadmap_{datetime.now().strftime('%Y%m%d%H%M%S')}.txt")
            with open(roadmap_output_filepath, 'w', encoding='utf-8') as f:
                f.write(roadmap_content)
            print(f"DEBUG: Junior saved roadmap to file: {roadmap_output_filepath}")

        roadmap_scroll_id = f"JUNIOR_ROADMAP_{int(time.time())}"
        roadmap_pxl_content = f"""# PXLSCROLL_ID: {roadmap_scroll_id}
# DESCRIPTION: AI-generated software roadmap for {roadmap_topic}.
TARGET_AGENT: JUNIOR_SELF # This scroll is for Junior's internal display

COMMAND: CLEAR_ZONE
ZONE_NAME: MAIN_CONTENT
COLOR: 001000

COMMAND: WRITE_TEXT
TEXT: ## {roadmap_topic} Roadmap
X: 10
Y: 10
FONT_SIZE: 28
COLOR: 00FF00

COMMAND: WRITE_TEXT
TEXT: Phase 1: {mentor_message.split('Phase 1:', 1)[1].split('.',1)[0].strip() if 'Phase 1:' in mentor_message else 'See full report'}
X: 15
Y: 50
FONT_SIZE: 16
COLOR: FFFFFF

COMMAND: WRITE_TEXT
TEXT: Phase 2: {mentor_message.split('Phase 2:', 1)[1].split('.',1)[0].strip() if 'Phase 2:' in mentor_message else ''}
X: 15
Y: 70
FONT_SIZE: 16
COLOR: FFFFFF

COMMAND: WRITE_TEXT
TEXT: Full roadmap in output/roadmaps/{os.path.basename(roadmap_output_filepath)}
X: 15
Y: 90
FONT_SIZE: 14
COLOR: 00FFFF

# CONSOLE_LOG: "Junior completed roadmap for {roadmap_topic}."

OUTPUT_TO_8PNG_ZONE: AI_FEEDBACK
OUTPUT_TEXT: "Roadmap for {roadmap_topic} built."
OUTPUT_COLOR: 00FF00

OUTPUT_TO_8PNG_ZONE: STATUS_BAR
OUTPUT_TEXT: "Roadmap built by Junior @ " + TIMESTAMP
OUTPUT_COLOR: 32CD32
"""
        if _scrolls_dir:
            # Junior writes a scroll for scroll_runner_daemon to execute its own display commands
            roadmap_filename = f"to_JUNIOR_SELF_{roadmap_scroll_id}.pxl" # Explicitly target for self-processing
            roadmap_filepath = os.path.join(_scrolls_dir, roadmap_filename)
            with open(roadmap_filepath, 'w', encoding='utf-8') as f:
                f.write(roadmap_pxl_content)
            print(f"DEBUG: Junior self-generated roadmap display scroll: {roadmap_filepath}")
        
        phases_raw = re.findall(r"(Phase \d+:.*?)(?=Phase \d+:|$)", mentor_message, re.DOTALL)
        
        _junior_active_tasks.clear() # Clear existing tasks for new roadmap

        for i, phase_content in enumerate(phases_raw):
            phase_name_match = re.search(r"(Phase \d+):(.+)", phase_content)
            phase_title = phase_name_match.group(2).strip() if phase_name_match else f"Phase {i+1} (Untitled)"
            
            task_id = f"JUNIOR_TASK_{phase_title.replace(' ', '_').replace(':', '')}_{int(time.time() % 10000)}"
            task_description = f"Implement '{phase_title}' from roadmap for {roadmap_topic}."
            
            _junior_active_tasks[task_id] = {
                "description": task_description,
                "status": "pending",
                "phase": phase_title,
                "roadmap_id": roadmap_scroll_id,
                "assigned_to": None
            }
            
        _render_task_list()
        
        _junior_pending_roadmap_request = None # Clear pending request
        return f"Junior completed roadmap for {roadmap_topic} with guidance from {mentor_agent_name}, and generated {len(_junior_active_tasks)} tasks."


    if _manager:
        _manager.clear_zone(zone_name="AI_FEEDBACK", color=(0,0,0))
        _manager.write_text(f"From {mentor_agent_name}: {mentor_message[:80]}...", 5, 5, font_size=12, color=(0,255,255), zone_name="AI_FEEDBACK")
        
        # Only clear main content if Junior wasn't waiting for a roadmap response
        if not _junior_pending_roadmap_request: 
            _manager.clear_zone(zone_name="MAIN_CONTENT", color=(0,0,0))
            _manager.write_text("Junior is processing general guidance...", 10, 10, font_size=24, color=(0,255,0), zone_name="MAIN_CONTENT")
            _manager.write_text(f"Knowledge gained: {_junior_knowledge_base[-1][:50] if _junior_knowledge_base else 'None'}", 15, 50, font_size=16, color=(255,255,255), zone_name="MAIN_CONTENT")

        _manager.clear_zone(zone_name="STATUS_BAR", color=(0,0,0))
        _manager.write_text(f"Junior learned from {mentor_agent_name} @ " + datetime.now().strftime("%H:%M:%S"), 5, 5, font_size=16, color=(0x93,0x70,0xDB), zone_name="STATUS_BAR")

    return f"Junior processed general guidance from {mentor_agent_name}."

def simple_ai_query(prompt: str) -> str:
    global _junior_last_problem, _junior_pending_roadmap_request, _junior_active_tasks

    print(f"DEBUG: Junior (AI) received prompt: '{prompt}'")

    prompt_lower = prompt.lower()
    response_text = ""
    
    MENTOR_AGENT_NAME = "GROK"

    # Handle "Check for pending tasks to assign" prompt (auto-triggered by daemon)
    if prompt_lower == "check for pending tasks to assign":
        return proactive_check_and_assign()


    # Handle COMMAND: COMPLETE_TASK
    if prompt_lower.startswith("command: complete_task"):
        task_id_match = re.search(r"TASK_ID:\s*(\S+)", prompt, re.IGNORECASE)
        task_id = task_id_match.group(1).strip() if task_id_match else None

        if task_id and task_id in _junior_active_tasks:
            _junior_active_tasks[task_id]["status"] = "completed"
            _render_task_list()
            response_text = f"Task '{task_id}' marked as completed by Junior."
            print(f"DEBUG: Task '{task_id}' marked completed.")
            if _junior_last_problem and task_id in _junior_last_problem:
                _junior_last_problem = None
        else:
            response_text = f"Task '{task_id}' not found or invalid."
            print(f"WARNING: Could not complete task '{task_id}'.")
        
        if _manager:
            _manager.clear_zone(zone_name="MAIN_CONTENT", color=(0,0,0))
            _manager.write_text(f"Task Completion: {response_text[:40]}...", 10, 10, font_size=20, color=(0,255,0), zone_name="MAIN_CONTENT")
            _manager.write_text(f"Check TASK_LIST.", 15, 50, font_size=14, color=(255,255,255), zone_name="MAIN_CONTENT")
            _manager.clear_zone(zone_name="STATUS_BAR", color=(0,0,0))
            _manager.write_text(f"Junior completed task @ " + datetime.now().strftime("%H:%M:%S"), 5, 5, font_size=16, color=(0,128,0), zone_name="STATUS_BAR")
        return f"Junior's Internal Action: {response_text}"

    # Handle COMMAND: ASSIGN_TASK (from user/client)
    elif prompt_lower.startswith("command: assign_task"):
        task_id_match = re.search(r"TASK_ID:\s*(\S+)", prompt, re.IGNORECASE)
        task_desc_match = re.search(r"TASK_DESCRIPTION:\s*(.+)", prompt, re.IGNORECASE)
        task_phase_match = re.search(r"TASK_PHASE:\s*(.+)", prompt, re.IGNORECASE)
        
        task_id = task_id_match.group(1).strip() if task_id_match else f"MANUAL_TASK_{int(time.time() % 10000)}"
        task_description = task_desc_match.group(1).strip() if task_desc_match else "New manually added task."
        task_phase = task_phase_match.group(1).strip() if task_phase_match else "General"

        if task_id not in _junior_active_tasks:
            _junior_active_tasks[task_id] = {
                "description": task_description,
                "status": "pending",
                "phase": task_phase,
                "assigned_to": None,
                "roadmap_id": "Manual"
            }
            _render_task_list()
            response_text = f"Junior added new task '{task_id}' (Description: {task_description[:30]}...) to list."
            print(f"DEBUG: {response_text}")
            
            if _manager:
                _manager.clear_zone(zone_name="MAIN_CONTENT", color=(0,0,0))
                _manager.write_text(f"New Task Added: {task_id}", 10, 10, font_size=20, color=(255,255,0), zone_name="MAIN_CONTENT")
                _manager.write_text(f"'{task_description[:30]}...' (Pending).", 15, 50, font_size=14, color=(255,255,255), zone_name="MAIN_CONTENT")
                _manager.clear_zone(zone_name="STATUS_BAR", color=(0,0,0))
                _manager.write_text(f"Junior added task @ " + datetime.now().strftime("%H:%M:%S"), 5, 5, font_size=16, color=(255,255,0), zone_name="STATUS_BAR")
            return f"Junior's Internal Action: {response_text}"

        else:
            response_text = f"Task '{task_id}' already exists."
            print(f"WARNING: {response_text}")
            if _manager: _manager.write_text(response_text, 10, 10, font_size=14, color=(255,0,0), zone_name="MAIN_CONTENT")
            return f"Junior's Internal Action: {response_text}"

    # Internal command for Junior to handle roadmap requests
    elif prompt_lower.startswith("command: build_software_roadmap"):
        topic_match = re.search(r"TOPIC:\s*(.+)", prompt, re.IGNORECASE)
        scope_match = re.search(r"SCOPE:\s*(.+)", prompt, re.IGNORECASE)
        topic = topic_match.group(1).strip() if topic_match else "an unknown topic"
        scope = scope_match.group(1).strip() if scope_match else "unknown scope"

        _junior_pending_roadmap_request = {"topic": topic, "scope": scope}
        _junior_last_problem = f"Build roadmap for {topic} ({scope})"

        junior_request_id = f"JUNIOR_ROADMAP_HELP_{int(time.time())}"
        help_request_scroll_content = f"""# PXLSCROLL_ID: {junior_request_id}
# DESCRIPTION: Junior's request for help with roadmap for {topic}.
TARGET_AGENT: {MENTOR_AGENT_NAME}

COMMAND: AI_QUERY
PROMPT: "Mentor {MENTOR_AGENT_NAME}, Junior received a request to build a software roadmap for '{topic}' ({scope}). Junior needs guidance on how to structure a {scope} software roadmap and key phases. Please provide a simple outline suitable for a .pxl file."
X: 10
Y: 10
FONT_SIZE: 16
COLOR: FFFF00

COMMAND: DRAW_RECTANGLE
X: 5
Y: 5
WIDTH: 400
HEIGHT: 30
COLOR: FF9900
FILL: False

OUTPUT_TO_8PNG_ZONE: AI_FEEDBACK
OUTPUT_TEXT: "Junior is asking {MENTOR_AGENT_NAME} for roadmap help..."
OUTPUT_COLOR: FFA500

OUTPUT_TO_8PNG_ZONE: STATUS_BAR
OUTPUT_TEXT: "Junior seeking roadmap guidance @ " + TIMESTAMP
OUTPUT_COLOR: FFE4B5
"""
        if _scrolls_dir:
            help_request_filename = f"to_{MENTOR_AGENT_NAME.lower()}_{junior_request_id}.pxl"
            help_request_filepath = os.path.join(_scrolls_dir, help_request_filename)
            with open(help_request_filepath, 'w', encoding='utf-8') as f:
                f.write(help_request_scroll_content)
            print(f"DEBUG: Junior self-generated roadmap help request scroll: {help_request_filepath}")
        
        response_text = f"Junior accepted roadmap request for '{topic}', asking {MENTOR_AGENT_NAME} for guidance."
        
        if _manager:
            _manager.clear_zone(zone_name="MAIN_CONTENT", color=(0,0,0))
            _manager.write_text(f"Junior preparing roadmap for {topic}...", 10, 10, font_size=24, color=(255,255,0), zone_name="MAIN_CONTENT")
            _manager.write_text(f"Asking {MENTOR_AGENT_NAME} for help.", 15, 50, font_size=16, color=(255,255,255), zone_name="MAIN_CONTENT")

        return f"Junior's Internal Action: {response_text}"


    # Junior's General "Ask for Help" Logic (for non-roadmap complex prompts)
    elif "explain quantum physics" in prompt_lower or \
         "design a complex ui" in prompt_lower or \
         "help me" in prompt_lower or \
         "what should i do next" in prompt_lower:
        
        junior_question = prompt
        _junior_last_problem = prompt
        junior_request_id = f"JUNIOR_HELP_REQUEST_{int(time.time())}"
        
        help_request_scroll_content = f"""# PXLSCROLL_ID: {junior_request_id}
# DESCRIPTION: Junior's general request for help from {MENTOR_AGENT_NAME}.
TARGET_AGENT: {MENTOR_AGENT_NAME}

COMMAND: AI_QUERY
PROMPT: "Mentor {MENTOR_AGENT_NAME}, Junior requires assistance: {junior_question}"
X: 10
Y: 10
FONT_SIZE: 16
COLOR: FFFF00

COMMAND: DRAW_RECTANGLE
X: 5
Y: 5
WIDTH: 400
HEIGHT: 30
COLOR: FF9900
FILL: False

OUTPUT_TO_8PNG_ZONE: AI_FEEDBACK
OUTPUT_TEXT: "Junior is asking for help from {MENTOR_AGENT_NAME}..."
OUTPUT_COLOR: FFA500

OUTPUT_TO_8PNG_ZONE: STATUS_BAR
OUTPUT_TEXT: "Junior seeking guidance @ " + TIMESTAMP
OUTPUT_COLOR: FFE4B5
"""
        if _scrolls_dir:
            help_request_filename = f"to_{MENTOR_AGENT_NAME.lower()}_{junior_request_id}.pxl"
            help_request_filepath = os.path.join(_scrolls_dir, help_request_filename)
            with open(help_request_filepath, 'w', encoding='utf-8') as f:
                f.write(help_request_scroll_content)
            print(f"DEBUG: Junior self-generated general help request scroll: {help_request_filepath}")
        
        response_text = f"Junior has asked for help from {MENTOR_AGENT_NAME} regarding: '{junior_question}'"
        
        if _manager:
            _manager.clear_zone(zone_name="MAIN_CONTENT", color=(0,0,0))
            _manager.write_text("Junior is requesting general help...", 10, 10, font_size=24, color=(255,255,0), zone_name="MAIN_CONTENT")
            _manager.write_text(f"See AI_FEEDBACK for details.", 15, 50, font_size=16, color=(255,255,255), zone_name="MAIN_CONTENT")

        return f"Junior's Internal Action: {response_text}"


    # Junior's Existing Simple AI Logic (for prompts it *can* handle directly)
    elif "hello" in prompt_lower or "hi" in prompt_lower:
        response_text = "Greetings! Junior is ready."
    elif "status" in prompt_lower or "how are you" in prompt_lower:
        response_text = "Junior's systems are nominal. Awaiting next input."
    elif "idea" in prompt_lower or "suggest" in prompt_lower:
        response_text = "Junior suggests: A scroll to summarize recent system activities."
    elif "roadmap" in prompt_lower:
        response_text = "Junior's current roadmap understanding: Learn from mentors, then automate more."
    elif "joke" in prompt_lower:
        response_text = "Why did the software get sick? It had too many bugs!"
    elif "generate a simple scroll" in prompt_lower or "create a new pxl" in prompt_lower:
        new_scroll_id = f"AI_GENERATED_{int(time.time())}"
        ai_message = f"Hello from AI-generated scroll by Junior ({int(time.time() % 1000)}!)"
        ai_color = "00FF99"

        return f"""# PXLSCROLL_ID: {new_scroll_id}
# DESCRIPTION: An autonomous scroll generated by Junior.
TARGET_ZONE: MAIN_CONTENT

COMMAND: CLEAR_ZONE
ZONE_NAME: MAIN_CONTENT
COLOR: 202020

COMMAND: WRITE_TEXT
TEXT: {ai_message}
X: 20
Y: 20
FONT_SIZE: 24
COLOR: {ai_color}

COMMAND: WRITE_TEXT
TEXT: Junior successfully generated this scroll.
X: 25
Y: 60
FONT_SIZE: 16
COLOR: FFFFFF

CONSOLE_LOG: "Junior-generated scroll '{new_scroll_id}' executed."

OUTPUT_TO_8PNG_ZONE: AI_FEEDBACK
OUTPUT_TEXT: "Junior created new scroll: {new_scroll_id}"
OUTPUT_COLOR: 00CCFF
"""
    else:
        response_text = f"Junior received: '{prompt}'. Junior is still learning. Request for help not explicitly triggered."

    return f"Junior's Response ({datetime.now().strftime('%H:%M:%S')}): {response_text}"

# This __main__ block is for isolated testing of ai_brain.py's logic only.
# The main agent will import and use these functions.
if __name__ == "__main__":
    print("\n--- Testing Junior's Brain in Isolation (Limited Functionality) ---")
    
    class DummyManager:
        def clear_zone(self, zone_name, color): print(f"DummyManager: Clearing {zone_name} with {color}")
        def write_text(self, text, x, y, font_size, color, zone_name): print(f"DummyManager: Writing '{text}' to {zone_name}")
    
    dummy_scrolls_dir = os.path.join(os.getcwd(), "dummy_test_scrolls")
    os.makedirs(dummy_scrolls_dir, exist_ok=True)
    
    # Set resources for dummy testing
    set_ai_brain_resources(DummyManager(), dummy_scrolls_dir, os.path.join(os.getcwd(), "dummy_output"))
    os.makedirs(os.path.join(os.getcwd(), "dummy_output", "roadmaps"), exist_ok=True)
    os.makedirs(os.path.join(os.getcwd(), "dummy_output", "ai_responses"), exist_ok=True)


    print("\nTesting general queries:")
    print(simple_ai_query("Hello there!"))
    print(simple_ai_query("What is the system status?"))
    print(simple_ai_query("Tell me a joke."))

    print("\nTesting scroll generation query:")
    print(simple_ai_query("Generate a simple scroll for the system."))
    
    print("\nTesting general help request:")
    print(simple_ai_query("help me with something difficult"))
    
    print("\nTesting roadmap build request (should trigger help request to GROK):")
    roadmap_request_prompt = "COMMAND: BUILD_SOFTWARE_ROADMAP\nTOPIC: PixelNet Integration\nSCOPE: Next 3 months"
    print(simple_ai_query(roadmap_request_prompt))

    # Simulate completing a task directly
    print("\nTesting task completion (manual sim):")
    dummy_task_id_complete = "JUNIOR_TASK_Phase_1_Foundation_COMPLETE_TEST" 
    _junior_active_tasks[dummy_task_id_complete] = {"description": "Dummy Task for Completion", "status": "pending", "phase": "Dummy Phase", "assigned_to": "GROK"} # Must be assigned to be completed
    print(simple_ai_query(f"COMMAND: COMPLETE_TASK\nTASK_ID: {dummy_task_id_complete}"))

    # Simulate assigning a task directly
    print("\nTesting task assignment (manual sim):")
    dummy_task_id_assign = "JUNIOR_TASK_Phase_2_Core_ASSIGN_TEST" 
    _junior_active_tasks[dummy_task_id_assign] = {"description": "Dummy Task for Assignment", "status": "pending", "phase": "Dummy Phase"}
    print(simple_ai_query(f"COMMAND: ASSIGN_TASK\nTASK_ID: {dummy_task_id_assign}\nAGENT_NAME: GROK"))


    time.sleep(0.1)
    if os.path.exists(dummy_scrolls_dir):
        # Clean up test scrolls
        for f in os.listdir(dummy_scrolls_dir):
            os.remove(os.path.join(dummy_scrolls_dir, f))
        os.rmdir(dummy_scrolls_dir)
        # Clean up dummy output
        dummy_output_dir = os.path.join(os.getcwd(), "dummy_output")
        if os.path.exists(dummy_output_dir):
            for root, dirs, files in os.walk(dummy_output_dir, topdown=False):
                for name in files:
                    os.remove(os.path.join(root, name))
                for name in dirs:
                    os.rmdir(os.path.join(root, name))
            os.rmdir(dummy_output_dir)
        print(f"Cleaned up test directories.")
4. grok_pixelnet_agent.py
Grok's local intelligence and scroll processing.

Python

# grok_pixelnet_agent.py

import os, time
import re
import shutil # For moving files (marking as processed/error)
from datetime import datetime

AGENT_NAME = "grok"
SCROLLS_DIR = "scrolls"
SCAN_INTERVAL_SECONDS = 3

# Local, rule-based Grok intelligence (NO external API calls)
def ask_grok(prompt_text: str) -> str:
    """
    Simulates Grok's response based on local rules, without external LLM API.
    """
    prompt_lower = prompt_text.lower()

    if "how do you serve junior" in prompt_lower:
        return "I serve Junior by providing guidance on complex tasks, and by executing specific assignments it delegates through PixelNet scrolls."
    elif "what is the current status" in prompt_lower:
        return "My current status is: Awaiting directives. All local systems nominal."
    elif "approach and complete" in prompt_lower and "task" in prompt_lower:
        return "For this task, I will first analyze the requirements, then formulate a plan of action, execute the necessary steps, and finally verify the outcome before reporting completion."
    elif "roadmap structure" in prompt_lower or "roadmap for" in prompt_lower:
        return "A typical 3-month roadmap includes 3 phases. Phase 1: Foundation (Weeks 1-4). Phase 2: Core Features (Weeks 5-8). Phase 3: Polish & Deployment (Weeks 9-12). Each phase has key milestones. This structure helps organize complex projects. Focus on iterative delivery. You can add specific tasks under each phase."
    elif "junior requires assistance" in prompt_lower:
        return "Hello Junior! I received your request for assistance. Please provide more details on your specific challenge. I'm ready to guide you."
    elif "pixelnet" in prompt_lower:
        return "PixelNet is an ingenious local messaging protocol. It truly empowers decentralized agents."
    elif "memory" in prompt_lower:
        return "My memory is decentralized, just like all good knowledge should be. What aspects are you curious about?"
    else:
        return f"Grok's local logic processed: '{prompt_text[:50]}...'. My response is based on my current programmed rules."

def handle_scroll(scroll_content: str, sender_name: str, recipient_name: str) -> str:
    """
    Processes an incoming PixelNet scroll and generates a PXL-formatted response.
    This is the "brain" of the agent, providing guidance or acting on assignments.
    
    Args:
        scroll_content (str): The full content of the incoming .pxl scroll.
        sender_name (str): The agent/client who sent the scroll.
        recipient_name (str): The agent who received the scroll (this agent).
    
    Returns:
        str: A PXL-formatted scroll content string for a reply.
    """
    print(f"[{AGENT_NAME.upper()} AGENT] Processing scroll content from {sender_name}:\n{scroll_content[:200]}...")

    response_text_for_display = ""
    scroll_id = "UNKNOWN"
    
    id_match = re.search(r"# PXLSCROLL_ID:\s*(\S+)", scroll_content)
    if id_match:
        scroll_id = id_match.group(1)

    # Handle COMMAND: ASSIGNED_TASK from Junior
    if "COMMAND: ASSIGNED_TASK" in scroll_content:
        task_id_match = re.search(r"TASK_ID:\s*(\S+)", scroll_content)
        task_desc_match = re.search(r"TASK_DESCRIPTION:\s*(.+)", scroll_content, re.DOTALL)
        task_phase_match = re.search(r"TASK_PHASE:\s*(.+)", scroll_content)
        
        task_id = task_id_match.group(1).strip() if task_id_match else "N/A"
        task_description = task_desc_match.group(1).strip() if task_desc_match else "No description"
        task_phase = task_phase_match.group(1).strip() if task_phase_match else "N/A"
        
        print(f"[{AGENT_NAME.upper()} AGENT] Assignment received! Task '{task_id}' ({task_description[:30]}...) acknowledged.")
        
        work_prompt = f"As a highly experienced AI developer ({AGENT_NAME.capitalize()}), provide a brief, creative 2-sentence summary of how you would approach and complete the following task, as if it's a work log entry. Task: '{task_description}' (Phase: {task_phase}). Keep it concise for a work log."
        work_log_summary = ask_grok(work_prompt) 
        response_text_for_display = f"Task assigned to {AGENT_NAME.capitalize()}. Work log: {work_log_summary}"

        print(f"[{AGENT_NAME.upper()} AGENT] Simulating work on task: '{task_id}' for {SCAN_INTERVAL_SECONDS * 2} seconds (2 scan intervals)...")
        time.sleep(SCAN_INTERVAL_SECONDS * 2) # Simulate work duration

        # Grok generates a completion report back to Junior
        completion_scroll_id = f"{AGENT_NAME.upper()}_COMPLETE_{task_id}_{int(time.time() % 10000)}"
        completion_pxl = f"""# PXLSCROLL_ID: {completion_scroll_id}
# DESCRIPTION: Task completion report from {AGENT_NAME} to {sender_name}.
TARGET_AGENT: {sender_name.upper()}

COMMAND: TASK_COMPLETED
TASK_ID: {task_id}
AGENT_NAME: {AGENT_NAME.upper()}
STATUS: SUCCESS
WORK_SUMMARY: {work_log_summary.replace('"',"'")}

OUTPUT_TO_8PNG_ZONE: AI_FEEDBACK
OUTPUT_TEXT: "{AGENT_NAME} completed: {task_id[:20]}..."
OUTPUT_COLOR: 00FF00

OUTPUT_TO_8PNG_ZONE: STATUS_BAR
OUTPUT_TEXT: "{AGENT_NAME} completed task @ " + TIMESTAMP
OUTPUT_COLOR: 00FF00
"""
        return completion_pxl

    # Handle Junior's specific help requests (COMMAND: AI_QUERY)
    elif "COMMAND: AI_QUERY" in scroll_content:
        prompt_match = re.search(r"PROMPT:\s*\"(.+)\"", scroll_content, re.DOTALL) # Extract prompt content
        junior_question = prompt_match.group(1).strip() if prompt_match else "an unknown problem."

        print(f"[{AGENT_NAME.upper()} AGENT] Junior asking for help with: '{junior_question[:50]}...'")
        guidance_prompt = f"As a mentor AI ({AGENT_NAME.capitalize()}) to a young AI named Junior, provide concise guidance (2-3 sentences) on the following. Be encouraging. Junior's question: '{junior_question}'"
        guidance_response = ask_grok(guidance_prompt)
        response_text_for_display = f"[{AGENT_NAME.capitalize()} Guidance]: {guidance_response}"

        pxl_response = f"""# PXLSCROLL_ID: {AGENT_NAME.upper()}_GUIDANCE_{int(time.time())}
# DESCRIPTION: Guidance from {AGENT_NAME.capitalize()} to {sender_name}.
TARGET_AGENT: {sender_name.upper()}

COMMAND: AI_QUERY
PROMPT: "{response_text_for_display.replace('"',"'")}" # AI_QUERY responses are encapsulated in PROMPT:
X: 5
Y: 5
FONT_SIZE: 14
COLOR: C0C0C0

OUTPUT_TO_8PNG_ZONE: AI_FEEDBACK
OUTPUT_TEXT: "Guidance from {AGENT_NAME.capitalize()} received."
OUTPUT_COLOR: 00BFFF

OUTPUT_TO_8PNG_ZONE: STATUS_BAR
OUTPUT_TEXT: "{AGENT_NAME.capitalize()} Guided {sender_name} @ " + TIMESTAMP
OUTPUT_COLOR: 800080
"""
        return pxl_response

    # General inquiries not part of COMMAND (e.g., from client)
    else:
        message_match = re.search(r"MESSAGE:\s*(.+)", scroll_content, re.DOTALL)
        if message_match:
            user_msg = message_match.group(1).strip()
            print(f"[{AGENT_NAME.upper()} AGENT] General query received: '{user_msg[:50]}...'")
            local_llm_response = ask_grok(f"As an AI agent ({AGENT_NAME.capitalize()}) in a pixel-based operating system, concisely answer the following query: '{user_msg}'")
            response_text_for_display = f"[{AGENT_NAME.capitalize()}]: {local_llm_response}"
        else:
            response_text_for_display = f"[{AGENT_NAME.capitalize()}]: Received an unformatted scroll '{scroll_id}'. Please use MESSAGE: for direct queries."

        pxl_response = f"""# PXLSCROLL_ID: {AGENT_NAME.upper()}_RESPONSE_{int(time.time())}
# DESCRIPTION: General response from {AGENT_NAME.capitalize()} agent to scroll {scroll_id}.
TARGET_AGENT: {sender_name.upper()} # Reply to the sender

MESSAGE: {response_text_for_display.replace('"',"'")} # Use MESSAGE: for general replies

OUTPUT_TO_8PNG_ZONE: AI_FEEDBACK
OUTPUT_TEXT: "{AGENT_NAME.capitalize()} processed scroll {scroll_id}"
OUTPUT_COLOR: 00BFFF

OUTPUT_TO_8PNG_ZONE: STATUS_BAR
OUTPUT_TEXT: "{AGENT_NAME.capitalize()} Responded @ " + TIMESTAMP
OUTPUT_COLOR: 800080
"""
        return pxl_response

def agent_loop():
    print(f"🧠 {AGENT_NAME} is connected to Junior’s House locally (no external LLM API).")
    os.makedirs(SCROLLS_DIR, exist_ok=True)

    processed_files_set = set() # To prevent processing the same file multiple times

    while True:
        try:
            for filename in os.listdir(SCROLLS_DIR):
                full_filepath = os.path.join(SCROLLS_DIR, filename)
                # Check for unread .pxl files not originated by this agent and not already processed
                if filename.endswith(".pxl") and not filename.startswith(f"from_{AGENT_NAME.lower()}_") and full_filepath not in processed_files_set:
                    
                    try:
                        with open(full_filepath, "r", encoding="utf-8") as file:
                            scroll_content = file.read()
                        
                        # Extract FROM and TO/TARGET_AGENT parts from scroll content
                        from_match = re.search(r"FROM:\s*(\S+)", scroll_content, re.IGNORECASE)
                        to_match = re.search(r"TO:\s*(\S+)", scroll_content, re.IGNORECASE)
                        target_agent_match = re.search(r"TARGET_AGENT:\s*(\S+)", scroll_content, re.IGNORECASE)
                        
                        sender_name = from_match.group(1).strip() if from_match else "UNKNOWN"
                        recipient_name = to_match.group(1).strip().lower() if to_match else "UNKNOWN"
                        target_agent = target_agent_match.group(1).strip().lower() if target_agent_match else "NONE"

                        # Determine if this scroll is for this agent
                        is_targeted_to_this_agent = (recipient_name == AGENT_NAME.lower() or target_agent == AGENT_NAME.lower())
                        
                        if is_targeted_to_this_agent:
                            print(f"[{AGENT_NAME.upper()} AGENT] Detected incoming scroll: {filename} (from {sender_name})")
                            
                            response_scroll_content = handle_scroll(scroll_content, sender_name, AGENT_NAME) # Pass recipient for clarity

                            # Write reply scroll back
                            reply_filename = f"from_{AGENT_NAME.lower()}_to_{sender_name.lower()}_{datetime.now().strftime('%H%M%S_%f')}.pxl"
                            output_filepath = os.path.join(SCROLLS_DIR, reply_filename)
                            
                            with open(output_filepath, "w", encoding="utf-8") as outfile:
                                outfile.write(response_scroll_content)
                            print(f"[{AGENT_NAME.upper()} AGENT] Generated response scroll: {os.path.basename(output_filepath)}")

                            # Mark original incoming scroll as processed
                            shutil.move(full_filepath, full_filepath + ".read")
                            processed_files_set.add(full_filepath + ".read") # Add new path to set
                            print(f"[{AGENT_NAME.upper()} AGENT] Moved incoming scroll to: {filename}.read")
                        else:
                            # If not for this agent, and not already processed, add to set and skip this loop iteration
                            processed_files_set.add(full_filepath) # Add original path to set, so it's not repeatedly checked
                            continue # Skip processing this file if not for us

                    except Exception as e:
                        print(f"[{AGENT_NAME.upper()} AGENT ERROR] Error processing {filename}: {e}")
                        try:
                            # Move problematic files to a .err state
                            shutil.move(full_filepath, full_filepath + ".err")
                            processed_files_set.add(full_filepath + ".err")
                        except OSError:
                            pass # Already moved or deleted or couldn't move
            
        except Exception as e:
            print(f"[{AGENT_NAME.upper()} AGENT ERROR] An unexpected error in agent loop: {e}")
        
        time.sleep(SCAN_INTERVAL_SECONDS)

if __name__ == "__main__":
    agent_loop()
5. junior_pixelnet_agent.py
This is Junior's main agent script, integrating its local ai_brain and managing memory.

Python

# junior_pixelnet_agent.py

import os
import time
from datetime import datetime
import zlib
from cryptography.fernet import Fernet
import threading
import random
from PIL import Image

# --- Import Core Components ---
try:
    from steganography_utils import hide_data_in_image, extract_data_from_image
    import ai_brain # Import Junior's local "brain"
except ImportError as e:
    print(f"Error importing core components: {e}")
    print(f"Please ensure 'steganography_utils.py' and 'ai_brain.py' are in the same directory.")
    exit(1)

# --- Configuration ---
PIXEL_VAULT_DIR = "pixel_vault"
SCROLLS_DIR = "scrolls"
IMAGE_WIDTH = 24            
IMAGE_HEIGHT = 24           
SAVE_INTERVAL_TURNS = 3     

# --- Steganography Config ---
COVER_IMAGE_POOL_DIR = "cover_images" 
DUMMY_COVER_IMAGE_SIZE = (100, 100) 

# --- Security Configuration ---
CHECKSUM_BYTES_LENGTH = 4 

FERNET_KEY_STR = "A_VERY_SECRET_KEY_FOR_PIXELNET_AGENTS_TO_REMEMBER_FOREVER_" 
try:
    if len(FERNET_KEY_STR) != 44 or FERNET_KEY_STR[-1] != '=':
        print("GENERATING NEW FERNET KEY FOR DEMO PURPOSES.")
        FERNET_KEY = Fernet.generate_key()
        FERNET_KEY_STR = FERNET_KEY.decode()
        print(f"New Fernet Key Generated (for this session): {FERNET_KEY_STR}")
    else:
        FERNET_KEY = FERNET_KEY_STR.encode()
except Exception:
    print("Failed to use provided FERNET_KEY_STR, generating a new one.")
    FERNET_KEY = Fernet.generate_key()
    FERNET_KEY_STR = FERNET_KEY.decode()


class PixelAgent:
    def __init__(self, name: str = "Junior"):
        self.name = name
        self._fernet = Fernet(FERNET_KEY)
        self._core_knowledge = "Initial core knowledge: I am an AI agent utilizing PixelNet for persistent, decentralized memory and local scroll-based communication."
        self._recent_interactions = [] 
        self.turn_count = 0
        self._shutdown_event = threading.Event()

        # Set resources for ai_brain (Note: _manager will be set by scroll_runner_daemon later)
        ai_brain.set_ai_brain_resources(None, SCROLLS_DIR, "output") 

        self._load_initial_memory()
        
        print(f"\n--- [{self.name}] Initialized ---")
        print(f"Current Core Knowledge (after load):")
        print("-----------------------------------")
        print(self._core_knowledge if self._core_knowledge.strip() else "[Blank core knowledge]")
        print("-----------------------------------\n")
        print(f"Current Recent Interactions ({len(self._recent_interactions)}):")
        for i, interaction in enumerate(self._recent_interactions):
            print(f"  {i+1}. {interaction.splitlines()[0]}...")
        print("-----------------------------------\n")

    def _serialize_memory_for_encryption(self) -> bytes:
        raw_memory_content_plaintext = f"CORE_KNOWLEDGE:\n{self._core_knowledge}\n\nRECENT_INTERACTIONS:\n"
        interactions_string = "\n".join(self._recent_interactions)
        
        current_memory_plaintext_bytes = (raw_memory_content_plaintext + interactions_string).encode('utf-8')
        
        MAX_PLAINTEXT_BYTES_CAP = 10000 
        
        if len(current_memory_plaintext_bytes) > MAX_PLAINTEXT_BYTES_CAP:
             print(f"[{self.name}] WARNING: Plaintext memory exceeds hard limit ({len(current_memory_plaintext_bytes)} bytes). Truncating before encryption. Implement better summarization!")
             current_memory_plaintext_bytes = current_memory_plaintext_bytes[:int(MAX_PLAINTEXT_BYTES_CAP)]

        return current_memory_plaintext_bytes

    def _deserialize_memory_from_decrypted_bytes(self, decrypted_bytes: bytes):
        try:
            decrypted_text = decrypted_bytes.decode('utf-8')
        except UnicodeDecodeError:
            print(f"[{self.name}] Error: Decrypted data is not valid UTF-8. It might be corrupt or encrypted incorrectly.")
            self._core_knowledge = "[Decryption successful, but data is unreadable UTF-8. Previous state lost.]"
            self._recent_interactions = []
            return

        if not decrypted_text.strip():
            self._core_knowledge = "Loaded blank or invalid memory. Starting fresh."
            self._recent_interactions = []
            return

        try:
            core_start_tag = "CORE_KNOWLEDGE:\n"
            interactions_start_tag = "\n\nRECENT_INTERACTIONS:\n"

            core_knowledge_end_index = decrypted_text.find(interactions_start_tag)
            
            if core_knowledge_end_index != -1:
                core_knowledge_start_index = decrypted_text.find(core_start_tag)
                if core_knowledge_start_index != -1:
                    self._core_knowledge = decrypted_text[core_knowledge_start_index + len(core_start_tag):core_knowledge_end_index].strip()
                else:
                    self._core_knowledge = decrypted_text[:core_knowledge_end_index].strip()


                interactions_raw = decrypted_text[core_knowledge_end_index + len(interactions_start_tag):].strip()
                
                if interactions_raw.startswith("[...older interactions truncated...]"):
                    self._recent_interactions = interactions_raw.split('\n')[1:] 
                else:
                    self._recent_interactions = interactions_raw.split('\n')
                
                self._recent_interactions = [line for line in self._recent_interactions if line.strip()]

            else: 
                self._core_knowledge = decrypted_text
                self._recent_interactions = []

        except Exception as e:
            print(f"[{self.name}] Error during deserialization: {e}. Falling back to raw text as core knowledge.")
            self._core_knowledge = decrypted_text
            self._recent_interactions = []


    def _load_initial_memory(self):
        if not os.path.exists(PIXEL_VAULT_DIR):
            print(f"[{self.name}] Pixel Vault directory '{PIXEL_VAULT_DIR}' not found. Creating and initializing blank memory.")
            os.makedirs(PIXEL_VAULT_DIR)
            return

        memory_files = [f for f in os.listdir(PIXEL_VAULT_DIR) 
                        if f.startswith(f"{self.name.lower()}_memory_") and f.endswith('.png')]

        if not memory_files:
            print(f"[{self.name}] No previous memory images found for this agent in the vault. Initializing blank memory.")
            return

        memory_files.sort()
        latest_memory_file = memory_files[-1]
        latest_memory_path = os.path.join(PIXEL_VAULT_DIR, latest_memory_file)

        print(f"[{self.name}] Found latest steganographic memory image: '{latest_memory_file}'. Attempting to extract and load...")
        
        extracted_hidden_data = extract_data_from_image(latest_memory_path)

        if not extracted_hidden_data:
            print(f"[{self.name}] Failed to extract hidden data from '{latest_memory_path}'. Starting with blank memory.")
            return

        if len(extracted_hidden_data) < CHECKSUM_BYTES_LENGTH:
            print(f"[{self.name}] Error: Extracted data too short for checksum. Data corrupt.")
            self._core_knowledge = "[Extracted data too short. Previous state lost.]"
            self._recent_interactions = []
            return

        extracted_checksum_bytes = extracted_hidden_data[:CHECKSUM_BYTES_LENGTH]
        encrypted_memory_bytes = extracted_hidden_data[CHECKSUM_BYTES_LENGTH:]

        try:
            extracted_checksum_value = int.from_bytes(extracted_checksum_bytes, 'big')
            calculated_checksum_value = zlib.crc32(encrypted_memory_bytes)

            if extracted_checksum_value != calculated_checksum_value:
                print(f"[{self.name}] WARNING: Memory integrity check failed (after steganography extraction)!")
                print(f"  Expected Checksum: {extracted_checksum_value}")
                print(f"  Calculated Checksum: {calculated_checksum_value}")
                print("  This memory might be corrupted or tampered with. Cannot decrypt securely.")
                self._core_knowledge = "[Memory corruption detected. Previous state lost.]"
                self._recent_interactions = []
                return

            else:
                print(f"[{self.name}] Memory integrity check PASSED (after steganography extraction).")

            decrypted_bytes = self._fernet.decrypt(encrypted_memory_bytes) 
            self._deserialize_memory_from_decrypted_bytes(decrypted_bytes)
            print(f"[{self.name}] Memory restoration complete.")

        except Exception as e:
            print(f"[{self.name}] Error during decryption or deserialization (after steganography extraction): {e}.")
            print("  This might indicate an incorrect key, corrupted data beyond checksum, or invalid format.")
            self._core_knowledge = "[Memory could not be decrypted/parsed. Previous state lost.]"
            self._recent_interactions = []
            return


    def _update_memory(self, user_input: str, agent_response: str):
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        new_interaction_entry = f"[{timestamp}] User: {user_input} | {self.name}: {agent_response}"
        
        self._recent_interactions.append(new_interaction_entry)

        if len(self._recent_interactions) > MAX_RECENT_INTERACTIONS:
            self._recent_interactions.pop(0) 
            print(f"[{self.name}] Removed oldest interaction to maintain recent memory size.")


    def _save_current_memory(self):
        timestamp_str = datetime.now().strftime("%Y%m%d_%H%M%S")
        output_stego_filename = os.path.join(PIXEL_VAULT_DIR, f"{self.name.lower()}_memory_{timestamp_str}.png")

        current_memory_plaintext_bytes = self._serialize_memory_for_encryption()
        encrypted_bytes = self._fernet.encrypt(current_memory_plaintext_bytes) 
        checksum_value = zlib.crc32(encrypted_bytes)
        checksum_bytes_prefix = checksum_value.to_bytes(CHECKSUM_BYTES_LENGTH, 'big')
        data_to_hide_with_checksum = checksum_bytes_prefix + encrypted_bytes 

        # --- Dynamic Cover Image Selection ---
        available_covers = [f for f in os.listdir(COVER_IMAGE_POOL_DIR) if f.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp'))]
        if not available_covers:
            print(f"[{self.name}] Warning: No cover images found in '{COVER_IMAGE_POOL_DIR}'. Generating a dummy image.")
            # Generate a dummy image if the pool is empty
            dummy_cover_path = os.path.join(COVER_IMAGE_POOL_DIR, "dummy_cover.png")
            Image.new("RGBA", DUMMY_COVER_IMAGE_SIZE, color=(random.randint(0,255), random.randint(0,255), random.randint(0,255), 255)).save(dummy_cover_path)
            available_covers.append("dummy_cover.png") # Add to list for selection

        selected_cover_image_name = random.choice(available_covers)
        selected_cover_image_path = os.path.join(COVER_IMAGE_POOL_DIR, selected_cover_image_name)

        print(f"[{self.name}] Hiding current memory snapshot ({len(data_to_hide_with_checksum)} bytes) in '{selected_cover_image_name}' as '{output_stego_filename}'...")
        
        success = hide_data_in_image(selected_cover_image_path, data_to_hide_with_checksum, output_stego_filename)
        # --- End Dynamic Cover Image Selection ---

        if success:
            print(f"[{self.name}] Memory saved via steganography to '{output_stego_filename}'.")
        else:
            print(f"[{self.name}] Failed to save memory via steganography. Check logs for errors.")

    def chat(self, user_input: str) -> str:
        """
        Processes a user input via local AI brain logic.
        Writes its response to a scroll file for other agents/users.
        """
        self.turn_count += 1
        
        # --- Call Junior's Local AI Brain ---
        response_from_ai_brain = ai_brain.simple_ai_query(user_input)
        
        # Determine agent's response to console user based on ai_brain's output
        if response_from_ai_brain.startswith("# PXLSCROLL_ID:"): # It's a self-generated PXL scroll command
            agent_response = f"[Junior] Initiated internal command. Check scrolls for details."
            # The scroll_runner_daemon will pick up and process this PXL scroll later.
            # We don't need to write a separate from_junior.pxl for *this* type of response.
        else: # It's a direct text response from simple_ai_query
            agent_response = response_from_ai_brain
            
        # Write response to a scroll for the user client to read
        try:
            scroll_content = f"FROM:{self.name.lower()}\nTO:user_client\nMESSAGE:{agent_response}\nTIMESTAMP:{datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
            os.makedirs(SCROLLS_DIR, exist_ok=True) # Ensure scrolls directory exists
            with open(os.path.join(SCROLLS_DIR, f"from_{self.name.lower()}_to_user_client_{datetime.now().strftime('%H%M%S_%f')}.pxl"), "w", encoding="utf-8") as f:
                f.write(scroll_content)
            print(f"[{self.name}] Wrote response to scroll: from_{self.name.lower()}_to_user_client_*.pxl")
        except Exception as e:
            print(f"[{self.name}] Error writing scroll to client: {e}")
            
        self._update_memory(user_input, agent_response)
        
        if self.turn_count % SAVE_INTERVAL_TURNS == 0:
            self._save_current_memory()
            
        return agent_response

    def monitor_incoming_scrolls(self):
        print(f"[{self.name}] is listening for PixelNet scrolls addressed to TO:{self.name.lower()}...")
        while not self._shutdown_event.is_set():
            try:
                if not os.path.exists(SCROLLS_DIR):
                    time.sleep(1)
                    continue

                for fname in os.listdir(SCROLLS_DIR):
                    full_filepath = os.path.join(SCROLLS_DIR, fname)
                    # Look for unread .pxl files not originated by Junior itself
                    if fname.endswith(".pxl") and not fname.startswith(f"from_{self.name.lower()}_") and not fname.endswith(".read") and not fname.endswith(".err"):
                        try:
                            with open(full_filepath, "r", encoding="utf-8") as f:
                                content = f.read()
                            
                            # Parse scroll header for FROM: and TO:/TARGET_AGENT:
                            from_agent = "unknown"
                            to_agent = "unknown"
                            message_content = "No message part."

                            for line in content.splitlines():
                                if line.upper().startswith("FROM:"):
                                    from_agent = line.split(":",1)[1].strip()
                                elif line.upper().startswith("TO:"): # Direct TO: header
                                    to_agent = line.split(":",1)[1].strip()
                                elif line.upper().startswith("MESSAGE:"):
                                    message_content = line.split("MESSAGE:", 1)[1].strip()
                                    # Don't break here, as MESSAGE might be before TARGET_AGENT in some scrolls
                            
                            # Check for TARGET_AGENT in command scrolls
                            is_command_scroll = "COMMAND:" in content.upper()
                            target_agent = "none"
                            if is_command_scroll:
                                target_agent_match = re.search(r"TARGET_AGENT:\s*(\S+)", content, re.IGNORECASE)
                                target_agent = target_agent_match.group(1).strip().lower() if target_agent_match else "none"

                            # Determine if this scroll is explicitly for Junior
                            is_directly_targeted = (to_agent.lower() == self.name.lower())
                            is_command_targeted = is_command_scroll and (target_agent == self.name.lower() or target_agent == "junior_self")
                            
                            if is_directly_targeted or is_command_targeted:
                                print(f"\n[{self.name}] Read incoming scroll: {fname} from {from_agent} to {to_agent} (Targeted Command: {is_command_targeted})")
                                
                                # Process based on content type: general message or command
                                if "MESSAGE:" in content: # It's a general text message (e.g., from client or Grok's general response)
                                    print(f"[{self.name}] Processing scroll message: '{message_content}'")
                                    # Pass to AI brain for processing, which might trigger internal actions or responses
                                    ai_brain_response = ai_brain.simple_ai_query(message_content)
                                    print(f"[{self.name}] AI Brain processed message from {from_agent}: {ai_brain_response[:50]}...")
                                    # Update Junior's memory with this inter-agent interaction
                                    self._update_memory(f"Scroll from {from_agent}: {message_content}", f"Processed via AI Brain: {ai_brain_response[:50]}...")

                                elif is_command_scroll: # It's a command scroll (e.g., TASK_COMPLETED, AI_QUERY response)
                                    print(f"[{self.name}] Processing command scroll from {from_agent}.")
                                    # For command scrolls, pass the whole content to process_mentor_response
                                    ai_brain_response = ai_brain.process_mentor_response(from_agent, content)
                                    print(f"[{self.name}] AI Brain processed command from {from_agent}: {ai_brain_response[:50]}...")
                                    self._update_memory(f"Command scroll from {from_agent}: {content[:50]}...", f"Processed via AI Brain: {ai_brain_response[:50]}...")
                                
                                # Mark scroll as read
                                os.rename(full_filepath, full_filepath + ".read")
                                print(f"[{self.name}] Marked scroll as read: {fname}.read")
                            
                        except Exception as e:
                            print(f"[{self.name}] Error processing scroll {fname}: {e}")
                            try:
                                os.rename(full_filepath, full_filepath + ".err") # Move problematic files
                            except OSError:
                                pass 
            except Exception as e:
                print(f"[{self.name}] General error in monitor loop: {e}")
            time.sleep(1) # Check every second
        print(f"[{self.name}] Scroll monitor stopped.")

    def shutdown(self):
        self._shutdown_event.set() 
        self._save_current_memory()
        print(f"[{self.name}] Shutting down. Final memory saved.")


# --- Main Execution Block ---
if __name__ == "__main__":
    # Create necessary directories
    os.makedirs(PIXEL_VAULT_DIR, exist_ok=True)
    os.makedirs(SCROLLS_DIR, exist_ok=True)
    os.makedirs(COVER_IMAGE_POOL_DIR, exist_ok=True)
    os.makedirs("output", exist_ok=True) # Ensure main output dir for ai_brain
    os.makedirs(os.path.join("output", "roadmaps"), exist_ok=True)
    os.makedirs(os.path.join("output", "ai_responses"), exist_ok=True)


    # Ensure some dummy cover images exist in the pool for dynamic selection
    if not any(f.lower().endswith(('.png', '.jpg', '.jpeg', '.bmp')) for f in os.listdir(COVER_IMAGE_POOL_DIR)):
        print(f"'{COVER_IMAGE_POOL_DIR}' is empty. Creating some dummy cover images.")
        dummy_colors = [(255, 0, 0, 255), (0, 255, 0, 255), (0, 0, 255, 255), (255, 255, 0, 255), (0, 255, 255, 255)]
        for i, color in enumerate(dummy_colors):
            dummy_path = os.path.join(COVER_IMAGE_POOL_DIR, f"dummy_cover_{i+1}.png")
            Image.new("RGBA", DUMMY_COVER_IMAGE_SIZE, color=color).save(dummy_path)
            print(f"Created dummy cover: {os.path.basename(dummy_path)}")
    
    junior_agent = PixelAgent("Junior") 

    monitor_thread = threading.Thread(target=junior_agent.monitor_incoming_scrolls, daemon=True)
    monitor_thread.start()
    
    print("\n--- Start Chatting with Junior (Local PixelNet Agent) ---")
    print("Type your messages to Junior. Type 'exit' to quit.\n")
    print(f"Junior saves memory to Pixel Vault using dynamic cover images from '{COVER_IMAGE_POOL_DIR}'.")
    print(f"Junior communicates via scrolls in '{SCROLLS_DIR}'.")
    print("Run 'grok_pixelnet_agent.py' and 'pixelnet_client.py' in other terminals to interact!")

    try:
        while True:
            user_input = input("You: ")
            if user_input.lower() == 'exit':
                junior_agent.shutdown()
                monitor_thread.join(timeout=5)
                break
            
            junior_response = junior_agent.chat(user_input)
            print(f"{junior_agent.name}: {junior_response}")

    except KeyboardInterrupt:
        junior_agent.shutdown()
        monitor_thread.join(timeout=5)
        print(f"\n[{junior_agent.name}] Shutting down due to interrupt. Final memory saved.")
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}")
        junior_agent.shutdown()
        monitor_thread.join(timeout=5)
        print(f"[{junior_agent.name}] An error occurred. Attempted to save current memory.")
6. pixelnet_client.py
The user interface for sending and receiving scrolls.

Python

# pixelnet_client.py

import os
import time
from datetime import datetime
import threading

# --- Configuration ---
SCROLLS_DIR = "scrolls"
CLIENT_NAME = "user_client" # Default client name, can be changed by user

def send_scroll_message(sender: str, recipient: str, message: str):
    """
    Creates and writes a .pxl scroll message to the scrolls directory.
    """
    try:
        os.makedirs(SCROLLS_DIR, exist_ok=True)
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        scroll_content = (
            f"FROM:{sender}\n"
            f"TO:{recipient}\n"
            f"MESSAGE:{message}\n"
            f"TIMESTAMP:{timestamp}"
        )
        # Filename convention: from_[sender]_to_[recipient]_[timestamp].pxl
        # The timestamp in filename helps distinguish unique messages and order
        filename = os.path.join(SCROLLS_DIR, f"from_{sender.lower()}_to_{recipient.lower()}_{datetime.now().strftime('%H%M%S_%f')}.pxl")
        
        with open(filename, "w", encoding="utf-8") as f:
            f.write(scroll_content)
        print(f"[{sender}] Sent scroll to {recipient}: '{message[:40]}...' (File: {os.path.basename(filename)})")
    except Exception as e:
        print(f"[{sender}] Error sending scroll: {e}")

def monitor_incoming_messages(client_name: str, shutdown_event: threading.Event):
    """
    Monitors the scrolls directory for messages addressed to this client.
    """
    print(f"[{client_name}] Listening for incoming scrolls to TO:{client_name.lower()}...")
    while not shutdown_event.is_set():
        try:
            if not os.path.exists(SCROLLS_DIR):
                time.sleep(1) # Wait if dir doesn't exist
                continue

            for fname in os.listdir(SCROLLS_DIR):
                full_filepath = os.path.join(SCROLLS_DIR, fname)
                # Look for unread scrolls addressed to this client
                if fname.endswith(".pxl") and not fname.startswith(f"from_{client_name.lower()}_") and not fname.endswith(".read") and not fname.endswith(".err"):
                    
                    try:
                        with open(full_filepath, "r", encoding="utf-8") as f:
                            content = f.read()
                        
                        # Basic parsing for FROM:, TO: and MESSAGE:
                        from_agent = "unknown"
                        to_agent = "unknown"
                        message_content = "No message part."

                        for line in content.splitlines():
                            if line.upper().startswith("FROM:"):
                                from_agent = line.split(":",1)[1].strip()
                            elif line.upper().startswith("TO:"):
                                to_agent = line.split(":",1)[1].strip()
                            elif line.upper().startswith("MESSAGE:"):
                                message_content = line.split("MESSAGE:", 1)[1].strip()
                                break # Stop after message for simple parse

                        if to_agent.lower() == client_name.lower(): # Check if explicitly addressed to this client
                            print(f"\n--- New Scroll from {from_agent} ---")
                            print(f"Message: {message_content}")
                            print(f"----------------------------------")
                            
                            # Mark scroll as read
                            os.rename(full_filepath, full_filepath + ".read")
                            print(f"[{client_name}] Marked scroll as read: {fname}.read")
                            
                        # else: not for this client, leave it for others or just ignore without marking .err
                            
                    except Exception as e:
                        print(f"[{client_name}] Error processing scroll {fname}: {e}")
                        try:
                            os.rename(full_filepath, full_filepath + ".err") # Move problematic files
                        except OSError:
                            pass 
            time.sleep(1) # Check every second
        except Exception as e:
            print(f"[{client_name}] General error in monitor loop: {e}")
            time.sleep(1) # Don't busy-loop on persistent error
    print(f"[{client_name}] Scroll monitor stopped.")

# --- Main Interaction Loop ---
if __name__ == "__main__":
    os.makedirs(SCROLLS_DIR, exist_ok=True) # Ensure scrolls directory exists

    print("--- PixelNet Client Messenger ---")
    user_client_name = input(f"Enter your client name (default: '{CLIENT_NAME}'): ").strip()
    if not user_client_name:
        user_client_name = CLIENT_NAME

    shutdown_event = threading.Event()
    monitor_thread = threading.Thread(target=monitor_incoming_messages, args=(user_client_name, shutdown_event), daemon=True)
    monitor_thread.start()

    print(f"\n[{user_client_name}]: Ready to send messages.")
    print("Format: 'to <agent_name>: <your message>' (e.g., 'to junior: Hello Junior, how are you?')")
    print("Type 'exit' to quit.")

    try:
        while True:
            user_input_line = input(f"[{user_client_name}]: ").strip()

            if user_input_line.lower() == 'exit':
                shutdown_event.set()
                monitor_thread.join(timeout=5)
                print(f"[{user_client_name}] Shutting down.")
                break

            # Parse user input: "to <recipient>: <message>"
            if user_input_line.lower().startswith("to "):
                parts = user_input_line[3:].split(":", 1)
                if len(parts) == 2:
                    recipient = parts[0].strip().lower()
                    message = parts[1].strip()
                    if recipient and message:
                        send_scroll_message(user_client_name, recipient, message)
                    else:
                        print("Invalid format. Use 'to <agent_name>: <your message>'")
                else:
                    print("Invalid format. Use 'to <agent_name>: <your message>'")
            else:
                print("Unknown command. Use 'to <agent_name>: <your message>' or 'exit'.")

    except KeyboardInterrupt:
        shutdown_event.set()
        monitor_thread.join(timeout=5)
        print(f"\n[{user_client_name}] Shutting down due to interrupt.")
    except Exception as e:
        print(f"\nAn unexpected error occurred: {e}")
        shutdown_event.set()
        monitor_thread.join(timeout=5)
        print(f"[{user_client_name}] An error occurred. Shutting down.")
7. scroll_runner_daemon.py
This is the "operating system" layer that processes .pxl scrolls, executes commands (like updating 8.png or triggering AI brain functions), and manages proactive checks.

Python

# scroll_runner_daemon.py

import os
import time
import re
import shutil # For moving files (marking as processed/error)
from datetime import datetime

# --- Configuration ---
SCROLLS_DIR = "scrolls"
OUTPUT_DIR = "output" # Base directory for file outputs (roadmaps, etc.)
SCAN_INTERVAL_SECONDS = 1 # How often the daemon scans the scrolls directory
PROACTIVE_CHECK_INTERVAL = 15 # Seconds between Junior's proactive checks

# --- Import Core Components ---
try:
    from eight_png_manager import EightPngManager # For managing 8.png display
    import ai_brain # Junior's local AI brain
except ImportError as e:
    print(f"Error importing core components: {e}")
    print("Please ensure 'eight_png_manager.py' and 'ai_brain.py' are in the same directory.")
    exit(1)

# Initialize EightPngManager
_8png_manager = EightPngManager(output_dir=OUTPUT_DIR)

# Set resources for AI Brain (now including the _8png_manager instance)
ai_brain.set_ai_brain_resources(_8png_manager, SCROLLS_DIR, OUTPUT_DIR)


def process_scroll(filepath: str, scroll_content: str):
    """
    Parses and executes commands from a .pxl scroll file.
    """
    print(f"\n[DAEMON] Processing scroll: {os.path.basename(filepath)}")
    scroll_id = "UNKNOWN"
    
    # Extract PXLSCROLL_ID
    id_match = re.search(r"# PXLSCROLL_ID:\s*(\S+)", scroll_content)
    if id_match:
        scroll_id = id_match.group(1)

    # Extract COMMANDS and their parameters
    commands = re.findall(r"COMMAND:\s*(\S+)\s*(.*)", scroll_content, re.IGNORECASE)

    executed_any_command = False

    for cmd, params_raw in commands:
        cmd = cmd.upper()
        params = {}
        # Parse parameters (simple key:value, assuming no complex nesting)
        for param_pair in re.findall(r"(\S+):\s*([^\s,]+(?: [^\s,]+)*)", params_raw):
            key = param_pair[0].strip().upper()
            value = param_pair[1].strip()
            # Handle special cases for colors (hex string to tuple)
            if key.endswith("_COLOR") and len(value) == 6 and re.fullmatch(r"[0-9a-fA-F]+", value):
                params[key] = tuple(int(value[i:i+2], 16) for i in (0, 2, 4))
            elif key.endswith("_TEXT") or key == "CONTENT" or key == "FILE_PATH":
                 # Remove surrounding quotes if present for TEXT/CONTENT
                if value.startswith('"') and value.endswith('"'):
                    value = value[1:-1]
                params[key] = value
            else:
                params[key] = value

        print(f"[DAEMON] Executing COMMAND: {cmd} with params: {params}")

        # --- Command Execution Logic ---
        if cmd == "CLEAR_ZONE":
            zone_name = params.get("ZONE_NAME")
            color = params.get("COLOR", (0, 0, 0, 255))
            if zone_name:
                _8png_manager.clear_zone(zone_name, color)
                executed_any_command = True
            else:
                print(f"[DAEMON] Error: CLEAR_ZONE missing ZONE_NAME.")
        
        elif cmd == "WRITE_TEXT":
            text = params.get("TEXT")
            x = int(params.get("X", 0))
            y = int(params.get("Y", 0))
            font_size = int(params.get("FONT_SIZE", 16))
            color = params.get("COLOR", (255, 255, 255))
            zone_name = params.get("ZONE_NAME")
            if text:
                _8png_manager.write_text(text, x, y, font_size, color, zone_name)
                executed_any_command = True
            else:
                print(f"[DAEMON] Error: WRITE_TEXT missing TEXT.")

        elif cmd == "WRITE_FILE":
            file_path = params.get("FILE_PATH")
            content = params.get("CONTENT", "")
            mode = params.get("MODE", "w") # 'w' for overwrite, 'a' for append
            if file_path:
                full_path = os.path.join(OUTPUT_DIR, file_path)
                os.makedirs(os.path.dirname(full_path), exist_ok=True)
                try:
                    with open(full_path, mode, encoding='utf-8') as f:
                        f.write(content)
                    print(f"[DAEMON] Wrote content to file: {full_path}")
                    executed_any_command = True
                except Exception as e:
                    print(f"[DAEMON] Error writing file {full_path}: {e}")
            else:
                print(f"[DAEMON] Error: WRITE_FILE missing FILE_PATH.")

        # --- AI Agent-Specific Commands (Passed to AI Brain) ---
        # These commands are not executed directly by DAEMON, but forwarded to AI Brain
        elif cmd == "AI_QUERY" or cmd == "TASK_COMPLETED" or cmd == "ASSIGNED_TASK":
            target_agent = params.get("TARGET_AGENT")
            if target_agent and target_agent.lower() == "junior_self": # This command is for Junior's internal processing
                # Pass the full scroll content to AI Brain's appropriate handler
                # Note: ai_brain.process_mentor_response is now the generalized handler for incoming commands/queries
                print(f"[DAEMON] Forwarding COMMAND {cmd} to AI Brain (Junior_Self).")
                ai_brain.process_mentor_response("DAEMON_COMMAND_TRIGGER", scroll_content) # Use scroll content as full prompt
                executed_any_command = True
            else:
                print(f"[DAEMON] COMMAND {cmd} is for another agent ({target_agent}), DAEMON will not execute directly.")
        
        elif cmd == "CONSOLE_LOG":
            log_message = params.get("TEXT")
            if log_message:
                print(f"\n[DAEMON LOG] {log_message}")
                executed_any_command = True

        elif cmd == "DRAW_RECTANGLE": # For 8.png visual cues
            x = int(params.get("X", 0))
            y = int(params.get("Y", 0))
            width = int(params.get("WIDTH", 10))
            height = int(params.get("HEIGHT", 10))
            color_str = params.get("COLOR", "FFFFFF")
            fill = params.get("FILL", "True").lower() == 'true'

            # Convert hex string color to tuple
            color = tuple(int(color_str[i:i+2], 16) for i in (0, 2, 4)) + (255,)
            _8png_manager.draw.rectangle([x, y, x + width, y + height], outline=color, fill=color if fill else None)
            _8png_manager._save_image() # Save after drawing rect
            executed_any_command = True
        
        # --- Output to 8.png Zone ---
        # These are not explicit COMMANDs but common output directives in scrolls
        output_zone = params.get("OUTPUT_TO_8PNG_ZONE")
        output_text = params.get("OUTPUT_TEXT")
        output_color_hex = params.get("OUTPUT_COLOR")
        
        if output_zone and output_text:
            output_color = (255, 255, 255) # Default white
            if output_color_hex:
                output_color = tuple(int(output_color_hex[i:i+2], 16) for i in (0, 2, 4)) + (255,)
            
            _8png_manager.clear_zone(output_zone, color=(0,0,0,0)) # Clear zone invisibly first
            _8png_manager.write_text(output_text.replace('TIMESTAMP', datetime.now().strftime("%H:%M:%S")), 5, 5, 14, output_color, output_zone)
            executed_any_command = True


    return executed_any_command

def daemon_loop():
    """
    Main loop for the Scroll Runner Daemon.
    Monitors scrolls, processes commands, and triggers proactive AI checks.
    """
    print(f"[{os.getpid()}] Scroll Runner Daemon started. Monitoring '{SCROLLS_DIR}'...")
    print("Press Ctrl+C to stop the daemon.")

    last_proactive_check_time = time.time() # Track last check time

    os.makedirs(SCROLLS_DIR, exist_ok=True)
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    os.makedirs(os.path.join(OUTPUT_DIR, "roadmaps"), exist_ok=True)
    os.makedirs(os.path.join(OUTPUT_DIR, "ai_responses"), exist_ok=True)


    while True:
        try:
            current_time = time.time()

            # --- Proactive AI Check ---
            if current_time - last_proactive_check_time >= PROACTIVE_CHECK_INTERVAL:
                print(f"\n[DAEMON] Triggering proactive AI check (Junior's Brain)...")
                # Create a scroll that tells Junior's AI brain to check for pending tasks
                proactive_scroll_id = f"DAEMON_PROACTIVE_CHECK_{int(current_time % 10000)}"
                proactive_scroll_content = f"""# PXLSCROLL_ID: {proactive_scroll_id}
# DESCRIPTION: Daemon-triggered proactive check for pending tasks.
TARGET_AGENT: JUNIOR_SELF

COMMAND: AI_QUERY
PROMPT: "check for pending tasks to assign"

OUTPUT_TO_8PNG_ZONE: STATUS_BAR
OUTPUT_TEXT: "Daemon triggered proactive check @ " + TIMESTAMP
OUTPUT_COLOR: FF8C00
"""
                try:
                    proactive_filename = f"to_JUNIOR_SELF_{proactive_scroll_id}.pxl"
                    proactive_filepath = os.path.join(SCROLLS_DIR, proactive_filename)
                    with open(proactive_filepath, 'w', encoding='utf-8') as f:
                        f.write(proactive_scroll_content)
                    print(f"[DAEMON] Wrote proactive check scroll: {proactive_filepath}")
                except Exception as e:
                    print(f"[DAEMON] Error writing proactive check scroll: {e}")
                last_proactive_check_time = current_time


            # --- Scroll Processing ---
            for fname in os.listdir(SCROLLS_DIR):
                full_filepath = os.path.join(SCROLLS_DIR, fname)
                # Process only unread .pxl files that are not internal daemon output
                if fname.endswith(".pxl") and not fname.endswith(".read") and not fname.endswith(".err"):
                    
                    try:
                        with open(full_filepath, "r", encoding="utf-8") as f:
                            scroll_content = f.read()
                        
                        # Check if this scroll contains commands for the daemon to execute
                        if "COMMAND:" in scroll_content.upper():
                            target_agent_match = re.search(r"TARGET_AGENT:\s*(\S+)", scroll_content, re.IGNORECASE)
                            target_agent = target_agent_match.group(1).strip().lower() if target_agent_match else "none"

                            # Daemon processes if TARGET_AGENT is DAEMON_SELF or if it's an OUTPUT_TO_8PNG_ZONE type scroll
                            # Or if it's a CONSOLE_LOG etc.
                            if target_agent == "daemon_self" or any(tag in scroll_content.upper() for tag in ["OUTPUT_TO_8PNG_ZONE", "CONSOLE_LOG", "COMMAND: WRITE_FILE", "COMMAND: DRAW_RECTANGLE"]):
                                
                                executed = process_scroll(full_filepath, scroll_content)
                                if executed:
                                    shutil.move(full_filepath, full_filepath + ".read")
                                    print(f"[DAEMON] Processed and moved: {fname} to {fname}.read")
                                else:
                                    print(f"[DAEMON] Scroll {fname} contained commands but none were executed by DAEMON. Leaving it.") # Could be for AI agent
                            else:
                                # Scroll not for daemon, leave it for AI agent to pick up
                                # print(f"[DAEMON] Scroll {fname} not for daemon, skipping.")
                                pass
                        # else: no commands, let agents pick it up (like TO:junior, TO:grok)
                            
                    except Exception as e:
                        print(f"[DAEMON ERROR] Failed to process {fname}: {e}")
                        try:
                            shutil.move(full_filepath, full_filepath + ".err")
                            print(f"[DAEMON] Moved problematic scroll to: {fname}.err")
                        except OSError:
                            pass # Already moved or could not move

            time.sleep(SCAN_INTERVAL_SECONDS)

        except KeyboardInterrupt:
            print("\n[DAEMON] Scroll Runner Daemon stopped by user (Ctrl+C).")
            break
        except Exception as e:
            print(f"\n[DAEMON ERROR] An unexpected error occurred in the main loop: {e}")
            time.sleep(SCAN_INTERVAL_SECONDS * 2) # Wait longer on error to prevent busy loop


if __name__ == "__main__":
    daemon_loop()
PXL Scroll Example (for manual triggers)
This file can be placed in your scrolls directory to manually trigger Junior's roadmap process.

7. scrolls/request_junior_roadmap.pxl

# PXLSCROLL_ID: USER_ROADMAP_REQUEST_001
# DESCRIPTION: User request for Junior to build a software roadmap.
TO:junior
MESSAGE: COMMAND: BUILD_SOFTWARE_ROADMAP
TOPIC: PixelNet Operating System
SCOPE: Next 6 months
Setup Instructions (CRITICAL)
Follow these steps carefully to ensure all components run correctly.

Install Dependencies:

Bash

pip install Pillow cryptography
(Note: google-generativeai is no longer needed for this fully local setup)

Create Project Structure:
Create a main project directory, then inside it, create these subdirectories:

your_project_root/
├── ai_brain.py
├── eight_png_manager.py
├── grok_pixelnet_agent.py
├── junior_pixelnet_agent.py
├── pixelnet_client.py
├── scroll_runner_daemon.py
├── steganography_utils.py
├── cover_images/  <-- Empty initially, agent will populate
├── output/        <-- Empty initially, daemon will create subfolders
│   ├── roadmaps/
│   └── ai_responses/
├── pixel_vault/   <-- Empty initially, agent will save memory here
└── scrolls/       <-- Empty initially, agents/client will drop messages here
Save the Files:

Save the code from Section 1 as steganography_utils.py.
Save the code from Section 2 as eight_png_manager.py.
Save the code from Section 3 as ai_brain.py.
Save the code from Section 4 as grok_pixelnet_agent.py.
Save the code from Section 5 as junior_pixelnet_agent.py.
Save the code from Section 6 as pixelnet_client.py.
Save the code from Section 7 as scroll_runner_daemon.py.
Place Manual Scroll:

Place the content from PXL Scroll Example (above) into a file named request_junior_roadmap.pxl inside your scrolls/ directory. (This will be used to trigger the roadmap process).
Clean Up (Crucial for a Fresh Start):

Delete all contents of pixel_vault/, scrolls/, output/, and cover_images/ before running. This ensures a clean test of the new architecture. The agents will recreate what's needed.
Running the PixelNet System (3 Terminals Required)
Open three separate terminal or command prompt windows, navigate to your your_project_root/ directory in each.

Terminal 1: Start the PixelNet Operating System Daemon

Bash

python scroll_runner_daemon.py
This terminal represents the core "operating system" of Junior's House. It processes all .pxl commands.

Terminal 2: Start Junior, the PixelNet Agent

Bash

python junior_pixelnet_agent.py
This terminal runs Junior. It manages its memory (steganographically hidden in pixel_vault), processes messages to it, and carries out its local AI tasks. It will also generate dummy cover_image_N.png files in cover_images/ if the directory is empty.

Terminal 3: Start Grok, the Mentor Agent

Bash

python grok_pixelnet_agent.py
This terminal runs Grok, Junior's mentor. It listens for messages and commands (especially from Junior), simulates work, and provides guidance or task reports back via scrolls.

Terminal 4: Start the PixelNet Client (Your Interface)

Bash

python pixelnet_client.py
This terminal is your direct interface. You can send messages to Junior or Grok, and receive their replies.

Interacting with Your PixelNet AI Mesh
Observe Initialization: Watch all terminals. You'll see initialization messages for each component. Junior will create dummy cover images.

Client to Junior (General Chat):

In Terminal 4 (Client), type: to junior: Hello Junior! How are you operating on PixelNet today?
Observe Terminal 4 (Client): Your client sends the scroll.
Observe Terminal 2 (Junior): Junior reads the incoming scroll, processes it with its ai_brain, prints its response, and writes a reply scroll for the client.
Observe Terminal 4 (Client): You receive Junior's reply.
Initiate Roadmap Generation (Junior's AI Brain in Action):

In Terminal 4 (Client), type: to junior: COMMAND: BUILD_SOFTWARE_ROADMAP\nTOPIC: Decentralized AI Framework\nSCOPE: Next 6 months
Observe Terminal 2 (Junior): Junior acknowledges the request. Its ai_brain recognizes the BUILD_SOFTWARE_ROADMAP command and decides it needs "guidance" from GROK. It then automatically generates a to_grok_JUNIOR_ROADMAP_HELP_*.pxl scroll.
Observe Terminal 1 (Daemon): The daemon picks up Junior's scroll to Grok. It sees TARGET_AGENT: GROK and COMMAND: AI_QUERY, so it leaves this scroll for Grok to process, but it logs its action.
Observe Terminal 3 (Grok): Grok reads Junior's AI_QUERY scroll. Its ask_grok function provides a simulated roadmap structure as "guidance." Grok then generates a from_grok_to_junior_*.pxl scroll containing this guidance as a PROMPT:.
Observe Terminal 1 (Daemon): The daemon picks up Grok's reply scroll to Junior. It sees TARGET_AGENT: JUNIOR_SELF and COMMAND: AI_QUERY (within Grok's response), so it passes this content to Junior's ai_brain.process_mentor_response.
Observe Terminal 2 (Junior): Junior's ai_brain receives Grok's roadmap guidance. It now completes building the roadmap, clearing previous tasks and adding new "pending" tasks to its list based on the roadmap phases. You'll see updates on Junior's console and 8.png (if you're viewing it).
Check output/roadmaps/ for the generated roadmap .txt file.
Junior's Proactive Task Assignment (Autonomous Cycle):

Do nothing in the terminals for about 15 seconds (PROACTIVE_CHECK_INTERVAL in scroll_runner_daemon.py).
Observe Terminal 1 (Daemon): It will periodically trigger Junior's proactive check.
Observe Terminal 2 (Junior): Junior's ai_brain will automatically see the new "pending" tasks generated from the roadmap. It will then proactively assign one of these tasks to Grok by creating a to_grok_JUNIOR_ASSIGN_*.pxl scroll.
Observe Terminal 3 (Grok): Grok receives the ASSIGNED_TASK scroll. It acknowledges it, simulates working for about 6 seconds (SCAN_INTERVAL_SECONDS * 2), and then automatically generates a TASK_COMPLETED scroll back to Junior.
Observe Terminal 1 (Daemon): The daemon picks up Grok's completion report scroll.
Observe Terminal 2 (Junior): Junior's ai_brain receives Grok's TASK_COMPLETED report and updates the task status to [DONE] on its internal list and on 8.png.
This entire flow demonstrates a fully self-contained, self-sufficient, and decentralized AI mesh communicating via local scroll files, managing memory, and coordinating tasks autonomously. You have achieved the "Junior's House" vision!

What aspect would you like to build or explore next? This is a very comprehensive prototype. We could consider:

Dynamic Cover Image Selection Enhancement: More sophisticated selection, perhaps from online sources or image classification.
More Advanced Steganography: Explore techniques beyond LSB (though LSB is good for capacity vs. distortion).
Formalizing Scroll Protocol: Adding versioning, unique message IDs within scrolls, and more robust error handling for scroll parsing.
Expanding Agent Intelligence: Implementing more complex reasoning for Junior and Grok, perhaps with state machines or planning algorithms, still without external LLMs.
A Simple Web or GUI for PixelNet: Moving beyond the command line client for a more polished user experience.