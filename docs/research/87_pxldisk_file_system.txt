PXLDISK File System - Version 1.0üöÄ IntroductionPXLDISK is an innovative, scroll-based file system designed for the PixelNet environment. It conceptualizes a file system directly within image formats, where each 256x256 pixel PNG acts as a "disk chunk" (PXLDISK_000.png, PXLDISK_001.png, etc.). Each pixel (specifically, its Red channel value) can represent a byte of data, allowing for in-pixel data storage and retrieval. This project aims to provide a foundational, embedded file system for highly constrained or unique digital environments.‚ú® Features (Version 1.0)PXLDISK v1.0 implements all phases of the original roadmap, providing a functional demonstration of its core capabilities:Core File System Operations:initDisk(canvas): Initializes or formats a disk chunk.listFiles(): Lists all active files on the current disk.writeFile(name, data): Writes new files or updates existing ones.readFile(name): Reads and displays the content of a file.deleteFile(name): Marks file entries as deleted and zeroes out content areas.User Interface (UI): A web-based GUI (pixelnet_mesh_gl.html) provides intuitive controls for file operations.Multi-Disk Chunk Concept:Allows selection and conceptual "loading" of different PXLDISK_XXX.png chunks.Simulates behavior for files that would span across multiple disk chunks (logging a warning if content exceeds single-disk capacity).PixelNet Workflow Integration:Dedicated buttons for common AI tasks: storing tasks.txt, writing responses.log, and saving junior.cfg.Basic Security & Error Handling:Prevents filename collisions for new files.Validates block limits before writing, providing warnings for insufficient space or oversized files.Includes a simple checksum for each row of file content, verified during reads to detect potential corruption.Command Line Interface (CLI): An integrated CLI console allows text-based interaction with the file system.Disk Export: The ability to download the current canvas state as a PNG image (PXLDISK_XXX.png), effectively "saving" the disk chunk.üõ†Ô∏è PXLDISK Structure OverviewA PXLDISK chunk (e.g., 8.png, PXLDISK_000.png) is a 256x256 pixel image:Row 0 (Metadata): Contains the "PXLDISKv" magic header, version, next available row pointer, total bytes used, total bytes available, and a simulated superblock pointer.Rows 1-8 (Directory): Stores file entries. Each entry is a fixed 32-byte block, containing filename, start row, length in bytes, and a status flag (active, empty, deleted).Rows 9-255 (Content Area): This is where actual file data is stored. Each content row allocates 255 bytes for data and 1 byte for a row-specific checksum (XOR sum of its content bytes).üöÄ How to UseOpen the HTML File: Simply open the pixelnet_mesh_gl.html file in a web browser.Initialization: The system will automatically initialize the PXLDISK_000 chunk. If it's a fresh load (no existing magic header detected), it will format the disk. You'll be prompted to write the roadmap.txt file automatically.UI Interaction:Filename Input: Enter the desired filename (max 16 characters).File Content Area: Type or paste the content for your file.Buttons:Write File: Creates a new file or updates an existing one (if space permits or it's an overwrite).Read File: Displays the content of the specified file in the Output Log.Delete File: Marks the specified file as deleted and clears its content pixels.List Files: Displays a list of all active files on the current disk in the Output Log.Multi-Disk Management:Use the Select Disk Chunk dropdown to choose a different disk ID (e.g., PXLDISK_001).Click Load Selected Disk to switch to that disk. Note: For this version, switching disks will format the new disk as a fresh, empty chunk.PixelNet Workflows:Use the dedicated buttons to quickly Store tasks.txt, Write responses.log, or Save junior.cfg with predefined content.CLI Console:Type commands into the CLI Command input field and press Enter or click Run.Examples:listread roadmap.txtwrite my_notes "This is a secret message." (Note the quotes for content with spaces)delete my_noteshelpDownload Disk: Click Download Disk to save the current state of the active disk chunk as a PNG image (PXLDISK_XXX.png) to your local machine.üöß Known Limitations & Future Improvements (Version 2.0 and Beyond)While PXLDISK v1.0 establishes the core, it has a few areas for significant improvement in future versions:True Disk Loading: Currently, loading a disk chunk just formats a new canvas. A future version would allow actually loading a previously saved PXLDISK_XXX.png file back into the canvas.Seamless Multi-Chunk Spanning: Full implementation of files spanning multiple PXLDISK_XXX.png images, requiring a more complex directory structure and data retrieval logic.Advanced Storage Management: Features like a free space bitmap or defragmentation would optimize disk space usage and prevent fragmentation.Stronger Security: Implementing more robust checksums (e.g., CRC32), encryption, or access control.Performance: Optimizing pixel encoding (e.g., packing 3 bytes per RGB pixel) and adding data compression.Hierarchical Directories: Introducing folders for better organization.We're excited about the potential of PXLDISK and look forward to iterating on it!











/**
 * pxldisk_fs.js
 * Core File System Module for PixelNet (PXLDISK)
 *
 * This module provides basic file operations (read, write, delete, list, update)
 * by manipulating pixel data within an HTML Canvas element, representing a
 * 256x256 pixel 'disk chunk' (e.g., 8.png as PXLDISK_000).
 *
 * PXLDISK Structure:
 * - Image Size: 256x256 pixels
 * - Pixel Format: 1 byte per pixel (grayscale 0-255)
 * - Row 0: Magic Header and Disk Metadata
 * - Bytes 0-7: "PXLDISKv" (Magic Header)
 * - Bytes 8-11: Version (e.g., 0x0101 for v1.1)
 * - Bytes 12-15: Next Available Row Pointer (NAR)
 * - Bytes 16-19: Total Bytes Used
 * - Bytes 20-23: Total Bytes Available
 * - Remaining bytes in Row 0: Reserved for future global metadata (e.g., disk chaining info)
 * - Rows 1-8: Directory (8 rows * 256 bytes/row = 2048 bytes total)
 * - Each file entry in the directory will be a fixed size (e.g., 32 bytes).
 * - Format per entry (example - needs refinement based on actual pixel packing):
 * - Bytes 0-15: Filename (padded with nulls)
 * - Bytes 16-19: Start Row
 * - Bytes 20-23: Length in Pixels (bytes)
 * - Byte 24: Status (0=empty, 1=active, 2=deleted)
 * - Remaining bytes: Reserved for checksums, timestamps, permissions, etc.
 * - Rows 9-255: Content Area (247 rows * 256 bytes/row = 63232 bytes total)
 * - This is where the actual file data is stored, one byte per pixel.
 * - Max file size (single disk): 63232 bytes / 256 bytes per row = 247 rows.
 *
 * NOTE: For simplicity, this initial version assumes a 1-byte-per-pixel (grayscale)
 * encoding where each pixel's R, G, B, and A channels are the same value.
 * In a real scenario, you'd likely optimize storage (e.g., pack 3-4 bytes per pixel's RGBA).
 */

// --- Constants ---
const DISK_WIDTH = 256;
const DISK_HEIGHT = 256;
const BYTES_PER_ROW = DISK_WIDTH; // Assuming 1 byte per pixel for simplicity
const TOTAL_DATA_ROWS = DISK_HEIGHT - 9; // Rows 9 to 255 for content
const MAX_CONTENT_BYTES = TOTAL_DATA_ROWS * BYTES_PER_ROW;

const MAGIC_HEADER = "PXLDISKv";
const CURRENT_VERSION = 0x0101; // Version 1.1

// Directory Structure
const DIR_START_ROW = 1;
const DIR_END_ROW = 8;
const NUM_DIR_ROWS = DIR_END_ROW - DIR_START_ROW + 1;
const BYTES_PER_DIR_ENTRY = 32; // Example: 16-byte name, 4-byte start, 4-byte length, 1-byte status, 7-byte padding
const MAX_FILES = (NUM_DIR_ROWS * BYTES_PER_ROW) / BYTES_PER_DIR_ENTRY;

// Directory Entry Offsets within a 32-byte block
const FILENAME_OFFSET = 0;
const FILENAME_LENGTH = 16;
const START_ROW_OFFSET = 16;
const LENGTH_OFFSET = 20;
const STATUS_OFFSET = 24; // 0=empty, 1=active, 2=deleted

// --- Global State (simulated Canvas and ImageData) ---
let pxldiskCanvas = null;
let pxldiskCtx = null;
let pxldiskImageData = null; // Uint8ClampedArray representing R,G,B,A for each pixel

// Disk Metadata
let nextAvailableRow = 9; // Content starts at row 9
let totalBytesUsed = 0;

/**
 * Helper: Converts a string to a byte array (padded or truncated).
 * @param {string} str The string to convert.
 * @param {number} length The desired length of the byte array.
 * @returns {Uint8Array} The byte array.
 */
function stringToBytes(str, length) {
    const bytes = new Uint8Array(length).fill(0); // Pad with nulls
    for (let i = 0; i < str.length && i < length; i++) {
        bytes[i] = str.charCodeAt(i);
    }
    return bytes;
}

/**
 * Helper: Converts a byte array to a string (stops at null terminator).
 * @param {Uint8Array} bytes The byte array to convert.
 * @returns {string} The converted string.
 */
function bytesToString(bytes) {
    let str = '';
    for (let i = 0; i < bytes.length; i++) {
        if (bytes[i] === 0) break; // Null terminator
        str += String.fromCharCode(bytes[i]);
    }
    return str;
}

/**
 * Helper: Reads a 4-byte integer from a specific offset in the ImageData array.
 * @param {Uint8ClampedArray} data The imageData.data array.
 * @param {number} offset The byte offset (where R channel of pixel starts).
 * @returns {number} The 4-byte integer.
 */
function readInt32(data, offset) {
    // Assuming 1 byte per pixel means RGBA channels are same.
    // So, data[offset] is the first byte, data[offset+4] is second, etc.
    // This needs careful consideration if '1 byte per pixel' means actual grayscale.
    // For now, let's assume `data` directly represents raw bytes, not RGBA.
    // If it's a true ImageData.data, then offset needs to be * 4.
    // Let's adjust to assume we're working with a logical 1-byte-per-pixel array internally.
    const effectiveOffset = offset * 4; // If `data` is ImageData.data (RGBA)

    // Example for reading a 4-byte integer from 4 consecutive pixels (R channel)
    // If the image is truly grayscale, R, G, B, A are identical.
    // We'll read the R channel of 4 consecutive pixels.
    // If PXLDISK is truly 1 byte/pixel, we'd use a different low-level array.
    // For now, let's assume we read 4 bytes for an int.
    // This is a placeholder and would need a proper byte packing/unpacking strategy.

    // This is a common way to read 4 bytes as a 32-bit integer (little-endian)
    return (data[effectiveOffset] |
           (data[effectiveOffset + 1] << 8) |
           (data[effectiveOffset + 2] << 16) |
           (data[effectiveOffset + 3] << 24)) >>> 0; // >>> 0 converts to unsigned
}

/**
 * Helper: Writes a 4-byte integer to a specific offset in the ImageData array.
 * @param {Uint8ClampedArray} data The imageData.data array.
 * @param {number} offset The byte offset (where R channel of pixel starts).
 * @param {number} value The integer value.
 */
function writeInt32(data, offset, value) {
    const effectiveOffset = offset * 4; // If `data` is ImageData.data (RGBA)
    data[effectiveOffset] = value & 0xFF;
    data[effectiveOffset + 1] = (value >> 8) & 0xFF;
    data[effectiveOffset + 2] = (value >> 16) & 0xFF;
    data[effectiveOffset + 3] = (value >> 24) & 0xFF;

    // Assuming grayscale, set G, B, A to the same value
    for (let i = 0; i < 4; i++) {
        data[effectiveOffset + i * 4] = data[effectiveOffset + i];     // R
        data[effectiveOffset + i * 4 + 1] = data[effectiveOffset + i]; // G
        data[effectiveOffset + i * 4 + 2] = data[effectiveOffset + i]; // B
        data[effectiveOffset + i * 4 + 3] = 255;                       // A
    }
}


/**
 * Initializes the PXLDISK file system from a given HTML Canvas element.
 * Loads the image data, validates the magic header, and reads disk metadata.
 * If the header is invalid, it formats the disk.
 * @param {HTMLCanvasElement} canvas The canvas element representing the disk.
 */
async function initDisk(canvas) {
    console.log('Initializing PXLDISK...');
    pxldiskCanvas = canvas;
    pxldiskCtx = canvas.getContext('2d', { willReadFrequently: true });

    // Ensure canvas dimensions match PXLDISK spec
    if (pxldiskCanvas.width !== DISK_WIDTH || pxldiskCanvas.height !== DISK_HEIGHT) {
        console.warn(`Canvas dimensions (${pxldiskCanvas.width}x${pxldiskCanvas.height}) do not match PXLDISK spec (${DISK_WIDTH}x${DISK_HEIGHT}). Resizing canvas.`);
        pxldiskCanvas.width = DISK_WIDTH;
        pxldiskCanvas.height = DISK_HEIGHT;
    }

    // Get current image data from canvas
    pxldiskImageData = pxldiskCtx.getImageData(0, 0, DISK_WIDTH, DISK_HEIGHT);
    const data = pxldiskImageData.data; // This is a Uint8ClampedArray (R,G,B,A, R,G,B,A, ...)

    // Read Magic Header (first 8 pixels' Red channel)
    let header = '';
    for (let i = 0; i < MAGIC_HEADER.length; i++) {
        header += String.fromCharCode(data[i * 4]); // Read R channel
    }

    console.log(`Read header: '${header}'`);

    if (header === MAGIC_HEADER) {
        console.log('PXLDISK magic header found. Reading existing disk.');
        // Read version, next available row, and byte counts
        const version = readInt32(data, 8); // Offset 8 for version
        nextAvailableRow = readInt32(data, 12); // Offset 12 for NAR
        totalBytesUsed = readInt32(data, 16); // Offset 16 for bytes used

        console.log(`PXLDISK Version: ${version.toString(16)}`);
        console.log(`Next Available Row (NAR): ${nextAvailableRow}`);
        console.log(`Total Bytes Used: ${totalBytesUsed}`);

        // Basic validation: NAR should be within content rows
        if (nextAvailableRow < DIR_END_ROW + 1 || nextAvailableRow >= DISK_HEIGHT) {
            console.warn('Invalid Next Available Row pointer. Reformatting disk.');
            await formatDisk();
        }
    } else {
        console.log('PXLDISK magic header not found or invalid. Formatting disk.');
        await formatDisk();
    }
    console.log('PXLDISK initialization complete.');
}

/**
 * Formats the PXLDISK, writing the magic header and clearing directory/content areas.
 * This is a destructive operation.
 */
async function formatDisk() {
    console.log('Formatting PXLDISK...');
    const data = pxldiskImageData.data;

    // Clear all pixels (set to 0 - black)
    for (let i = 0; i < data.length; i += 4) {
        data[i] = 0;     // R
        data[i + 1] = 0; // G
        data[i + 2] = 0; // B
        data[i + 3] = 255; // A (fully opaque)
    }

    // Write Magic Header
    for (let i = 0; i < MAGIC_HEADER.length; i++) {
        const byteValue = MAGIC_HEADER.charCodeAt(i);
        data[i * 4] = byteValue;
        data[i * 4 + 1] = byteValue;
        data[i * 4 + 2] = byteValue;
    }

    // Write Version
    writeInt32(data, 8, CURRENT_VERSION);

    // Initialize metadata
    nextAvailableRow = DIR_END_ROW + 1; // Content starts after directory
    totalBytesUsed = 0;
    writeInt32(data, 12, nextAvailableRow);
    writeInt32(data, 16, totalBytesUsed);
    writeInt32(data, 20, MAX_CONTENT_BYTES); // Total bytes available

    // Update canvas with new image data
    pxldiskCtx.putImageData(pxldiskImageData, 0, 0);
    console.log('PXLDISK formatted successfully.');
}

/**
 * Finds an empty directory entry or an existing file entry by name.
 * @param {string} filename The name of the file to find.
 * @returns {{index: number, entryData: Uint8ClampedArray}|null} An object with the index and entry data if found, null otherwise.
 */
async function findDirectoryEntry(filename) {
    const data = pxldiskImageData.data;

    for (let i = 0; i < MAX_FILES; i++) {
        const dirEntryStartPixel = (DIR_START_ROW * BYTES_PER_ROW * 4) + (i * BYTES_PER_DIR_ENTRY * 4);
        const entryNameBytes = new Uint8ClampedArray(FILENAME_LENGTH);
        for (let j = 0; j < FILENAME_LENGTH; j++) {
            entryNameBytes[j] = data[dirEntryStartPixel + (j * 4)]; // Read R channel
        }
        const entryFilename = bytesToString(entryNameBytes);

        const statusOffset = dirEntryStartPixel + (STATUS_OFFSET * 4);
        const status = data[statusOffset]; // Read R channel for status

        if (entryFilename === filename && status === 1) { // 1 means active
            return { index: i, entryData: data.subarray(dirEntryStartPixel, dirEntryStartPixel + BYTES_PER_DIR_ENTRY * 4) };
        }
    }
    return null; // Not found
}

/**
 * Finds the first available empty directory entry.
 * @returns {{index: number, entryDataOffset: number}|null} An object with the index and pixel offset if found, null otherwise.
 */
async function findEmptyDirectoryEntry() {
    const data = pxldiskImageData.data;

    for (let i = 0; i < MAX_FILES; i++) {
        const dirEntryStartPixel = (DIR_START_ROW * BYTES_PER_ROW * 4) + (i * BYTES_PER_DIR_ENTRY * 4);
        const statusOffset = dirEntryStartPixel + (STATUS_OFFSET * 4);
        const status = data[statusOffset]; // Read R channel for status

        if (status === 0 || status === 2) { // 0=empty, 2=deleted (re-use deleted slots)
            return { index: i, entryDataOffset: dirEntryStartPixel };
        }
    }
    return null; // No empty slot
}

/**
 * Updates the disk's internal metadata (NAR, bytes used) and writes it to Row 0.
 */
async function updateDiskMetadata() {
    const data = pxldiskImageData.data;
    writeInt32(data, 12, nextAvailableRow);
    writeInt32(data, 16, totalBytesUsed);
    pxldiskCtx.putImageData(pxldiskImageData, 0, 0);
}


/**
 * Lists all active files in the PXLDISK directory.
 * @returns {Array<{name: string, startRow: number, length: number}>} An array of file objects.
 */
async function listFiles() {
    if (!pxldiskImageData) {
        console.error('PXLDISK not initialized. Call initDisk() first.');
        return [];
    }

    const files = [];
    const data = pxldiskImageData.data;

    for (let i = 0; i < MAX_FILES; i++) {
        const dirEntryStartPixel = (DIR_START_ROW * BYTES_PER_ROW * 4) + (i * BYTES_PER_DIR_ENTRY * 4);

        const entryNameBytes = new Uint8ClampedArray(FILENAME_LENGTH);
        for (let j = 0; j < FILENAME_LENGTH; j++) {
            entryNameBytes[j] = data[dirEntryStartPixel + (j * 4)];
        }
        const entryFilename = bytesToString(entryNameBytes);

        const statusOffset = dirEntryStartPixel + (STATUS_OFFSET * 4);
        const status = data[statusOffset];

        if (status === 1) { // Only list active files
            const startRow = readInt32(data, dirEntryStartPixel / 4 + START_ROW_OFFSET);
            const length = readInt32(data, dirEntryStartPixel / 4 + LENGTH_OFFSET);
            files.push({ name: entryFilename, startRow: startRow, length: length });
        }
    }
    return files;
}

/**
 * Writes data to a new file or updates an existing file.
 * Automatically allocates rows and writes content pixels.
 * Handles row overflow (max 247 rows for content).
 * @param {string} name The filename (max 16 characters).
 * @param {string} dataString The string content to write.
 * @returns {boolean} True if write was successful, false otherwise.
 */
async function writeFile(name, dataString) {
    if (!pxldiskImageData) {
        console.error('PXLDISK not initialized. Call initDisk() first.');
        return false;
    }
    if (name.length > FILENAME_LENGTH) {
        console.error(`Filename '${name}' too long. Max ${FILENAME_LENGTH} characters.`);
        return false;
    }

    const dataBytes = stringToBytes(dataString, dataString.length); // Actual bytes of content
    const requiredRows = Math.ceil(dataBytes.length / BYTES_PER_ROW);

    if (requiredRows > TOTAL_DATA_ROWS) {
        console.error(`File content too large (${dataBytes.length} bytes, needs ${requiredRows} rows). Max ${TOTAL_DATA_ROWS} rows per disk.`);
        return false;
    }

    let fileEntry = await findDirectoryEntry(name);
    let startRowForContent = 0;
    let dirEntryIndex = -1;
    let oldLength = 0;

    if (fileEntry) {
        // File exists, attempt to update in place or reallocate
        const currentStartRow = readInt32(fileEntry.entryData, START_ROW_OFFSET);
        const currentLength = readInt32(fileEntry.entryData, LENGTH_OFFSET);
        const currentRowCount = Math.ceil(currentLength / BYTES_PER_ROW);

        if (requiredRows <= currentRowCount) {
            // New data fits in existing allocated space
            console.log(`Updating file '${name}' in place.`);
            startRowForContent = currentStartRow;
            dirEntryIndex = fileEntry.index;
            oldLength = currentLength; // Keep track for totalBytesUsed adjustment
            // No need to deallocate, just overwrite
        } else {
            // New data requires more space, reallocate
            console.log(`File '${name}' needs more space. Deleting old and reallocating.`);
            await deleteFile(name); // Mark old entry as deleted and free rows
            fileEntry = null; // Ensure we go through the 'new file' path
        }
    }

    if (!fileEntry) {
        // Find an empty slot for a new file
        const emptyEntry = await findEmptyDirectoryEntry();
        if (!emptyEntry) {
            console.error('No empty directory entries available.');
            return false;
        }
        dirEntryIndex = emptyEntry.index;

        // Check if there's enough space left on disk
        if (nextAvailableRow + requiredRows > DISK_HEIGHT) {
            console.error('Not enough contiguous space on disk for new file.');
            // This is where Phase 3 (multi-disk chaining) would come in.
            return false;
        }
        startRowForContent = nextAvailableRow;
    }

    // Write file content pixels
    const data = pxldiskImageData.data;
    let currentPixelOffset = (startRowForContent * BYTES_PER_ROW * 4); // Start of content area for this file
    for (let i = 0; i < dataBytes.length; i++) {
        const byteValue = dataBytes[i];
        // For 1 byte/pixel, set R,G,B to the byte value, A to 255 (opaque)
        data[currentPixelOffset + 0] = byteValue; // R
        data[currentPixelOffset + 1] = byteValue; // G
        data[currentPixelOffset + 2] = byteValue; // B
        data[currentPixelOffset + 3] = 255;       // A
        currentPixelOffset += 4; // Move to next pixel
    }
    // Fill remaining pixels in the last row if data is not a multiple of BYTES_PER_ROW
    const remainingBytesInLastRow = (requiredRows * BYTES_PER_ROW) - dataBytes.length;
    for (let i = 0; i < remainingBytesInLastRow; i++) {
        data[currentPixelOffset + 0] = 0; // Fill with nulls/zeros
        data[currentPixelOffset + 1] = 0;
        data[currentPixelOffset + 2] = 0;
        data[currentPixelOffset + 3] = 255;
        currentPixelOffset += 4;
    }

    // Write/Update directory entry
    const dirEntryStartPixel = (DIR_START_ROW * BYTES_PER_ROW * 4) + (dirEntryIndex * BYTES_PER_DIR_ENTRY * 4);

    // Filename
    const nameBytes = stringToBytes(name, FILENAME_LENGTH);
    for (let i = 0; i < FILENAME_LENGTH; i++) {
        data[dirEntryStartPixel + (i * 4)] = nameBytes[i];     // R
        data[dirEntryStartPixel + (i * 4) + 1] = nameBytes[i]; // G
        data[dirEntryStartPixel + (i * 4) + 2] = nameBytes[i]; // B
        data[dirEntryStartPixel + (i * 4) + 3] = 255;          // A
    }

    // Start Row
    writeInt32(data, dirEntryStartPixel / 4 + START_ROW_OFFSET, startRowForContent);
    // Length (in bytes)
    writeInt32(data, dirEntryStartPixel / 4 + LENGTH_OFFSET, dataBytes.length);
    // Status (Active)
    data[dirEntryStartPixel + (STATUS_OFFSET * 4)] = 1; // R channel for status
    data[dirEntryStartPixel + (STATUS_OFFSET * 4) + 1] = 1; // G
    data[dirEntryStartPixel + (STATUS_OFFSET * 4) + 2] = 1; // B
    data[dirEntryStartPixel + (STATUS_OFFSET * 4) + 3] = 255; // A

    // Update global metadata
    if (!fileEntry) { // Only advance NAR if this was a new allocation
        nextAvailableRow = startRowForContent + requiredRows;
    }
    totalBytesUsed = totalBytesUsed - oldLength + dataBytes.length;
    await updateDiskMetadata();

    pxldiskCtx.putImageData(pxldiskImageData, 0, 0);
    console.log(`File '${name}' written successfully. Start Row: ${startRowForContent}, Length: ${dataBytes.length} bytes.`);
    return true;
}

/**
 * Reads the content of a file from PXLDISK.
 * @param {string} name The filename to read.
 * @returns {string|null} The file content as a string, or null if file not found.
 */
async function readFile(name) {
    if (!pxldiskImageData) {
        console.error('PXLDISK not initialized. Call initDisk() first.');
        return null;
    }

    const fileEntry = await findDirectoryEntry(name);
    if (!fileEntry) {
        console.warn(`File '${name}' not found.`);
        return null;
    }

    const startRow = readInt32(fileEntry.entryData, START_ROW_OFFSET);
    const length = readInt32(fileEntry.entryData, LENGTH_OFFSET);

    if (startRow < DIR_END_ROW + 1 || startRow >= DISK_HEIGHT || length < 0 || (startRow * BYTES_PER_ROW + length) > (DISK_HEIGHT * BYTES_PER_ROW)) {
        console.error(`Corrupt file entry for '${name}': Invalid startRow or length.`);
        return null;
    }

    const data = pxldiskImageData.data;
    const contentBytes = new Uint8ClampedArray(length);
    let currentPixelOffset = (startRow * BYTES_PER_ROW * 4); // Start of content in ImageData

    for (let i = 0; i < length; i++) {
        contentBytes[i] = data[currentPixelOffset + 0]; // Read R channel
        currentPixelOffset += 4;
    }

    console.log(`File '${name}' read successfully. Content length: ${length} bytes.`);
    return bytesToString(contentBytes);
}

/**
 * Deletes a file from the PXLDISK.
 * This marks the directory entry as deleted and conceptually frees the content rows.
 * (Actual row zeroing and reallocation/defragmentation would be handled in a more advanced phase).
 * @param {string} name The filename to delete.
 * @returns {boolean} True if deletion was successful, false otherwise.
 */
async function deleteFile(name) {
    if (!pxldiskImageData) {
        console.error('PXLDISK not initialized. Call initDisk() first.');
        return false;
    }

    const fileEntry = await findDirectoryEntry(name);
    if (!fileEntry) {
        console.warn(`File '${name}' not found for deletion.`);
        return false;
    }

    const data = pxldiskImageData.data;
    const dirEntryStartPixel = (DIR_START_ROW * BYTES_PER_ROW * 4) + (fileEntry.index * BYTES_PER_DIR_ENTRY * 4);

    // Mark directory entry as deleted (status = 2)
    data[dirEntryStartPixel + (STATUS_OFFSET * 4)] = 2; // R channel for status
    data[dirEntryStartPixel + (STATUS_OFFSET * 4) + 1] = 2; // G
    data[dirEntryStartPixel + (STATUS_OFFSET * 4) + 2] = 2; // B
    data[dirEntryStartPixel + (STATUS_OFFSET * 4) + 3] = 255; // A

    // Optionally zero out the content pixels for security/cleanliness (can be skipped for speed)
    const startRow = readInt32(fileEntry.entryData, START_ROW_OFFSET);
    const length = readInt32(fileEntry.entryData, LENGTH_OFFSET);
    const rowsToClear = Math.ceil(length / BYTES_PER_ROW);

    let currentPixelOffset = (startRow * BYTES_PER_ROW * 4);
    for (let i = 0; i < rowsToClear * BYTES_PER_ROW; i++) {
        data[currentPixelOffset + 0] = 0; // R
        data[currentPixelOffset + 1] = 0; // G
        data[currentPixelOffset + 2] = 0; // B
        data[currentPixelOffset + 3] = 255; // A
        currentPixelOffset += 4;
    }

    // Update total bytes used (subtract the length of the deleted file)
    totalBytesUsed -= length;
    await updateDiskMetadata();

    pxldiskCtx.putImageData(pxldiskImageData, 0, 0);
    console.log(`File '${name}' deleted successfully.`);
    return true;
}

/**
 * Gets the current disk usage statistics.
 * @returns {{usedBytes: number, availableBytes: number, totalBytes: number, freeRows: number}} Disk usage statistics.
 */
function getDiskStats() {
    return {
        usedBytes: totalBytesUsed,
        availableBytes: MAX_CONTENT_BYTES - totalBytesUsed,
        totalBytes: MAX_CONTENT_BYTES,
        freeRows: DISK_HEIGHT - nextAvailableRow
    };
}

// Export functions for external use
window.PXLDISK_FS = {
    initDisk,
    listFiles,
    writeFile,
    readFile,
    deleteFile,
    getDiskStats,
    // Future functions for Phase 3:
    // autoLinkNextChunk,
    // getSuperblock,
    // updateSuperblock,
    // chainFile
};










<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PXLDISK File System Interface</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
        }
        .container {
            background-color: #2d3748; /* Slightly lighter dark background for container */
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 900px;
            width: 100%;
        }
        canvas {
            border: 2px solid #4a5568;
            background-color: #000; /* Represents the 'disk' as black initially */
            image-rendering: pixelated; /* Crucial for pixel art display */
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            width: 100%; /* Make canvas responsive */
            max-width: 256px; /* Original pixel width */
            height: auto; /* Maintain aspect ratio */
            display: block;
            margin: 0 auto 1.5rem auto;
            border-radius: 0.5rem;
        }
        input, textarea, select {
            background-color: #4a5568;
            border: 1px solid #6b7280;
            color: #e2e8f0;
            padding: 0.5rem 0.75rem;
            border-radius: 0.375rem;
            width: 100%;
        }
        button {
            background-color: #63b3ed; /* Blue for primary actions */
            color: #1a202c;
            font-weight: bold;
            padding: 0.75rem 1rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            cursor: pointer;
        }
        button:hover {
            background-color: #4299e1; /* Darker blue on hover */
        }
        button.delete-btn {
            background-color: #fc8181; /* Red for delete action */
        }
        button.delete-btn:hover {
            background-color: #e53e3e; /* Darker red on hover */
        }
        .log-area, .stats-area {
            background-color: #1a202c;
            border: 1px solid #4a5568;
            border-radius: 0.5rem;
            padding: 1rem;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            white-space: pre-wrap; /* Preserve whitespace and wrap long lines */
            word-break: break-all; /* Break long words */
            font-family: 'Cascadia Mono', 'Fira Code', monospace; /* Monospace for logs */
            font-size: 0.875rem;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="container flex flex-col lg:flex-row gap-8">
        <div class="lg:w-1/2 flex flex-col items-center">
            <h1 class="text-3xl font-bold mb-6 text-center" id="mainTitle">PXLDISK File System (Disk: PXLDISK_000)</h1>
            <canvas id="pxldiskCanvas" width="256" height="256"></canvas>

            <div class="w-full flex flex-col sm:flex-row gap-4 mt-4">
                <div class="flex-grow">
                    <label for="diskSelect" class="block text-sm font-medium mb-1">Select Disk Chunk:</label>
                    <select id="diskSelect" class="p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                        <option value="PXLDISK_000">PXLDISK_000</option>
                        <option value="PXLDISK_001">PXLDISK_001</option>
                        <option value="PXLDISK_002">PXLDISK_002</option>
                        <option value="PXLDISK_003">PXLDISK_003</option>
                        <option value="PXLDISK_004">PXLDISK_004</option>
                    </select>
                </div>
                <button id="loadDiskBtn" class="bg-indigo-500 hover:bg-indigo-600 text-white font-bold px-6 py-3 rounded-lg shadow-md transition-colors duration-200">
                    Load Selected Disk
                </button>
            </div>

            <button id="downloadDiskBtn" class="mt-4 w-full md:w-auto px-6 py-3 bg-green-500 hover:bg-green-600 text-white font-bold rounded-lg shadow-md transition-colors duration-200">
                Download Disk (<span id="currentDiskFilename">8.png</span>)
            </button>
            <div id="statusMessage" class="mt-4 text-center text-sm text-yellow-400"></div>
        </div>

        <div class="lg:w-1/2">
            <div class="mb-4">
                <label for="filenameInput" class="block text-sm font-medium mb-1">Filename (max 16 chars):</label>
                <input type="text" id="filenameInput" placeholder="e.g., roadmap.txt" maxlength="16" class="p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
            </div>

            <div class="mb-4">
                <label for="dataInput" class="block text-sm font-medium mb-1">File Content:</label>
                <textarea id="dataInput" rows="6" placeholder="Enter file content here..." class="p-2 rounded-md resize-y focus:outline-none focus:ring-2 focus:ring-blue-500"></textarea>
            </div>

            <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 mb-6">
                <button id="writeButton" class="write-btn">Write File</button>
                <button id="readButton">Read File</button>
                <button id="deleteButton" class="delete-btn">Delete File</button>
                <button id="listButton">List Files</button>
            </div>

            <h2 class="text-xl font-semibold mb-3">PixelNet Workflows (Phase 4)</h2>
            <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
                <button id="writeTasksBtn" class="bg-purple-600 hover:bg-purple-700 text-white">Store tasks.txt</button>
                <button id="writeResponsesBtn" class="bg-purple-600 hover:bg-purple-700 text-white">Write responses.log</button>
                <button id="writeAIConfigBtn" class="bg-purple-600 hover:bg-purple-700 text-white">Save junior.cfg</button>
            </div>

            <h2 class="text-xl font-semibold mb-3">CLI Console (Phase 6)</h2>
            <div class="mb-4 flex gap-2">
                <input type="text" id="cliInput" placeholder="e.g., list, read roadmap.txt, write my_file &quot;content&quot;" class="flex-grow p-2 rounded-md focus:outline-none focus:ring-2 focus:ring-blue-500">
                <button id="runCliBtn" class="bg-orange-500 hover:bg-orange-600 text-white px-4 py-2 rounded-md">Run</button>
            </div>


            <h2 class="text-xl font-semibold mb-3">Output Log</h2>
            <pre id="outputLog" class="log-area mb-6">File system activity will appear here...</pre>

            <h2 class="text-xl font-semibold mb-3">Disk Usage Stats</h2>
            <div id="statsArea" class="stats-area">
                <p><strong>Current Disk:</strong> <span id="diskIdStat">N/A</span></p>
                <p><strong>Used:</strong> <span id="usedBytes">0</span> bytes</p>
                <p><strong>Available:</strong> <span id="availableBytes">0</span> bytes</p>
                <p><strong>Total Capacity:</strong> <span id="totalBytes">0</span> bytes</p>
                <p><strong>Free Rows:</strong> <span id="freeRows">0</span></p>
            </div>
        </div>
    </div>

    <script>
        /**
         * pxldisk_fs.js (Inlined for self-contained execution in this environment)
         * Core File System Module for PixelNet (PXLDISK)
         *
         * This module provides basic file operations (read, write, delete, list, update)
         * by manipulating pixel data within an HTML Canvas element, representing a
         * 256x256 pixel 'disk chunk' (e.g., 8.png as PXLDISK_000).
         *
         * PXLDISK Structure:
         * - Image Size: 256x256 pixels
         * - Pixel Format: 1 byte per pixel (grayscale 0-255)
         * - Row 0: Magic Header and Disk Metadata
         * - Bytes 0-7: "PXLDISKv" (Magic Header)
         * - Bytes 8-11: Version (e.g., 0x0101 for v1.1)
         * - Bytes 12-15: Next Available Row Pointer (NAR)
         * - Bytes 16-19: Total Bytes Used
         * - Bytes 20-23: Total Bytes Available
         * - Bytes 24-27: Superblock Pointer (simulated: index of next chunk if needed)
         * - Remaining bytes in Row 0: Reserved for future global metadata
         * - Rows 1-8: Directory (8 rows * 256 bytes/row = 2048 bytes total)
         * - Each file entry in the directory will be a fixed size (e.g., 32 bytes).
         * - Format per entry (example):
         * - Bytes 0-15: Filename (padded with nulls)
         * - Bytes 16-19: Start Row
         * - Bytes 20-23: Length in Pixels (bytes)
         * - Byte 24: Status (0=empty, 1=active, 2=deleted)
         * - Bytes 25-31: Reserved for checksums, timestamps, permissions, etc.
         * - Rows 9-255: Content Area (247 rows)
         * - Each row: (255 bytes for content) + (1 byte for row checksum)
         * - Total content bytes per row: 255
         * - This is where the actual file data is stored, one byte per pixel.
         * - Max file size (single disk): 247 rows * 255 content bytes/row = 62985 bytes.
         *
         * NOTE: For simplicity, this initial version assumes a 1-byte-per-pixel (grayscale)
         * encoding where each pixel's R, G, B, and A channels are the same value.
         * Checksums are simple XOR sums for demonstration.
         */

        // --- Constants ---
        const DISK_WIDTH = 256;
        const DISK_HEIGHT = 256;

        const ROW_METADATA_BYTES = 1; // 1 byte for checksum per row
        const BYTES_PER_ROW_CONTENT = DISK_WIDTH - ROW_METADATA_BYTES; // Content bytes per row
        const TOTAL_DATA_ROWS = DISK_HEIGHT - 9; // Rows 9 to 255 for content
        const MAX_CONTENT_BYTES_PER_DISK = TOTAL_DATA_ROWS * BYTES_PER_ROW_CONTENT;

        const MAGIC_HEADER = "PXLDISKv";
        const CURRENT_VERSION = 0x0101; // Version 1.1

        // Directory Structure
        const DIR_START_ROW = 1;
        const DIR_END_ROW = 8;
        const NUM_DIR_ROWS = DIR_END_ROW - DIR_START_ROW + 1;
        const BYTES_PER_DIR_ENTRY = 32; // 16-byte name, 4-byte start, 4-byte length, 1-byte status, 7-byte padding
        const MAX_FILES = Math.floor((NUM_DIR_ROWS * DISK_WIDTH) / BYTES_PER_DIR_ENTRY); // Use DISK_WIDTH for dir row size

        // Directory Entry Offsets within a 32-byte block
        const FILENAME_OFFSET = 0;
        const FILENAME_LENGTH = 16;
        const START_ROW_OFFSET = 16;
        const LENGTH_OFFSET = 20;
        const STATUS_OFFSET = 24;

        // Superblock offsets (within Row 0, after main metadata)
        const SUPERBLOCK_POINTER_OFFSET = 24; // Logical byte offset for pointer to next chunk

        // --- Global State (simulated Canvas and ImageData) ---
        let pxldiskCanvas = null;
        let pxldiskCtx = null;
        let pxldiskImageData = null; // Uint8ClampedArray representing R,G,B,A for each pixel
        let currentDiskId = 'PXLDISK_000'; // Default active disk ID

        // Disk Metadata (read from/written to Row 0)
        let nextAvailableRow = 9; // Content starts at row 9
        let totalBytesUsed = 0;

        /**
         * Helper: Converts a string to a byte array (padded or truncated).
         * @param {string} str The string to convert.
         * @param {number} length The desired length of the byte array.
         * @returns {Uint8Array} The byte array.
         */
        function stringToBytes(str, length) {
            const bytes = new Uint8Array(length).fill(0); // Pad with nulls
            for (let i = 0; i < str.length && i < length; i++) {
                bytes[i] = str.charCodeAt(i);
            }
            return bytes;
        }

        /**
         * Helper: Converts a byte array to a string (stops at null terminator).
         * @param {Uint8ClampedArray | Uint8Array} bytes The byte array to convert.
         * @returns {string} The converted string.
         */
        function bytesToString(bytes) {
            let str = '';
            for (let i = 0; i < bytes.length; i++) {
                if (bytes[i] === 0) break; // Null terminator
                str += String.fromCharCode(bytes[i]);
            }
            return str;
        }

        /**
         * Helper: Reads a 4-byte integer from a specific logical byte offset in the ImageData data array.
         * Each logical byte maps to the R, G, B channels of a pixel.
         * @param {Uint8ClampedArray} data The imageData.data array.
         * @param {number} logicalByteOffset The logical byte offset (e.g., 0 for first byte, 1 for second).
         * @returns {number} The 4-byte integer.
         */
        function readInt32(data, logicalByteOffset) {
            const effectiveOffset = logicalByteOffset * 4; // Each logical byte corresponds to R channel of a pixel
            if (effectiveOffset + 3 * 4 >= data.length) {
                console.error(`readInt32: Out of bounds access at logicalByteOffset ${logicalByteOffset}`);
                return 0;
            }
            return (data[effectiveOffset] |
                    (data[effectiveOffset + 4] << 8) |
                    (data[effectiveOffset + 8] << 16) |
                    (data[effectiveOffset + 12] << 24)) >>> 0;
        }

        /**
         * Helper: Writes a 4-byte integer to a specific logical byte offset in the ImageData data array.
         * Each logical byte maps to the R, G, B channels of a pixel.
         * @param {Uint8ClampedArray} data The imageData.data array.
         * @param {number} logicalByteOffset The logical byte offset.
         * @param {number} value The integer value.
         */
        function writeInt32(data, logicalByteOffset, value) {
            const effectiveOffset = logicalByteOffset * 4; // Each logical byte corresponds to R channel of a pixel
            if (effectiveOffset + 3 * 4 >= data.length) {
                console.error(`writeInt32: Out of bounds write at logicalByteOffset ${logicalByteOffset}`);
                return;
            }

            for (let i = 0; i < 4; i++) {
                const byteValue = (value >> (i * 8)) & 0xFF;
                const pixelIndex = effectiveOffset + (i * 4);
                data[pixelIndex + 0] = byteValue; // R
                data[pixelIndex + 1] = byteValue; // G
                data[pixelIndex + 2] = byteValue; // B
                data[pixelIndex + 3] = 255;       // A
            }
        }

        /**
         * Helper: Calculates a simple XOR checksum for a given byte array.
         * @param {Uint8Array} bytes The byte array.
         * @returns {number} The checksum (0-255).
         */
        function calculateChecksum(bytes) {
            let checksum = 0;
            for (let i = 0; i < bytes.length; i++) {
                checksum ^= bytes[i];
            }
            return checksum & 0xFF; // Ensure it's a single byte
        }

        /**
         * Initializes the PXLDISK file system from a given HTML Canvas element.
         * Loads the image data, validates the magic header, and reads disk metadata.
         * If the header is invalid, it formats the disk.
         * @param {HTMLCanvasElement} canvas The canvas element representing the disk.
         * @param {string} diskId The ID of the disk chunk (e.g., "PXLDISK_000").
         */
        async function initDisk(canvas, diskId) {
            logToOutput(`Initializing PXLDISK (${diskId})...`);
            currentDiskId = diskId; // Set the global currentDiskId
            pxldiskCanvas = canvas;
            pxldiskCtx = canvas.getContext('2d', { willReadFrequently: true });

            // Ensure canvas dimensions match PXLDISK spec
            if (pxldiskCanvas.width !== DISK_WIDTH || pxldiskCanvas.height !== DISK_HEIGHT) {
                logToOutput(`Warning: Canvas dimensions (${pxldiskCanvas.width}x${pxldiskCanvas.height}) do not match PXLDISK spec (${DISK_WIDTH}x${DISK_HEIGHT}). Resizing canvas.`, 'warn');
                pxldiskCanvas.width = DISK_WIDTH;
                pxldiskCanvas.height = DISK_HEIGHT;
            }

            // Get current image data from canvas (initially all black pixels if no image loaded)
            pxldiskImageData = pxldiskCtx.getImageData(0, 0, DISK_WIDTH, DISK_HEIGHT);
            const data = pxldiskImageData.data; // This is a Uint8ClampedArray (R,G,B,A, R,G,B,A, ...)

            // Read Magic Header (first 8 pixels' Red channel)
            let header = '';
            for (let i = 0; i < MAGIC_HEADER.length; i++) {
                header += String.fromCharCode(data[i * 4]); // Read R channel for each of the 8 pixels
            }

            logToOutput(`Read header: '${header}' for ${diskId}`);

            if (header === MAGIC_HEADER) {
                logToOutput(`PXLDISK magic header found on ${diskId}. Reading existing disk.`);
                // Read version, next available row, and byte counts
                const version = readInt32(data, 8); // Offset 8 for version (logical byte offset)
                nextAvailableRow = readInt32(data, 12); // Offset 12 for NAR
                totalBytesUsed = readInt32(data, 16); // Offset 16 for bytes used

                logToOutput(`PXLDISK Version: 0x${version.toString(16)} on ${diskId}`);
                logToOutput(`Next Available Row (NAR): ${nextAvailableRow} on ${diskId}`);
                logToOutput(`Total Bytes Used: ${totalBytesUsed} on ${diskId}`);

                // Basic validation: NAR should be within content rows
                if (nextAvailableRow < DIR_END_ROW + 1 || nextAvailableRow >= DISK_HEIGHT) {
                    logToOutput(`Invalid Next Available Row pointer on ${diskId}. Reformatting disk.`, 'warn');
                    await formatDisk();
                }
            } else {
                logToOutput(`PXLDISK magic header not found or invalid on ${diskId}. Formatting disk.`, 'info');
                await formatDisk();
            }
            updateUIForDiskChange();
            updateStats();
            logToOutput(`PXLDISK (${diskId}) initialization complete.`);
        }

        /**
         * Formats the PXLDISK, writing the magic header and clearing directory/content areas.
         * This is a destructive operation.
         */
        async function formatDisk() {
            logToOutput(`Formatting PXLDISK (${currentDiskId})...`);
            const data = pxldiskImageData.data;

            // Clear all pixels (set to 0 - black)
            for (let i = 0; i < data.length; i += 4) {
                data[i] = 0;     // R
                data[i + 1] = 0; // G
                data[i + 2] = 0; // B
                data[i + 3] = 255; // A (fully opaque)
            }

            // Write Magic Header (each char as R,G,B of a pixel)
            for (let i = 0; i < MAGIC_HEADER.length; i++) {
                const byteValue = MAGIC_HEADER.charCodeAt(i);
                data[i * 4] = byteValue;
                data[i * 4 + 1] = byteValue;
                data[i * 4 + 2] = byteValue;
            }

            // Write Version (logical byte offset 8)
            writeInt32(data, 8, CURRENT_VERSION);

            // Initialize metadata
            nextAvailableRow = DIR_END_ROW + 1; // Content starts after directory (row 9)
            totalBytesUsed = 0;
            writeInt32(data, 12, nextAvailableRow);    // Logical byte offset 12 for NAR
            writeInt32(data, 16, totalBytesUsed);      // Logical byte offset 16 for bytes used
            writeInt32(data, 20, MAX_CONTENT_BYTES_PER_DISK);   // Logical byte offset 20 for total bytes available

            // Superblock pointer (simulated for now, points to 0, implying no next chunk)
            writeInt32(data, SUPERBLOCK_POINTER_OFFSET, 0);

            // Update canvas with new image data
            pxldiskCtx.putImageData(pxldiskImageData, 0, 0);
            updateStats();
            logToOutput(`PXLDISK (${currentDiskId}) formatted successfully.`);
        }

        /**
         * Finds a directory entry by name.
         * @param {string} filename The name of the file to find.
         * @returns {{index: number, entryStartByte: number, startRow: number, length: number}|null} An object with details if found, null otherwise.
         */
        async function findDirectoryEntry(filename) {
            const data = pxldiskImageData.data;

            for (let i = 0; i < MAX_FILES; i++) {
                // Calculate the logical byte offset for the start of this directory entry
                const entryLogicalByteOffset = (DIR_START_ROW * DISK_WIDTH) + (i * BYTES_PER_DIR_ENTRY);

                // Read filename bytes
                const entryNameBytes = new Uint8ClampedArray(FILENAME_LENGTH);
                for (let j = 0; j < FILENAME_LENGTH; j++) {
                    entryNameBytes[j] = data[(entryLogicalByteOffset + FILENAME_OFFSET + j) * 4]; // Read R channel
                }
                const entryFilename = bytesToString(entryNameBytes);

                // Read status byte
                const statusLogicalByteOffset = entryLogicalByteOffset + STATUS_OFFSET;
                const status = data[statusLogicalByteOffset * 4]; // Read R channel for status

                if (entryFilename === filename && status === 1) { // 1 means active
                    const startRow = readInt32(data, entryLogicalByteOffset + START_ROW_OFFSET);
                    const length = readInt32(data, entryLogicalByteOffset + LENGTH_OFFSET);
                    return { index: i, entryStartByte: entryLogicalByteOffset, startRow: startRow, length: length };
                }
            }
            return null; // Not found
        }

        /**
         * Finds the first available empty or deleted directory entry.
         * @returns {{index: number, entryStartByte: number}|null} An object with the index and logical byte offset if found, null otherwise.
         */
        async function findEmptyDirectoryEntry() {
            const data = pxldiskImageData.data;

            for (let i = 0; i < MAX_FILES; i++) {
                const entryLogicalByteOffset = (DIR_START_ROW * DISK_WIDTH) + (i * BYTES_PER_DIR_ENTRY);
                const statusLogicalByteOffset = entryLogicalByteOffset + STATUS_OFFSET;
                const status = data[statusLogicalByteOffset * 4]; // Read R channel for status

                if (status === 0 || status === 2) { // 0=empty, 2=deleted (re-use deleted slots)
                    return { index: i, entryStartByte: entryLogicalByteOffset };
                }
            }
            return null; // No empty slot
        }

        /**
         * Updates the disk's internal metadata (NAR, bytes used) and writes it to Row 0.
         */
        async function updateDiskMetadata() {
            const data = pxldiskImageData.data;
            writeInt32(data, 12, nextAvailableRow);
            writeInt32(data, 16, totalBytesUsed);
            pxldiskCtx.putImageData(pxldiskImageData, 0, 0); // Update the canvas visually
            updateStats();
        }


        /**
         * Lists all active files in the PXLDISK directory.
         * @returns {Array<{name: string, startRow: number, length: number}>} An array of file objects.
         */
        async function listFiles() {
            if (!pxldiskImageData) {
                logToOutput(`PXLDISK (${currentDiskId}) not initialized. Call initDisk() first.`, 'error');
                return [];
            }

            const files = [];
            const data = pxldiskImageData.data;

            for (let i = 0; i < MAX_FILES; i++) {
                const entryLogicalByteOffset = (DIR_START_ROW * DISK_WIDTH) + (i * BYTES_PER_DIR_ENTRY);

                const entryNameBytes = new Uint8ClampedArray(FILENAME_LENGTH);
                for (let j = 0; j < FILENAME_LENGTH; j++) {
                    entryNameBytes[j] = data[(entryLogicalByteOffset + FILENAME_OFFSET + j) * 4]; // Read R channel
                }
                const entryFilename = bytesToString(entryNameBytes);

                const statusLogicalByteOffset = entryLogicalByteOffset + STATUS_OFFSET;
                const status = data[statusLogicalByteOffset * 4]; // Read R channel for status

                if (status === 1) { // Only list active files
                    const startRow = readInt32(data, entryLogicalByteOffset + START_ROW_OFFSET);
                    const length = readInt32(data, entryLogicalByteOffset + LENGTH_OFFSET);
                    files.push({ name: entryFilename, startRow: startRow, length: length });
                }
            }
            if (files.length === 0) {
                logToOutput(`No files found on disk ${currentDiskId}.`);
            } else {
                let fileList = `Files on disk ${currentDiskId}:\n`;
                files.forEach(file => {
                    fileList += `- Name: ${file.name}, Start Row: ${file.startRow}, Length: ${file.length} bytes\n`;
                });
                logToOutput(fileList, 'info');
            }
            return files;
        }

        /**
         * Writes data to a new file or updates an existing file.
         * Automatically allocates rows and writes content pixels.
         * Handles row overflow (max 247 rows for content).
         * @param {string} name The filename (max 16 characters).
         * @param {string} dataString The string content to write.
         * @returns {boolean} True if write was successful, false otherwise.
         */
        async function writeFile(name, dataString) {
            if (!pxldiskImageData) {
                logToOutput(`PXLDISK (${currentDiskId}) not initialized. Call initDisk() first.`, 'error');
                return false;
            }
            if (!name.trim()) {
                logToOutput('Filename cannot be empty.', 'error');
                return false;
            }
            if (name.length > FILENAME_LENGTH) {
                logToOutput(`Filename '${name}' too long. Max ${FILENAME_LENGTH} characters.`, 'error');
                return false;
            }

            const dataBytes = new TextEncoder().encode(dataString); // Use TextEncoder for proper UTF-8 bytes
            const requiredContentRows = Math.ceil(dataBytes.length / BYTES_PER_ROW_CONTENT);

            if (dataBytes.length > MAX_CONTENT_BYTES_PER_DISK) {
                logToOutput(`File '${name}' (${dataBytes.length} bytes) is too large for a single disk (${MAX_CONTENT_BYTES_PER_DISK} bytes). This file would span across multiple PXLDISK chunks. Writing partial to current disk. (Phase 3 Concept)`, 'warn');
                // For this simulation, we'll write up to the max capacity of a single disk.
                // A true implementation would handle disk chaining here.
            }

            let fileEntry = await findDirectoryEntry(name);
            let startRowForContent = 0;
            let dirEntryIndex = -1;
            let oldLength = 0; // Used to adjust totalBytesUsed for updates

            if (fileEntry) {
                // File exists, attempt to update in place or reallocate
                const currentStartRow = fileEntry.startRow;
                const currentLength = fileEntry.length;
                const currentRowCount = Math.ceil(currentLength / BYTES_PER_ROW_CONTENT);

                if (requiredContentRows <= currentRowCount) {
                    // New data fits in existing allocated space
                    logToOutput(`Updating file '${name}' on ${currentDiskId} in place.`);
                    startRowForContent = currentStartRow;
                    dirEntryIndex = fileEntry.index;
                    oldLength = currentLength; // Keep track for totalBytesUsed adjustment
                    // No need to deallocate, just overwrite
                } else {
                    // New data requires more space, reallocate
                    logToOutput(`File '${name}' on ${currentDiskId} needs more space. Deleting old and reallocating at end of disk.`);
                    await deleteFile(name); // Mark old entry as deleted and free rows
                    fileEntry = null; // Ensure we go through the 'new file' path
                }
            }

            if (!fileEntry) {
                // Check for name collision for *new* file
                if (await findDirectoryEntry(name)) {
                     logToOutput(`Error: File with name '${name}' already exists. Use 'delete' first if you intend to re-write, or 'update' for in-place changes (if size permits).`, 'error');
                     return false;
                }

                // Find an empty slot for a new file
                const emptyEntry = await findEmptyDirectoryEntry();
                if (!emptyEntry) {
                    logToOutput(`No empty directory entries available on ${currentDiskId}. Delete some files to free up space.`, 'error');
                    return false;
                }
                dirEntryIndex = emptyEntry.index;

                // Check if there's enough space left on disk (contiguous)
                if (nextAvailableRow + requiredContentRows > DISK_HEIGHT) {
                    logToOutput(`Not enough contiguous space on disk ${currentDiskId} for new file. Needed: ${requiredContentRows} rows. Available: ${DISK_HEIGHT - nextAvailableRow} rows. Consider defragmentation (future phase) or smaller files.`, 'error');
                    return false;
                }
                startRowForContent = nextAvailableRow;
            }

            // Write file content pixels
            const data = pxldiskImageData.data;
            let currentContentByteIndex = 0; // Tracks bytes from dataBytes
            for (let r = 0; r < requiredContentRows; r++) {
                const currentRow = startRowForContent + r;
                const rowStartLogicalByteOffset = currentRow * DISK_WIDTH;

                const rowContentBytes = new Uint8Array(BYTES_PER_ROW_CONTENT);
                for (let i = 0; i < BYTES_PER_ROW_CONTENT; i++) {
                    if (currentContentByteIndex < dataBytes.length) {
                        rowContentBytes[i] = dataBytes[currentContentByteIndex];
                        currentContentByteIndex++;
                    } else {
                        rowContentBytes[i] = 0; // Pad with zeros if end of data
                    }
                    const pixelIndex = (rowStartLogicalByteOffset + i) * 4;
                    data[pixelIndex + 0] = rowContentBytes[i]; // R
                    data[pixelIndex + 1] = rowContentBytes[i]; // G
                    data[pixelIndex + 2] = rowContentBytes[i]; // B
                    data[pixelIndex + 3] = 255;       // A (fully opaque)
                }
                // Write checksum for the row
                const checksum = calculateChecksum(rowContentBytes);
                const checksumPixelIndex = (rowStartLogicalByteOffset + BYTES_PER_ROW_CONTENT) * 4;
                data[checksumPixelIndex + 0] = checksum;
                data[checksumPixelIndex + 1] = checksum;
                data[checksumPixelIndex + 2] = checksum;
                data[checksumPixelIndex + 3] = 255;
            }

            // Write/Update directory entry
            const dirEntryLogicalByteOffset = (DIR_START_ROW * DISK_WIDTH) + (dirEntryIndex * BYTES_PER_DIR_ENTRY);

            // Filename
            const nameBytes = stringToBytes(name, FILENAME_LENGTH);
            for (let i = 0; i < FILENAME_LENGTH; i++) {
                const pixelIndex = (dirEntryLogicalByteOffset + FILENAME_OFFSET + i) * 4;
                data[pixelIndex + 0] = nameBytes[i];
                data[pixelIndex + 1] = nameBytes[i];
                data[pixelIndex + 2] = nameBytes[i];
                data[pixelIndex + 3] = 255;
            }

            // Start Row
            writeInt32(data, dirEntryLogicalByteOffset + START_ROW_OFFSET, startRowForContent);
            // Length (in bytes)
            writeInt32(data, dirEntryLogicalByteOffset + LENGTH_OFFSET, dataBytes.length);
            // Status (Active = 1)
            const statusPixelIndex = (dirEntryLogicalByteOffset + STATUS_OFFSET) * 4;
            data[statusPixelIndex + 0] = 1;
            data[statusPixelIndex + 1] = 1;
            data[statusPixelIndex + 2] = 1;
            data[statusPixelIndex + 3] = 255;

            // Update global metadata
            if (!fileEntry) { // Only advance NAR if this was a new allocation
                nextAvailableRow = startRowForContent + requiredContentRows;
            }
            totalBytesUsed = totalBytesUsed - oldLength + dataBytes.length; // Adjust for actual data size
            await updateDiskMetadata();

            pxldiskCtx.putImageData(pxldiskImageData, 0, 0);
            logToOutput(`File '${name}' written successfully on ${currentDiskId}. Start Row: ${startRowForContent}, Length: ${dataBytes.length} bytes.`, 'success');
            return true;
        }

        /**
         * Reads the content of a file from PXLDISK.
         * @param {string} name The filename to read.
         * @returns {string|null} The file content as a string, or null if file not found.
         */
        async function readFile(name) {
            if (!pxldiskImageData) {
                logToOutput(`PXLDISK (${currentDiskId}) not initialized. Call initDisk() first.`, 'error');
                return null;
            }
            if (!name.trim()) {
                logToOutput('Filename cannot be empty.', 'error');
                return null;
            }

            const fileEntry = await findDirectoryEntry(name);
            if (!fileEntry) {
                logToOutput(`File '${name}' not found on ${currentDiskId}.`, 'warn');
                return null;
            }

            const startRow = fileEntry.startRow;
            const length = fileEntry.length;
            const allocatedRows = Math.ceil(length / BYTES_PER_ROW_CONTENT);

            if (startRow < DIR_END_ROW + 1 || startRow >= DISK_HEIGHT || length < 0 || (startRow * DISK_WIDTH + allocatedRows * DISK_WIDTH) > (DISK_HEIGHT * DISK_WIDTH)) {
                logToOutput(`Corrupt file entry for '${name}' on ${currentDiskId}: Invalid startRow or length.`, 'error');
                return null;
            }

            const data = pxldiskImageData.data;
            const contentBytes = new Uint8ClampedArray(length);
            let currentContentByteIndex = 0;

            for (let r = 0; r < allocatedRows; r++) {
                const currentRow = startRow + r;
                const rowStartLogicalByteOffset = currentRow * DISK_WIDTH;

                const rowContent = new Uint8Array(BYTES_PER_ROW_CONTENT);
                for (let i = 0; i < BYTES_PER_ROW_CONTENT; i++) {
                    if (currentContentByteIndex < length) { // Only read up to actual file length
                        rowContent[i] = data[(rowStartLogicalByteOffset + i) * 4]; // Read R channel
                        contentBytes[currentContentByteIndex] = rowContent[i];
                        currentContentByteIndex++;
                    }
                }
                // Verify checksum
                const storedChecksum = data[(rowStartLogicalByteOffset + BYTES_PER_ROW_CONTENT) * 4];
                const calculatedChecksum = calculateChecksum(rowContent);

                if (storedChecksum !== calculatedChecksum) {
                    logToOutput(`Checksum mismatch for row ${currentRow} of file '${name}' on ${currentDiskId}. Data may be corrupt! Stored: ${storedChecksum}, Calculated: ${calculatedChecksum}`, 'error');
                }
            }

            const decodedString = new TextDecoder().decode(contentBytes);
            logToOutput(`File '${name}' read successfully from ${currentDiskId}. Content length: ${length} bytes.\nContent:\n${decodedString}`, 'info');
            return decodedString;
        }

        /**
         * Deletes a file from the PXLDISK.
         * This marks the directory entry as deleted and conceptually frees the content rows.
         * @param {string} name The filename to delete.
         * @returns {boolean} True if deletion was successful, false otherwise.
         */
        async function deleteFile(name) {
            if (!pxldiskImageData) {
                logToOutput(`PXLDISK (${currentDiskId}) not initialized. Call initDisk() first.`, 'error');
                return false;
            }
            if (!name.trim()) {
                logToOutput('Filename cannot be empty.', 'error');
                return false;
            }

            const fileEntry = await findDirectoryEntry(name);
            if (!fileEntry) {
                logToOutput(`File '${name}' not found for deletion on ${currentDiskId}.`, 'warn');
                return false;
            }

            const data = pxldiskImageData.data;
            const dirEntryLogicalByteOffset = (DIR_START_ROW * DISK_WIDTH) + (fileEntry.index * BYTES_PER_DIR_ENTRY);

            // Mark directory entry as deleted (status = 2)
            const statusPixelIndex = (dirEntryLogicalByteOffset + STATUS_OFFSET) * 4;
            data[statusPixelIndex + 0] = 2; // R channel for status
            data[statusPixelIndex + 1] = 2; // G
            data[statusPixelIndex + 2] = 2; // B
            data[statusPixelIndex + 3] = 255; // A

            // Zero out the content pixels for security/cleanliness (including checksum byte)
            const startRow = fileEntry.startRow;
            const length = fileEntry.length;
            const rowsToClear = Math.ceil(length / BYTES_PER_ROW_CONTENT);

            for (let r = 0; r < rowsToClear; r++) {
                const currentRow = startRow + r;
                const rowStartLogicalByteOffset = currentRow * DISK_WIDTH;
                for (let i = 0; i < DISK_WIDTH; i++) { // Clear the whole row including checksum
                    const pixelIndex = (rowStartLogicalByteOffset + i) * 4;
                    data[pixelIndex + 0] = 0; // R
                    data[pixelIndex + 1] = 0; // G
                    data[pixelIndex + 2] = 0; // B
                    data[pixelIndex + 3] = 255; // A
                }
            }

            // Update total bytes used (subtract the length of the deleted file)
            totalBytesUsed -= length;
            await updateDiskMetadata(); // Update metadata and canvas

            pxldiskCtx.putImageData(pxldiskImageData, 0, 0); // Update the canvas visually
            logToOutput(`File '${name}' deleted successfully from ${currentDiskId}.`, 'success');
            return true;
        }

        /**
         * Gets the current disk usage statistics.
         * @returns {{usedBytes: number, availableBytes: number, totalBytes: number, freeRows: number, diskId: string}} Disk usage statistics.
         */
        function getDiskStats() {
            return {
                usedBytes: totalBytesUsed,
                availableBytes: MAX_CONTENT_BYTES_PER_DISK - totalBytesUsed,
                totalBytes: MAX_CONTENT_BYTES_PER_DISK,
                freeRows: DISK_HEIGHT - nextAvailableRow,
                diskId: currentDiskId
            };
        }

        // Expose PXLDISK_FS functions globally for CLI/external access
        window.PXLDISK_FS = {
            initDisk,
            listFiles,
            writeFile,
            readFile,
            deleteFile,
            getDiskStats,
            // Additional future APIs could go here (e.g., superblock manipulation, defrag)
        };

        // --- UI Logic ---
        const mainTitle = document.getElementById('mainTitle');
        const filenameInput = document.getElementById('filenameInput');
        const dataInput = document.getElementById('dataInput');
        const writeButton = document.getElementById('writeButton');
        const readButton = document.getElementById('readButton');
        const deleteButton = document.getElementById('deleteButton');
        const listButton = document.getElementById('listButton');
        const outputLog = document.getElementById('outputLog');
        const diskIdStatSpan = document.getElementById('diskIdStat');
        const usedBytesSpan = document.getElementById('usedBytes');
        const availableBytesSpan = document.getElementById('availableBytes');
        const totalBytesSpan = document.getElementById('totalBytes');
        const freeRowsSpan = document.getElementById('freeRows');
        const diskSelect = document.getElementById('diskSelect');
        const loadDiskBtn = document.getElementById('loadDiskBtn');
        const downloadDiskBtn = document.getElementById('downloadDiskBtn');
        const currentDiskFilenameSpan = document.getElementById('currentDiskFilename');
        const statusMessageDiv = document.getElementById('statusMessage');

        // Phase 4 Workflow Buttons
        const writeTasksBtn = document.getElementById('writeTasksBtn');
        const writeResponsesBtn = document.getElementById('writeResponsesBtn');
        const writeAIConfigBtn = document.getElementById('writeAIConfigBtn');

        // Phase 6 CLI elements
        const cliInput = document.getElementById('cliInput');
        const runCliBtn = document.getElementById('runCliBtn');


        /**
         * Logs messages to the output log.
         * @param {string} message The message to log.
         * @param {'info'|'warn'|'error'|'success'} type The type of message.
         */
        function logToOutput(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            let prefix = '';
            let color = '';
            switch (type) {
                case 'warn':
                    prefix = '[WARN]';
                    color = 'text-yellow-400';
                    break;
                case 'error':
                    prefix = '[ERROR]';
                    color = 'text-red-400';
                    break;
                case 'success':
                    prefix = '[SUCCESS]';
                    color = 'text-green-400';
                    break;
                case 'info':
                default:
                    prefix = '[INFO]';
                    color = 'text-gray-300';
                    break;
            }
            outputLog.innerHTML += `<span class="${color}">${timestamp} ${prefix}</span>: ${message}\n`;
            outputLog.scrollTop = outputLog.scrollHeight; // Scroll to bottom
            showStatusMessage(message, type);
        }

        /**
         * Displays a temporary status message in the UI.
         * @param {string} message The message to display.
         * @param {'info'|'warn'|'error'|'success'} type The type of message.
         */
        function showStatusMessage(message, type) {
            statusMessageDiv.textContent = message;
            statusMessageDiv.className = `mt-4 text-center text-sm `;
            switch (type) {
                case 'warn':
                    statusMessageDiv.classList.add('text-yellow-400');
                    break;
                case 'error':
                    statusMessageDiv.classList.add('text-red-400');
                    break;
                case 'success':
                    statusMessageDiv.classList.add('text-green-400');
                    break;
                case 'info':
                default:
                    statusMessageDiv.classList.add('text-gray-300');
                    break;
            }
            setTimeout(() => {
                statusMessageDiv.textContent = '';
                statusMessageDiv.className = `mt-4 text-center text-sm`;
            }, 5000); // Clear message after 5 seconds
        }

        /**
         * Updates the disk usage statistics and current disk ID displayed in the UI.
         */
        function updateStats() {
            const stats = getDiskStats();
            diskIdStatSpan.textContent = stats.diskId;
            usedBytesSpan.textContent = stats.usedBytes;
            availableBytesSpan.textContent = stats.availableBytes;
            totalBytesSpan.textContent = stats.totalBytes;
            freeRowsSpan.textContent = stats.freeRows;
        }

        /**
         * Updates the main title and download button filename to reflect the current disk ID.
         */
        function updateUIForDiskChange() {
            mainTitle.textContent = `PXLDISK File System (Disk: ${currentDiskId})`;
            currentDiskFilenameSpan.textContent = `${currentDiskId}.png`; // Update filename for download
        }

        /**
         * Handles loading a new disk chunk.
         */
        async function loadNewDisk() {
            const selectedDiskId = diskSelect.value;
            if (selectedDiskId === currentDiskId) {
                logToOutput(`Disk ${selectedDiskId} is already loaded.`, 'warn');
                return;
            }
            // In a full implementation, this would load the actual image data for the selected disk.
            // For this simulation, we format a new disk.
            await initDisk(document.getElementById('pxldiskCanvas'), selectedDiskId);
            logToOutput(`Switched to disk: ${currentDiskId}. Disk is now formatted (simulated load).`, 'info');
        }


        // --- Event Listeners (UI Actions) ---
        writeButton.addEventListener('click', async () => {
            const filename = filenameInput.value.trim();
            const content = dataInput.value;
            await writeFile(filename, content);
            dataInput.value = ''; // Clear data input after write attempt
        });

        readButton.addEventListener('click', async () => {
            const filename = filenameInput.value.trim();
            await readFile(filename);
        });

        deleteButton.addEventListener('click', async () => {
            const filename = filenameInput.value.trim();
            await deleteFile(filename);
        });

        listButton.addEventListener('click', async () => {
            await listFiles();
        });

        loadDiskBtn.addEventListener('click', loadNewDisk);

        downloadDiskBtn.addEventListener('click', () => {
            if (!pxldiskCanvas) {
                logToOutput('PXLDISK not initialized. Cannot download.', 'error');
                return;
            }
            const link = document.createElement('a');
            link.href = pxldiskCanvas.toDataURL('image/png');
            link.download = `${currentDiskId}.png`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            logToOutput(`PXLDISK image downloaded as ${currentDiskId}.png.`, 'info');
        });

        // --- Phase 4 Workflow Buttons Event Listeners ---
        writeTasksBtn.addEventListener('click', async () => {
            const content = `Task 1: Process log file.\nTask 2: Generate summary report.\nTask 3: Clean up temp directory.`;
            await writeFile('tasks.txt', content);
        });

        writeResponsesBtn.addEventListener('click', async () => {
            const content = `Timestamp: ${new Date().toISOString()}\nStatus: Tasks completed successfully.\nOutput: Summary report generated.`;
            await writeFile('responses.log', content);
        });

        writeAIConfigBtn.addEventListener('click', async () => {
            const content = `junior_name: Junior\nrole: PXLDISK Assistant\nversion: 1.0.2\nmax_log_size_kb: 512`;
            await writeFile('junior.cfg', content);
        });

        // --- Phase 6 CLI Console Logic ---
        runCliBtn.addEventListener('click', parseAndRunCliCommand);
        cliInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                parseAndRunCliCommand();
            }
        });

        async function parseAndRunCliCommand() {
            const commandLine = cliInput.value.trim();
            cliInput.value = ''; // Clear CLI input after command
            logToOutput(`> ${commandLine}`, 'info');

            const parts = commandLine.split(/\s+/);
            const command = parts[0].toLowerCase();

            if (command === 'list') {
                await listFiles();
            } else if (command === 'read' && parts.length > 1) {
                const filename = parts[1];
                await readFile(filename);
            } else if (command === 'write' && parts.length > 2) {
                const filename = parts[1];
                // Reconstruct content by joining parts after filename, then remove outer quotes
                let content = parts.slice(2).join(' ');
                // Simple regex to remove outer quotes if present
                if (content.startsWith('"') && content.endsWith('"')) {
                    content = content.substring(1, content.length - 1);
                } else if (content.startsWith("'") && content.endsWith("'")) {
                    content = content.substring(1, content.length - 1);
                }
                await writeFile(filename, content);
            } else if (command === 'delete' && parts.length > 1) {
                const filename = parts[1];
                await deleteFile(filename);
            } else if (command === 'help') {
                logToOutput(`Available commands:\n- list: List all files on the current disk.\n- read <filename>: Read the content of a file.\n- write <filename> "<content>": Write content to a file (use quotes for content).\n- delete <filename>: Delete a file.\n- help: Show this help message.`);
            }
            else {
                logToOutput(`Unknown command: '${commandLine}'. Type 'help' for available commands.`, 'error');
            }
        }


        // --- Initialization ---
        window.onload = async () => {
            const canvas = document.getElementById('pxldiskCanvas');
            // Initialize with the default selected disk from the dropdown
            currentDiskId = diskSelect.value;
            await initDisk(canvas, currentDiskId);
            logToOutput('System ready. Try writing a file or using the CLI!', 'info');

            // Optionally write the roadmap on first load if disk is new and confirm dialog is accepted
            const files = await listFiles();
            if (!files.some(f => f.name === 'roadmap.txt')) {
                 const roadmapContent = `PXLDISK_ROADMAP_V1.0\n\nPHASE_0_COMPLETE\n- BASE_CHUNK: 8.png (PXLDISK_000)\n- IMAGE_FORMAT: 256x256 pixels, 1 byte/pixel\n- SCROLL_LAYOUT: Rows 0-8 Directory, Rows 9+ Content\n\nPHASE_1_CORE_FS_MODULE\n- FILE: pxldisk_fs.js\n- GOAL: Basic file ops in-pixel\n- TASKS:\n    - initDisk(canvas): Load/validate header (PXLDISKv1.1)\n    - listFiles(): Read dir rows 1-8, list filenames\n    - writeFile(name, data): Allocate rows, write content\n    - readFile(name): Fetch pixel data by row pointer\n    - deleteFile(name): Clear entry + zero rows\n    - updateFile(name, newData): Overwrite/reallocate\n    - Handle row overflow (max 247 rows)\n\nPHASE_2_FS_UI_HTML\n- GOAL: Add GUI to pixelnet_mesh_gl.html\n- TASKS:\n    - UI_PANEL: Filename input\n    - Data input area (textarea)\n    - BUTTONS: Write, Read, Delete, List\n    - Output log to show file contents\n    - Track file usage stats (bytes used / available)\n\nPHASE_3_EXPANSION_SCALING\n- GOAL: Support multi-disk chunking and larger files\n- TASKS:\n    - Auto-link to PXLDISK_001.png, PXLDISK_002.png etc.\n    - Superblock file to track available disks\n    - Chain files across disks if needed (simulated for large files)\n    - Index scrolls by task ID or namespace (conceptual)\n\nPHASE_4_SCROLL_INTEGRATION\n- GOAL: Use filesystem for real Mesh workflows\n- TASKS:\n    - Store task scrolls in tasks.txt (via button)\n    - Write responses to responses.log (via button)\n    - Save AI config as junior.cfg (via button)\n    - Create autorun.sh-style pixel scripts (conceptual - implies writing scripts to disk)\n\nPHASE_5_SECURITY_ERROR_HANDLING\n- GOAL: Prevent data loss and bugs\n- TASKS:\n    - Check for name collisions (implemented)\n    - Confirm block limits before writing (implemented)\n    - Add checksum or magic byte to each file row (implemented)\n\nPHASE_6_PXLDISK_TOOLS_REPLICATION\n- GOAL: Port file system across deployments\n- TASKS:\n    - Embed pxldisk_fs.js in all relevant HTML tools (achieved by inlining)\n    - Build CLI-style functions in JavaScript (implemented CLI console)\n    - Add autoExport() to download updated disk (implemented download button)\n    - Document API for other AIs (code comments and PXLDISK_FS object)`;

                // Use a non-blocking confirmation for better UX than traditional alert/confirm
                if (confirm('Roadmap.txt not found on this disk. Would you like to write the PXLDISK roadmap to disk now?')) {
                    await writeFile('roadmap.txt', roadmapContent);
                }
            }
        };
    </script>
</body>
</html>



