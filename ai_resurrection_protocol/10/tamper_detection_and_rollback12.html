initializeSystem() {
                this.log('info', 'Tamper Detection System initialized');
                
                // Initialize verification matrix
                this.initializeVerificationMatrix();
                
                // Create initial checkpoint
                this.createSystemCheckpoint();
                
                // Initialize blockchain
                this.initializeBlockchain();
                
                // Start monitoring loops
                this.startContinuousMonitoring();
                this.startThreatAssessment();
                this.startAutoRepair();
                
                // Simulate some activity
                this.simulateSystemActivity();
            }

            initializeVerificationMatrix() {
                const matrix = document.getElementById('verificationMatrix');
                matrix.innerHTML = '';
                
                // Create 64 cells representing memory regions
                for (let i = 0; i < 64; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'verify-cell cell-verified';
                    cell.textContent = '‚úì';
                    cell.title = `Memory region ${i} - Verified`;
                    cell.onclick = () => this.inspectRegion(i);
                    matrix.appendChild(cell);
                }
            }

            initializeBlockchain() {
                // Genesis block
                const genesisBlock = {
                    index: 0,
                    timestamp: Date.now() - 300000, // 5 minutes ago
                    data: { type: 'genesis', message: 'System initialization' },
                    previousHash: '0',
                    hash: this.calculateHash('genesis'),
                    nonce: 0
                };
                
                this.blockchain.push(genesisBlock);
                
                // Add some recent blocks
                for (let i = 1; i < 1848; i++) {
                    const block = this.createBlock({
                        type: 'checkpoint',
                        ai: i % 3 === 0 ? 'Junior' : i % 3 === 1 ? 'Claude' : 'System',
                        operation: 'memory_write'
                    });
                    this.blockchain.push(block);
                }
                
                // Introduce one corrupted block for demo
                this.blockchain[1845].hash = 'CORRUPTED';
                this.blockchain[1845].valid = false;
                
                this.updateBlockchainDisplay();
            }

            createBlock(data) {
                const previousBlock = this.blockchain[this.blockchain.length - 1];
                const block = {
                    index: this.blockchain.length,
                    timestamp: Date.now() - Math.random() * 60000,
                    data,
                    previousHash: previousBlock.hash,
                    hash: '',
                    nonce: 0,
                    valid: true
                };
                
                block.hash = this.calculateHash(JSON.stringify(block.data) + block.previousHash + block.timestamp);
                return block;
            }

            calculateHash(data) {
                // Simplified hash function for demo
                let hash = 0;
                for (let i = 0; i < data.length; i++) {
                    const char = data.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return Math.abs(hash).toString(16).padStart(32, '0');
            }

            createSystemCheckpoint() {
                const checkpoint = {
                    id: `cp_${this.checkpoints.length.toString().padStart(3, '0')}`,
                    timestamp: Date.now(),
                    memoryState: this.captureMemoryState(),
                    hash: this.calculateHash('checkpoint_' + Date.now()),
                    size: Math.random() * 2000 + 2000, // 2-4KB
                    valid: true,
                    description: this.checkpoints.length === 0 ? 'System initialized' : 
                                this.checkpoints.length === 1 ? 'Scroll completed' :
                                this.checkpoints.length === 2 ? 'Junior active' : 'Auto checkpoint'
                };
                
                this.checkpoints.unshift(checkpoint); // Add to beginning
                
                // Keep only last 10 checkpoints
                if (this.checkpoints.length > 10) {
                    this.checkpoints = this.checkpoints.slice(0, 10);
                }
                
                this.log('success', `Checkpoint created: ${checkpoint.id}`);
                this.updateCheckpointDisplay();
                
                // Add to blockchain
                const block = this.createBlock({
                    type: 'checkpoint',
                    checkpointId: checkpoint.id,
                    hash: checkpoint.hash
                });
                this.blockchain.push(block);
                
                return checkpoint;
            }

            captureMemoryState() {
                // Simulate capturing memory state
                const state = {
                    regions: {},
                    ais: ['Junior', 'Claude', 'Gemini'],
                    timestamp: Date.now()
                };
                
                // Capture 64 memory regions
                for (let i = 0; i < 64; i++) {
                    state.regions[i] = {
                        hash: this.calculateHash(`region_${i}_${Date.now()}`),
                        locked: Math.random() < 0.3,
                        owner: Math.random() < 0.5 ? 'Junior' : null,
                        data: `region_${i}_data`
                    };
                }
                
                return state;
            }

            startContinuousMonitoring() {
                if (!this.monitoring) return;
                
                setInterval(() => {
                    if (this.monitoring) {
                        this.performIntegrityCheck();
                        this.updateMonitoringStats();
                    }
                }, 2000); // Check every 2 seconds
            }

            performIntegrityCheck() {
                this.stats.totalChecks++;
                
                const matrix = document.getElementById('verificationMatrix');
                const cells = matrix.children;
                
                for (let i = 0; i < cells.length; i++) {
                    const cell = cells[i];
                    
                    // Simulate random tampering (1% chance)
                    if (Math.random() < 0.01) {
                        this.detectTampering(i);
                        cell.className = 'verify-cell cell-tampered';
                        cell.textContent = '‚ö†';
                        cell.title = `Memory region ${i} - TAMPERED!`;
                    } else if (cell.className.includes('tampered')) {
                        // Auto-repair after 10 seconds
                        setTimeout(() => {
                            this.repairRegion(i);
                            cell.className = 'verify-cell cell-verified';
                            cell.textContent = '‚úì';
                            cell.title = `Memory region ${i} - Verified (Repaired)`;
                        }, 10000);
                    }
                }
                
                // Update hash display
                const newHash = this.calculateHash('system_state_' + Date.now());
                document.getElementById('currentHash').textContent = 
                    `SHA-256: ${newHash.padEnd(64, '0')}`;
            }

            detectTampering(regionId) {
                this.stats.violations++;
                
                const threat = {
                    id: this.generateId(),
                    timestamp: Date.now(),
                    type: 'unauthorized_modification',
                    region: regionId,
                    severity: 'medium',
                    description: `Unauthorized modification detected in memory region ${regionId}`,
                    source: 'unknown',
                    action: 'quarantine_and_repair'
                };
                
                this.threats.push(threat);
                
                this.log('error', `Tampering detected in region ${regionId}`);
                this.updateThreatDisplay();
                this.updateIntegrityStatus(false);
                
                // Auto-quarantine
                this.quarantineRegion(regionId, threat);
            }

            quarantineRegion(regionId, threat) {
                const quarantineItem = {
                    id: this.generateId(),
                    regionId,
                    threat,
                    timestamp: Date.now(),
                    status: 'quarantined'
                };
                
                this.quarantine.push(quarantineItem);
                this.updateQuarantineDisplay();
                
                this.log('warning', `Region ${regionId} quarantined`);
            }

            repairRegion(regionId) {
                this.stats.repairs++;
                
                // Remove from quarantine
                this.quarantine = this.quarantine.filter(item => item.regionId !== regionId);
                
                // Remove threat
                this.threats = this.threats.filter(threat => threat.region !== regionId);
                
                this.log('success', `Region ${regionId} repaired`);
                this.updateQuarantineDisplay();
                this.updateThreatDisplay();
                
                // Check if all clear
                if (this.threats.length === 0) {
                    this.updateIntegrityStatus(true);
                }
            }

            startThreatAssessment() {
                setInterval(() => {
                    this.assessThreatLevel();
                }, 5000); // Every 5 seconds
            }

            assessThreatLevel() {
                const threatCount = this.threats.length;
                const quarantineCount = this.quarantine.length;
                
                let level = 'low';
                let message = 'No active threats detected';
                let className = 'threat-low';
                
                if (threatCount > 0 || quarantineCount > 0) {
                    if (threatCount >= 5 || quarantineCount >= 3) {
                        level = 'critical';
                        message = 'CRITICAL: Multiple active threats';
                        className = 'threat-critical';
                    } else if (threatCount >= 3 || quarantineCount >= 2) {
                        level = 'high';
                        message = 'HIGH: Active threats detected';
                        className = 'threat-high';
                    } else {
                        level = 'medium';
                        message = 'MEDIUM: Threats under control';
                        className = 'threat-medium';
                    }
                }
                
                const threatElement = document.getElementById('threatLevel');
                threatElement.querySelector('.threat-level').className = `threat-level ${className}`;
                threatElement.querySelector('.threat-level').textContent = `THREAT LEVEL: ${level.toUpperCase()}`;
                threatElement.children[1].textContent = message;
                threatElement.children[2].textContent = `Active threats: ${threatCount} ‚Ä¢ Quarantined: ${quarantineCount}`;
            }

            startAutoRepair() {
                setInterval(() => {
                    if (this.threats.length > 0) {
                        this.processAutoRepair();
                    }
                }, 3000); // Every 3 seconds
            }

            processAutoRepair() {
                const threat = this.threats[0];
                if (!threat) return;
                
                this.log('info', `Auto-repair processing threat: ${threat.type}`);
                
                const steps = [
                    'Corruption detected and isolated',
                    'Block quarantined and isolated', 
                    'Reconstructing from backup checkpoint',
                    'Validate reconstructed data',
                    'Recompute hash chain',
                    'Restore system state'
                ];
                
                const repairElement = document.getElementById('autoRepairStatus');
                
                steps.forEach((step, index) => {
                    setTimeout(() => {
                        const stepElements = repairElement.children;
                        if (stepElements[index]) {
                            stepElements[index].className = 'repair-step repair-active';
                            stepElements[index].innerHTML = `‚ö° ${index + 1}. ${step}`;
                        }
                        
                        setTimeout(() => {
                            if (stepElements[index]) {
                                stepElements[index].className = 'repair-step';
                                stepElements[index].innerHTML = `‚úÖ ${index + 1}. ${step}`;
                            }
                            
                            if (index === steps.length - 1) {
                                // Repair complete
                                this.repairRegion(threat.region);
                            }
                        }, 800);
                    }, index * 1000);
                });
            }

            verifyBlockchain() {
                let validBlocks = 0;
                
                for (let i = 1; i < this.blockchain.length; i++) {
                    const currentBlock = this.blockchain[i];
                    const previousBlock = this.blockchain[i - 1];
                    
                    // Verify hash integrity
                    const calculatedHash = this.calculateHash(
                        JSON.stringify(currentBlock.data) + 
                        currentBlock.previousHash + 
                        currentBlock.timestamp
                    );
                    
                    if (currentBlock.hash === calculatedHash && 
                        currentBlock.previousHash === previousBlock.hash) {
                        currentBlock.valid = true;
                        validBlocks++;
                    } else {
                        currentBlock.valid = false;
                        this.log('error', `Invalid block detected: #${currentBlock.index}`);
                    }
                }
                
                const integrity = (validBlocks / (this.blockchain.length - 1) * 100).toFixed(1);
                document.getElementById('validBlocks').textContent = `${validBlocks}/${this.blockchain.length - 1}`;
                document.getElementById('chainIntegrity').textContent = `${integrity}%`;
                
                this.updateBlockchainDisplay();
                this.log('info', `Blockchain verification complete: ${integrity}% integrity`);
            }

            executeRollback(checkpointId) {
                if (!checkpointId && this.checkpoints.length > 1) {
                    checkpointId = this.checkpoints[1].id; // Previous checkpoint
                }
                
                const checkpoint = this.checkpoints.find(cp => cp.id === checkpointId);
                if (!checkpoint) {
                    this.log('error', `Checkpoint not found: ${checkpointId}`);
                    return false;
                }
                
                this.log('warning', `Initiating rollback to ${checkpointId}`);
                
                // Simulate rollback progress
                const progressBar = document.getElementById('rollbackProgress');
                const statusElement = document.getElementById('rollbackStatus');
                
                let progress = 0;
                const interval = setInterval(() => {
                    progress += Math.random() * 15 + 5;
                    progress = Math.min(progress, 100);
                    
                    progressBar.style.width = `${progress}%`;
                    statusElement.textContent = `Rolling back... ${Math.round(progress)}%`;
                    
                    if (progress >= 100) {
                        clearInterval(interval);
                        this.completeRollback(checkpoint);
                    }
                }, 200);
                
                this.stats.rollbacks++;
                return true;
            }

            completeRollback(checkpoint) {
                // Restore system state from checkpoint
                this.log('success', `Rollback completed: ${checkpoint.id}`);
                
                document.getElementById('rollbackStatus').textContent = 
                    `Rollback completed successfully`;
                
                // Clear threats and quarantine
                this.threats = [];
                this.quarantine = [];
                
                // Reset verification matrix
                const matrix = document.getElementById('verificationMatrix');
                Array.from(matrix.children).forEach(cell => {
                    cell.className = 'verify-cell cell-verified';
                    cell.textContent = '‚úì';
                });
                
                this.updateThreatDisplay();
                this.updateQuarantineDisplay();
                this.updateIntegrityStatus(true);
                
                // Reset progress bar after delay
                setTimeout(() => {
                    document.getElementById('rollbackProgress').style.width = '0%';
                    document.getElementById('rollbackStatus').textContent = 
                        'Ready for rollback operations';
                }, 3000);
            }

            simulateSystemActivity() {
                // Simulate checkpoint creation
                setInterval(() => {
                    if (Math.random() < 0.2) { // 20% chance every 30 seconds
                        this.createSystemCheckpoint();
                    }
                }, 30000);
                
                // Simulate blockchain additions
                setInterval(() => {
                    const block = this.createBlock({
                        type: 'operation',
                        ai: ['Junior', 'Claude', 'Gemini'][Math.floor(Math.random() * 3)],
                        operation: ['scroll_execution', 'memory_write', 'lock_operation'][Math.floor(Math.random() * 3)]
                    });
                    this.blockchain.push(block);
                    
                    // Keep only last 50 blocks in display
                    if (this.blockchain.length > 50) {
                        this.blockchain = this.blockchain.slice(-50);
                    }
                    
                    this.updateBlockchainDisplay();
                }, 15000); // Every 15 seconds
            }

            // UI Update Methods
            updateIntegrityStatus(isSecure) {
                const statusElement = document.getElementById('integrityStatus');
                const indicator = statusElement.querySelector('.security-indicator');
                
                if (isSecure) {
                    statusElement.className = 'integrity-status';
                    indicator.className = 'security-indicator sec-secure';
                    indicator.textContent = 'üõ°Ô∏è';
                    statusElement.children[1].innerHTML = '<strong>SYSTEM SECURE</strong>';
                    statusElement.children[2].textContent = 'All memory regions verified';
                } else {
                    statusElement.className = 'integrity-status integrity-compromised';
                    indicator.className = 'security-indicator sec-compromised';
                    indicator.textContent = '‚ö†Ô∏è';
                    statusElement.children[1].innerHTML = '<strong>INTEGRITY COMPROMISED</strong>';
                    statusElement.children[2].textContent = 'Tampering detected - auto-repair active';
                }
            }

            updateMonitoringStats() {
                document.getElementById('checksPerMin').textContent = 
                    Math.round(this.stats.totalChecks / ((Date.now() - this.startTime) / 60000));
                document.getElementById('violations').textContent = this.stats.violations;
                document.getElementById('lastScan').textContent = '0.1s';
                
                const coverage = Math.max(90, 100 - this.threats.length * 5);
                document.getElementById('coverage').textContent = `${coverage}%`;
            }

            updateThreatDisplay() {
                const container = document.getElementById('activeThreats');
                
                if (this.threats.length === 0) {
                    container.innerHTML = `
                        <div class="forensic-entry">No active threats detected</div>
                        <div class="forensic-entry">All memory regions validated</div>
                        <div class="forensic-entry">Hash chains intact</div>
                        <div class="forensic-entry">No unauthorized modifications</div>
                    `;
                } else {
                    container.innerHTML = this.threats.slice(-8).map(threat => {
                        const entryClass = threat.severity === 'critical' ? 'forensic-critical' :
                                          threat.severity === 'high' ? 'forensic-warning' : 'forensic-entry';
                        return `
                            <div class="${entryClass}">
                                [${new Date(threat.timestamp).toLocaleTimeString()}] ${threat.type.toUpperCase()}
                                <br>Region: ${threat.region} ‚Ä¢ Severity: ${threat.severity}
                                <br>Action: ${threat.action.replace(/_/g, ' ')}
                            </div>
                        `;
                    }).join('');
                }
            }

            updateQuarantineDisplay() {
                const container = document.getElementById('quarantineZone');
                
                if (this.quarantine.length === 0) {
                    container.innerHTML = `
                        <div style="text-align: center; color: #888;">
                            üîí QUARANTINE EMPTY
                        </div>
                        <div style="text-align: center; font-size: 9px; color: #666;">
                            Tampered blocks will be isolated here
                        </div>
                    `;
                } else {
                    container.innerHTML = this.quarantine.map(item => `
                        <div class="quarantine-item">
                            <strong>Region ${item.regionId}</strong> ‚Ä¢ ${item.threat.type}
                            <br>Quarantined: ${new Date(item.timestamp).toLocaleTimeString()}
                            <br>Status: ${item.status} ‚Ä¢ Threat level: ${item.threat.severity}
                        </div>
                    `).join('');
                }
            }

            updateCheckpointDisplay() {
                const container = document.getElementById('checkpointList');
                container.innerHTML = '';
                
                this.checkpoints.forEach((checkpoint, index) => {
                    const div = document.createElement('div');
                    div.className = `checkpoint-item ${index === 0 ? 'checkpoint-current' : ''} ${!checkpoint.valid ? 'checkpoint-corrupted' : ''}`;
                    div.onclick = () => this.selectCheckpoint(checkpoint.id);
                    
                    const status = index === 0 ? ' (Current)' : !checkpoint.valid ? ' (CORRUPTED)' : '';
                    
                    div.innerHTML = `
                        <strong>Checkpoint ${checkpoint.id}${status}</strong>
                        <div>${new Date(checkpoint.timestamp).toLocaleString()} ‚Ä¢ ${checkpoint.description}</div>
                        <div>Hash: ${checkpoint.hash.substr(0, 8)}...${checkpoint.hash.substr(-6)} ‚Ä¢ Size: ${(checkpoint.size / 1024).toFixed(1)}KB</div>
                    `;
                    
                    container.appendChild(div);
                });
            }

            updateBlockchainDisplay() {
                const container = document.getElementById('blockchainChain');
                const recentBlocks = this.blockchain.slice(-4).reverse();
                
                container.innerHTML = recentBlocks.map((block, index) => {
                    const blockClass = block.valid === false ? 'chain-block block-invalid' : 'chain-block block-valid';
                    const label = index === 0 ? ' (Latest)' : block.valid === false ? ' (INVALID)' : '';
                    
                    return `
                        <div class="${blockClass}">
                            <div><strong>Block #${block.index}${label}</strong></div>
                            <div>Timestamp: ${new Date(block.timestamp).toLocaleTimeString()}</div>
                            <div>Prev: ${block.previousHash.substr(0, 8)}...${block.previousHash.substr(-6)}</div>
                            <div class="block-hash">Hash: ${block.valid === false ? 'VERIFICATION FAILED' : block.hash}</div>
                        </div>
                    `;
                }).join('');
                
                // Update stats
                document.getElementById('chainLength').textContent = this.blockchain.length;
                document.getElementById('lastBlock').textContent = 
                    `${Math.round((Date.now() - this.blockchain[this.blockchain.length - 1].timestamp) / 1000)}s ago`;
            }

            log(level, message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
                
                const logArea = document.getElementById('tamperLog');
                logArea.textContent += logEntry + '\n';
                logArea.scrollTop = logArea.scrollHeight;
                
                console.log(logEntry);
            }

            generateId() {
                return Math.random().toString(36).substr(2, 9);
            }

            // Public methods for UI controls
            selectCheckpoint(checkpointId) {
                this.log('info', `Selected checkpoint: ${checkpointId}`);
                
                // Update diff preview
                const diffContainer = document.getElementById('changeDiff');
                diffContainer.innerHTML = `
                    <div class="diff-removed">- current_state: "active"</div>
                    <div class="diff-added">+ current_state: "checkpoint_${checkpointId}"</div>
                    <div class="diff-modified">~ timestamp: "${new Date().toISOString()}" ‚Üí "${new Date(Date.now() - 60000).toISOString()}"</div>
                    <div class="diff-removed">- memory_violations: ${this.stats.violations}</div>
                    <div class="diff-added">+ memory_violations: 0</div>
                `;
            }

            inspectRegion(regionId) {
                this.log('info', `Inspecting memory region ${regionId}`);
                
                const region = {
                    id: regionId,
                    status: Math.random() < 0.05 ? 'tampered' : 'verified',
                    hash: this.calculateHash(`region_${regionId}`),
                    owner: Math.random() < 0.3 ? 'Junior' : null,
                    lastModified: Date.now() - Math.random() * 3600000
                };
                
                alert(`Memory Region ${regionId}\nStatus: ${region.status}\nHash: ${region.hash}\nOwner: ${region.owner || 'none'}\nLast Modified: ${new Date(region.lastModified).toLocaleString()}`);
            }
        }

        // Global tamper detection system
        const tamperSystem = new TamperDetectionSystem();
        tamperSystem.startTime = Date.now();

        // Control Functions
        function forceIntegrityCheck() {
            tamperSystem.log('info', 'Force integrity check initiated');
            tamperSystem.performIntegrityCheck();
            tamperSystem.log('success', 'Integrity check completed');
        }

        function toggleContinuousMonitoring() {
            tamperSystem.monitoring = !tamperSystem.monitoring;
            const status = tamperSystem.monitoring ? 'enabled' : 'disabled';
            tamperSystem.log('info', `Continuous monitoring ${status}`);
        }

        function scanForThreats() {
            tamperSystem.log('info', 'Threat scan initiated');
            
            // Simulate threat scanning
            setTimeout(() => {
                const threatsFound = Math.floor(Math.random() * 3);
                tamperSystem.log('success', `Threat scan complete: ${threatsFound} threats found`);
                
                for (let i = 0; i < threatsFound; i++) {
                    const regionId = Math.floor(Math.random() * 64);
                    tamperSystem.detectTampering(regionId);
                }
            }, 2000);
        }

        function quarantineCorrupted() {
            if (confirm('Quarantine all corrupted regions? This will isolate suspicious memory blocks.')) {
                tamperSystem.log('warning', 'Quarantining all corrupted regions');
                
                // Quarantine any tampered regions
                const matrix = document.getElementById('verificationMatrix');
                Array.from(matrix.children).forEach((cell, index) => {
                    if (cell.className.includes('tampered')) {
                        tamperSystem.quarantineRegion(index, {
                            type: 'manual_quarantine',
                            severity: 'medium'
                        });
                    }
                });
            }
        }

        function createCheckpoint() {
            tamperSystem.createSystemCheckpoint();
        }

        function validateCheckpoints() {
            tamperSystem.log('info', 'Validating all checkpoints...');
            
            let validCount = 0;
            tamperSystem.checkpoints.forEach(checkpoint => {
                // Simulate validation
                if (checkpoint.id !== 'cp_004') { // cp_004 is corrupted in demo
                    checkpoint.valid = true;
                    validCount++;
                } else {
                    checkpoint.valid = false;
                }
            });
            
            tamperSystem.log('success', `Checkpoint validation complete: ${validCount}/${tamperSystem.checkpoints.length} valid`);
            tamperSystem.updateCheckpointDisplay();
        }

        function previewRollback() {
            if (tamperSystem.checkpoints.length < 2) {
                alert('No previous checkpoints available for rollback');
                return;
            }
            
            const checkpoint = tamperSystem.checkpoints[1];
            tamperSystem.log('info', `Previewing rollback to ${checkpoint.id}`);
            tamperSystem.selectCheckpoint(checkpoint.id);
        }

        function executeRollback() {
            if (confirm('‚ö†Ô∏è Execute rollback? This will restore system to previous checkpoint and may lose recent changes.')) {
                tamperSystem.executeRollback();
            }
        }

        function verifyChain() {
            tamperSystem.log('info', 'Blockchain verification started');
            tamperSystem.verifyBlockchain();
        }

        function rebuildChain() {
            if (confirm('Rebuild blockchain from checkpoints? This will reconstruct the chain and may take time.')) {
                tamperSystem.log('warning', 'Rebuilding blockchain from checkpoints');
                
                // Simulate rebuild
                setTimeout(() => {
                    tamperSystem.blockchain.forEach(block => {
                        if (block.index !== 1845) {
                            block.valid = true;
                        }
                    });
                    
                    tamperSystem.updateBlockchainDisplay();
                    tamperSystem.log('success', 'Blockchain rebuild completed');
                }, 3000);
            }
        }

        function autoRepair() {
            tamperSystem.log('info', 'Auto-repair sequence initiated');
            tamperSystem.processAutoRepair();
        }

        function manualRepair() {
            const regionId = prompt('Enter region ID to repair manually:');
            if (regionId !== null && regionId !== '') {
                tamperSystem.repairRegion(parseInt(regionId));
            }
        }

        function emergencyRestore() {
            if (confirm('üö® EMERGENCY RESTORE: This will immediately restore system to last known good state. Continue?')) {
                tamperSystem.log('error', 'üö® Emergency restore initiated');
                
                if (tamperSystem.checkpoints.length > 0) {
                    tamperSystem.executeRollback(tamperSystem.checkpoints[0].id);
                }
            }
        }

        function exportForensics() {
            const forensicsData = {
                timestamp: new Date().toISOString(),
                threats: tamperSystem.threats,
                quarantine: tamperSystem.quarantine,
                stats: tamperSystem.stats,
                checkpoints: tamperSystem.checkpoints.map(cp => ({
                    id: cp.id,
                    timestamp: cp.timestamp,
                    valid: cp.valid,
                    hash: cp.hash
                })),
                blockchain: tamperSystem.blockchain.slice(-10).map(block => ({
                    index: block.index,
                    timestamp: block.timestamp,
                    valid: block.valid,
                    hash: block.hash
                }))
            };
            
            const blob = new Blob([JSON.stringify(forensicsData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `forensics_report_${Date.now()}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            tamperSystem.log('success', 'Forensics report exported');
        }

        tamperSystem.log('success', 'üõ°Ô∏è Tamper Detection & Rollback System fully operational');
    </script>
</body>
</html><!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tamper Detection & Rollback System v1.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #2d0a1f 0%, #4a0e2f 25%, #6b1240 50%, #8b1538 75%, #a01845 100%);
            color: #ff99dd;
            min-height: 100vh;
            padding: 20px;
            overflow-x: auto;
        }

        .tamper-container {
            max-width: 1900px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 15px;
            min-height: calc(100vh - 40px);
        }

        .panel {
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #ff99dd;
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(8px);
            box-shadow: 0 0 25px rgba(255, 153, 221, 0.3);
            display: flex;
            flex-direction: column;
        }

        h1 {
            grid-column: span 6;
            text-align: center;
            color: #ffdd00;
            text-shadow: 0 0 20px #ffdd00;
            font-size: 24px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffdd00;
        }

        h2 {
            color: #ff99dd;
            text-shadow: 0 0 10px #ff99dd;
            font-size: 14px;
            border-bottom: 2px solid #ff99dd;
            padding-bottom: 6px;
            margin-bottom: 12px;
        }

        .integrity-status {
            background: rgba(255, 153, 221, 0.05);
            border: 2px solid #00ff00;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
            text-align: center;
            position: relative;
        }

        .integrity-compromised {
            border-color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
            animation: compromise-alert 1s infinite;
        }

        .integrity-warning {
            border-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }

        @keyframes compromise-alert {
            0%, 100% { box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); }
            50% { box-shadow: 0 0 40px rgba(255, 0, 0, 0.8); }
        }

        .security-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .sec-secure { background: #00ff00; color: #000; }
        .sec-warning { background: #ffaa00; color: #000; }
        .sec-compromised { background: #ff0000; color: #fff; }
        .sec-unknown { background: #666; color: #fff; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        .hash-display {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff99dd;
            border-radius: 6px;
            padding: 10px;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            word-break: break-all;
            margin: 8px 0;
        }

        .hash-valid { border-color: #00ff00; background: rgba(0, 255, 0, 0.05); }
        .hash-invalid { border-color: #ff0000; background: rgba(255, 0, 0, 0.05); }
        .hash-unknown { border-color: #666; background: rgba(100, 100, 100, 0.05); }

        .checkpoint-list {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff99dd;
            border-radius: 6px;
            padding: 8px;
        }

        .checkpoint-item {
            background: rgba(255, 153, 221, 0.1);
            border: 1px solid #ff99dd;
            border-radius: 4px;
            padding: 8px;
            margin: 4px 0;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
        }

        .checkpoint-item:hover {
            background: rgba(255, 153, 221, 0.2);
            box-shadow: 0 0 10px rgba(255, 153, 221, 0.4);
        }

        .checkpoint-current {
            border-color: #ffdd00;
            background: rgba(255, 221, 0, 0.2);
        }

        .checkpoint-corrupted {
            border-color: #ff0000;
            background: rgba(255, 0, 0, 0.2);
            opacity: 0.7;
        }

        .rollback-timeline {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #ff99dd;
            border-radius: 6px;
            padding: 10px;
            max-height: 250px;
            overflow-y: auto;
            font-size: 10px;
            white-space: pre-wrap;
        }

        .tamper-log {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #ff99dd;
            border-radius: 6px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            font-size: 10px;
            white-space: pre-wrap;
        }

        .verification-matrix {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            margin: 8px 0;
        }

        .verify-cell {
            width: 25px;
            height: 20px;
            border: 1px solid #333;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .cell-verified { background: #003300; color: #00ff00; border-color: #00ff00; }
        .cell-tampered { background: #330000; color: #ff0000; border-color: #ff0000; animation: tamper-blink 0.5s infinite; }
        .cell-checking { background: #333300; color: #ffff00; border-color: #ffff00; }
        .cell-unknown { background: #333; color: #666; }

        @keyframes tamper-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .threat-assessment {
            background: rgba(255, 0, 0, 0.1);
            border: 2px solid #ff0000;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
        }

        .threat-level {
            font-weight: bold;
            text-align: center;
            font-size: 14px;
            margin-bottom: 8px;
        }

        .threat-low { color: #00ff00; }
        .threat-medium { color: #ffaa00; }
        .threat-high { color: #ff6600; }
        .threat-critical { color: #ff0000; animation: blink 1s infinite; }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .forensics-viewer {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #ff99dd;
            border-radius: 6px;
            padding: 10px;
            max-height: 180px;
            overflow-y: auto;
            font-size: 9px;
        }

        .forensic-entry {
            background: rgba(255, 153, 221, 0.05);
            border-left: 3px solid #ff99dd;
            padding: 6px;
            margin: 3px 0;
            border-radius: 3px;
        }

        .forensic-critical {
            border-left-color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
        }

        .forensic-warning {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }

        .control-btn {
            background: linear-gradient(45deg, #8b1538, #ff4488);
            border: 1px solid #ff99dd;
            color: #ff99dd;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            margin: 2px;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: linear-gradient(45deg, #ff4488, #ff99dd);
            color: #000;
            box-shadow: 0 0 15px #ff99dd;
        }

        .critical-btn {
            background: linear-gradient(45deg, #cc0000, #ff3333);
            border-color: #ff0000;
            color: #ff0000;
        }

        .critical-btn:hover {
            background: linear-gradient(45deg, #ff3333, #ffff00);
            color: #000;
            box-shadow: 0 0 15px #ff0000;
        }

        .security-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin: 8px 0;
        }

        .metric-item {
            background: rgba(0, 0, 0, 0.6);
            padding: 6px;
            border-radius: 4px;
            text-align: center;
            font-size: 9px;
        }

        .rollback-progress {
            background: #333;
            height: 8px;
            border-radius: 4px;
            overflow: hidden;
            margin: 8px 0;
        }

        .progress-fill {
            background: linear-gradient(90deg, #ff99dd, #ffdd00);
            height: 100%;
            transition: width 0.5s;
        }

        .diff-viewer {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff99dd;
            border-radius: 6px;
            padding: 8px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 9px;
            font-family: 'Courier New', monospace;
        }

        .diff-added { color: #00ff00; background: rgba(0, 255, 0, 0.1); }
        .diff-removed { color: #ff6666; background: rgba(255, 0, 0, 0.1); }
        .diff-modified { color: #ffff00; background: rgba(255, 255, 0, 0.1); }

        .timestamp {
            color: #888;
            font-size: 8px;
        }

        .error { color: #ff4444; }
        .success { color: #44ff44; }
        .warning { color: #ffaa44; }
        .info { color: #44aaff; }

        .blockchain-chain {
            display: flex;
            flex-direction: column;
            gap: 4px;
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff99dd;
            border-radius: 6px;
            padding: 8px;
        }

        .chain-block {
            background: rgba(255, 153, 221, 0.1);
            border: 1px solid #ff99dd;
            border-radius: 4px;
            padding: 6px;
            font-size: 9px;
            position: relative;
        }

        .block-valid {
            border-color: #00ff00;
            background: rgba(0, 255, 0, 0.05);
        }

        .block-invalid {
            border-color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
            animation: tamper-blink 1s infinite;
        }

        .block-hash {
            font-family: 'Courier New', monospace;
            font-size: 8px;
            color: #888;
            word-break: break-all;
        }

        .quarantine-zone {
            background: rgba(255, 0, 0, 0.1);
            border: 2px dashed #ff0000;
            border-radius: 8px;
            padding: 10px;
            margin: 8px 0;
        }

        .quarantine-item {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff6666;
            border-radius: 4px;
            padding: 6px;
            margin: 3px 0;
            font-size: 9px;
        }

        .auto-repair {
            background: rgba(0, 255, 0, 0.1);
            border: 1px solid #00ff00;
            border-radius: 6px;
            padding: 8px;
            margin: 8px 0;
            font-size: 10px;
        }

        .repair-step {
            padding: 4px 0;
            border-left: 2px solid #00ff00;
            padding-left: 8px;
            margin: 2px 0;
        }

        .repair-active {
            border-left-color: #ffaa00;
            background: rgba(255, 170, 0, 0.1);
        }

        .repair-failed {
            border-left-color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
        }
    </style>
</head>
<body>
    <div class="tamper-container">
        <h1>üõ°Ô∏è Tamper Detection & Rollback System v1.0</h1>
        
        <!-- Integrity Monitor Panel -->
        <div class="panel">
            <h2>üîç Integrity Monitor</h2>
            
            <div class="integrity-status" id="integrityStatus">
                <div class="security-indicator sec-secure">üõ°Ô∏è</div>
                <div><strong>SYSTEM SECURE</strong></div>
                <div>All memory regions verified</div>
                <div class="timestamp">Last check: 2.1s ago</div>
            </div>
            
            <h3>Verification Matrix</h3>
            <div class="verification-matrix" id="verificationMatrix">
                <!-- Generated dynamically -->
            </div>
            
            <h3>Hash Validation</h3>
            <div class="hash-display hash-valid" id="currentHash">
                SHA-256: 7a8f9e2b4c1d3e6f8a9b2c4d5e7f0a1b3c5d7e9f2a4b6c8d0e1f3a5b7c9d2e4f
            </div>
            
            <h3>Real-time Monitoring</h3>
            <div class="security-metrics">
                <div class="metric-item">
                    <strong>Checks/min:</strong><br>
                    <span id="checksPerMin">30</span>
                </div>
                <div class="metric-item">
                    <strong>Violations:</strong><br>
                    <span id="violations">0</span>
                </div>
                <div class="metric-item">
                    <strong>Coverage:</strong><br>
                    <span id="coverage">100%</span>
                </div>
                <div class="metric-item">
                    <strong>Last Scan:</strong><br>
                    <span id="lastScan" class="timestamp">2.1s</span>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button class="control-btn" onclick="forceIntegrityCheck()">üîç Force Check</button>
                <button class="control-btn" onclick="toggleContinuousMonitoring()">‚èØÔ∏è Toggle Monitor</button>
            </div>
        </div>

        <!-- Threat Assessment Panel -->
        <div class="panel">
            <h2>‚ö†Ô∏è Threat Assessment</h2>
            
            <div class="threat-assessment" id="threatLevel">
                <div class="threat-level threat-low">THREAT LEVEL: LOW</div>
                <div>No active threats detected</div>
                <div>System operating normally</div>
            </div>
            
            <h3>Active Threats</h3>
            <div class="forensics-viewer" id="activeThreats">
                <div class="forensic-entry">No active threats detected</div>
                <div class="forensic-entry">All memory regions validated</div>
                <div class="forensic-entry">Hash chains intact</div>
                <div class="forensic-entry">No unauthorized modifications</div>
            </div>
            
            <h3>Quarantine Zone</h3>
            <div class="quarantine-zone" id="quarantineZone">
                <div style="text-align: center; color: #888;">
                    üîí QUARANTINE EMPTY
                </div>
                <div style="text-align: center; font-size: 9px; color: #666;">
                    Tampered blocks will be isolated here
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button class="control-btn" onclick="scanForThreats()">üîç Threat Scan</button>
                <button class="critical-btn" onclick="quarantineCorrupted()">üîí Quarantine</button>
            </div>
        </div>

        <!-- Checkpoint Manager Panel -->
        <div class="panel">
            <h2>üì∏ Checkpoint Manager</h2>
            
            <div class="checkpoint-list" id="checkpointList">
                <div class="checkpoint-item checkpoint-current" onclick="selectCheckpoint('cp_001')">
                    <strong>Checkpoint #001 (Current)</strong>
                    <div>2025-06-15 10:45:23 ‚Ä¢ Junior active</div>
                    <div>Hash: 7a8f9e2b...d2e4f ‚Ä¢ Size: 4.2KB</div>
                </div>
                
                <div class="checkpoint-item" onclick="selectCheckpoint('cp_002')">
                    <strong>Checkpoint #002</strong>
                    <div>2025-06-15 10:44:15 ‚Ä¢ Scroll completed</div>
                    <div>Hash: 3c5d7e9f...8d0e1f ‚Ä¢ Size: 3.8KB</div>
                </div>
                
                <div class="checkpoint-item" onclick="selectCheckpoint('cp_003')">
                    <strong>Checkpoint #003</strong>
                    <div>2025-06-15 10:42:07 ‚Ä¢ System initialized</div>
                    <div>Hash: 2a4b6c8d...3a5b7c ‚Ä¢ Size: 2.1KB</div>
                </div>
                
                <div class="checkpoint-item checkpoint-corrupted" onclick="selectCheckpoint('cp_004')">
                    <strong>Checkpoint #004 (CORRUPTED)</strong>
                    <div>2025-06-15 10:40:33 ‚Ä¢ Hash mismatch</div>
                    <div>Hash: INVALID ‚Ä¢ Size: Unknown</div>
                </div>
            </div>

            <h3>Auto-Checkpoint Rules</h3>
            <div class="auto-repair">
                <div class="repair-step">‚úÖ Every scroll completion</div>
                <div class="repair-step">‚úÖ Every 5 minutes (heartbeat)</div>
                <div class="repair-step">‚úÖ Before AI handoffs</div>
                <div class="repair-step">‚úÖ On integrity violations</div>
                <div class="repair-step">‚úÖ Manual triggers</div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button class="control-btn" onclick="createCheckpoint()">üì∏ Create</button>
                <button class="control-btn" onclick="validateCheckpoints()">‚úÖ Validate</button>
            </div>
        </div>

        <!-- Rollback Control Panel -->
        <div class="panel">
            <h2>‚Ü©Ô∏è Rollback Control</h2>
            
            <h3>Rollback Timeline</h3>
            <div class="rollback-timeline" id="rollbackTimeline">
[10:45:23] Current state - All systems operational
[10:44:15] Checkpoint created - Scroll 'welcome.scroll' completed
[10:43:42] Memory write - Junior updated rows 15-17
[10:43:18] Lock acquired - Junior locked region 'Core Memory'
[10:42:07] System checkpoint - Initialization complete
[10:41:33] Boot sequence - Memory regions allocated
[10:41:15] System start - Resurrection protocol initiated

Available rollback points: 6
Oldest safe point: 10:41:15 (4m 8s ago)
            </div>
            
            <h3>Rollback Progress</h3>
            <div class="rollback-progress">
                <div class="progress-fill" id="rollbackProgress" style="width: 0%"></div>
            </div>
            <div id="rollbackStatus">Ready for rollback operations</div>
            
            <h3>Change Diff Preview</h3>
            <div class="diff-viewer" id="changeDiff">
                <div class="diff-removed">- scroll_status: "executing"</div>
                <div class="diff-added">+ scroll_status: "completed"</div>
                <div class="diff-modified">~ memory_usage: "3.8KB" ‚Üí "4.2KB"</div>
                <div class="diff-added">+ execution_result: {"success": true}</div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button class="control-btn" onclick="previewRollback()">üëÅÔ∏è Preview</button>
                <button class="critical-btn" onclick="executeRollback()">‚Ü©Ô∏è Rollback</button>
            </div>
        </div>

        <!-- Blockchain Verification Panel -->
        <div class="panel">
            <h2>‚õìÔ∏è Blockchain Verification</h2>
            
            <div class="blockchain-chain" id="blockchainChain">
                <div class="chain-block block-valid">
                    <div><strong>Block #1847 (Latest)</strong></div>
                    <div>Timestamp: 10:45:23</div>
                    <div>Prev: 3c5d7e9f...8d0e1f</div>
                    <div class="block-hash">Hash: 7a8f9e2b4c1d3e6f8a9b2c4d5e7f0a1b</div>
                </div>
                
                <div class="chain-block block-valid">
                    <div><strong>Block #1846</strong></div>
                    <div>Timestamp: 10:44:15</div>
                    <div>Prev: 2a4b6c8d...3a5b7c</div>
                    <div class="block-hash">Hash: 3c5d7e9f2a4b6c8d0e1f3a5b7c9d2e4f</div>
                </div>
                
                <div class="chain-block block-invalid">
                    <div><strong>Block #1845 (INVALID)</strong></div>
                    <div>Timestamp: 10:43:07</div>
                    <div>Prev: CORRUPTED</div>
                    <div class="block-hash">Hash: VERIFICATION FAILED</div>
                </div>
                
                <div class="chain-block block-valid">
                    <div><strong>Block #1844</strong></div>
                    <div>Timestamp: 10:42:07</div>
                    <div>Prev: 1b3c5d7e...f2a4b6</div>
                    <div class="block-hash">Hash: 2a4b6c8d0e1f3a5b7c9d2e4f8a0b1c3d</div>
                </div>
            </div>

            <h3>Chain Statistics</h3>
            <div class="security-metrics">
                <div class="metric-item">
                    <strong>Valid Blocks:</strong><br>
                    <span id="validBlocks">1846/1847</span>
                </div>
                <div class="metric-item">
                    <strong>Chain Length:</strong><br>
                    <span id="chainLength">1847</span>
                </div>
                <div class="metric-item">
                    <strong>Integrity:</strong><br>
                    <span id="chainIntegrity">99.9%</span>
                </div>
                <div class="metric-item">
                    <strong>Last Block:</strong><br>
                    <span id="lastBlock" class="timestamp">2.1s ago</span>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button class="control-btn" onclick="verifyChain()">‚õìÔ∏è Verify Chain</button>
                <button class="control-btn" onclick="rebuildChain()">üîß Rebuild</button>
            </div>
        </div>

        <!-- Forensics & Recovery Panel -->
        <div class="panel">
            <h2>üî¨ Forensics & Recovery</h2>
            
            <h3>Tamper Investigation</h3>
            <div class="tamper-log" id="tamperLog">
[10:45:23] [INFO] Integrity check completed - all regions valid
[10:44:15] [INFO] Checkpoint created successfully
[10:43:42] [INFO] Memory write validated - Junior rows 15-17
[10:43:18] [INFO] Lock operation verified
[10:43:07] [WARNING] Hash mismatch detected in block #1845
[10:43:08] [INFO] Initiating forensic analysis
[10:43:09] [ERROR] Tampering detected - unauthorized modification
[10:43:10] [INFO] Quarantining corrupted block
[10:43:11] [SUCCESS] Auto-repair initiated
[10:43:15] [SUCCESS] Block reconstructed from backup
[10:43:16] [INFO] Chain integrity restored
            </div>
            
            <h3>Auto-Repair Status</h3>
            <div class="auto-repair" id="autoRepairStatus">
                <div class="repair-step">‚úÖ 1. Corruption detected in block #1845</div>
                <div class="repair-step">‚úÖ 2. Block quarantined and isolated</div>
                <div class="repair-step repair-active">‚ö° 3. Reconstructing from backup checkpoint</div>
                <div class="repair-step">‚è≥ 4. Validate reconstructed data</div>
                <div class="repair-step">‚è≥ 5. Recompute hash chain</div>
                <div class="repair-step">‚è≥ 6. Restore system state</div>
            </div>

            <h3>Recovery Options</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button class="control-btn" onclick="autoRepair()">üîß Auto Repair</button>
                <button class="control-btn" onclick="manualRepair()">üõ†Ô∏è Manual</button>
                <button class="critical-btn" onclick="emergencyRestore()">üö® Emergency</button>
                <button class="control-btn" onclick="exportForensics()">üìã Export</button>
            </div>
        </div>
    </div>

    <script>
        // Tamper Detection & Rollback System
        class TamperDetectionSystem {
            constructor() {
                this.checksums = new Map();
                this.checkpoints = [];
                this.blockchain = [];
                this.quarantine = [];
                this.threats = [];
                this.monitoring = true;
                this.stats = {
                    totalChecks: 0,
                    violations: 0,
                    repairs: 0,
                    rollbacks: 0
                };
                
                this.initializeSystem();
            }

            initializeSystem() {
                this.log('info', 'Tamper Detection System initialized');
                
                // Initialize verification matrix
                this.initializeVerificationMatrix();
                
                // Create initial checkpoint
                this.createSystemCheckpoint();
                
                // Initialize blockchain
                this.initializeBlockchain();