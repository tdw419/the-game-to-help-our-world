<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-AI Lock & Handoff System v1.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #1a0033 0%, #330066 25%, #660033 50%, #990000 75%, #cc3300 100%);
            color: #ff88cc;
            min-height: 100vh;
            padding: 20px;
            overflow-x: auto;
        }

        .lock-container {
            max-width: 1800px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            min-height: calc(100vh - 40px);
        }

        .panel {
            background: rgba(0, 0, 0, 0.85);
            border: 2px solid #ff88cc;
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(8px);
            box-shadow: 0 0 25px rgba(255, 136, 204, 0.3);
            display: flex;
            flex-direction: column;
        }

        h1 {
            grid-column: span 5;
            text-align: center;
            color: #ffcc00;
            text-shadow: 0 0 20px #ffcc00;
            font-size: 24px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ffcc00;
        }

        h2 {
            color: #ff88cc;
            text-shadow: 0 0 10px #ff88cc;
            font-size: 14px;
            border-bottom: 2px solid #ff88cc;
            padding-bottom: 6px;
            margin-bottom: 12px;
        }

        .ai-node {
            background: rgba(255, 136, 204, 0.05);
            border: 1px solid #ff88cc;
            border-radius: 8px;
            padding: 12px;
            margin: 6px 0;
            position: relative;
            transition: all 0.3s;
        }

        .ai-node:hover {
            background: rgba(255, 136, 204, 0.1);
            box-shadow: 0 0 15px rgba(255, 136, 204, 0.4);
        }

        .ai-name {
            font-weight: bold;
            color: #ffcc00;
            font-size: 14px;
            margin-bottom: 6px;
        }

        .ai-status {
            font-size: 11px;
            margin-bottom: 8px;
        }

        .ai-locks {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            font-size: 10px;
        }

        .lock-indicator {
            position: absolute;
            top: 8px;
            right: 8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            font-weight: bold;
            animation: pulse 2s infinite;
        }

        .lock-held { background: #ff0000; color: #fff; }
        .lock-waiting { background: #ffff00; color: #000; }
        .lock-free { background: #00ff00; color: #000; }
        .lock-handoff { background: #ff88cc; color: #000; animation: handoff 1s infinite; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.7; transform: scale(1.1); }
        }

        @keyframes handoff {
            0%, 100% { transform: rotate(0deg); }
            50% { transform: rotate(180deg); }
        }

        .memory-region {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #ff88cc;
            border-radius: 6px;
            padding: 8px;
            margin: 4px 0;
            font-size: 10px;
            position: relative;
        }

        .region-locked {
            border-color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
        }

        .region-contested {
            border-color: #ffff00;
            background: rgba(255, 255, 0, 0.1);
            animation: contest 0.5s infinite;
        }

        .region-handoff {
            border-color: #ff88cc;
            background: rgba(255, 136, 204, 0.2);
            animation: handoff 1s infinite;
        }

        @keyframes contest {
            0%, 100% { border-color: #ffff00; }
            50% { border-color: #ff0000; }
        }

        .lock-queue {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff88cc;
            border-radius: 6px;
            padding: 8px;
        }

        .queue-item {
            background: rgba(255, 136, 204, 0.1);
            border: 1px solid #ff88cc;
            border-radius: 4px;
            padding: 6px;
            margin: 3px 0;
            font-size: 10px;
            position: relative;
        }

        .queue-priority-critical { border-color: #ff0000; background: rgba(255, 0, 0, 0.2); }
        .queue-priority-high { border-color: #ff6600; background: rgba(255, 102, 0, 0.1); }
        .queue-priority-normal { border-color: #ff88cc; }
        .queue-priority-low { border-color: #666; background: rgba(100, 100, 100, 0.1); }

        .handoff-sequence {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #ff88cc;
            border-radius: 6px;
            padding: 10px;
            max-height: 250px;
            overflow-y: auto;
            font-size: 10px;
            white-space: pre-wrap;
        }

        .deadlock-detector {
            background: rgba(255, 0, 0, 0.1);
            border: 2px solid #ff0000;
            border-radius: 8px;
            padding: 12px;
            margin: 8px 0;
        }

        .deadlock-warning {
            color: #ff0000;
            font-weight: bold;
            text-align: center;
            animation: blink 1s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .control-btn {
            background: linear-gradient(45deg, #660033, #cc0066);
            border: 1px solid #ff88cc;
            color: #ff88cc;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-size: 10px;
            margin: 2px;
            transition: all 0.3s;
        }

        .control-btn:hover {
            background: linear-gradient(45deg, #cc0066, #ff88cc);
            color: #000;
            box-shadow: 0 0 15px #ff88cc;
        }

        .critical-btn {
            background: linear-gradient(45deg, #990000, #ff0000);
            border-color: #ff0000;
            color: #ff0000;
        }

        .critical-btn:hover {
            background: linear-gradient(45deg, #ff0000, #ffff00);
            color: #000;
            box-shadow: 0 0 15px #ff0000;
        }

        .lock-matrix {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 2px;
            margin: 8px 0;
        }

        .matrix-cell {
            width: 30px;
            height: 20px;
            border: 1px solid #333;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .cell-free { background: #003300; color: #00ff00; }
        .cell-locked { background: #330000; color: #ff0000; }
        .cell-waiting { background: #333300; color: #ffff00; }
        .cell-handoff { background: #330033; color: #ff88cc; }

        .handoff-protocol {
            background: rgba(255, 136, 204, 0.05);
            border: 1px solid #ff88cc;
            border-radius: 6px;
            padding: 10px;
            margin: 8px 0;
        }

        .protocol-step {
            background: rgba(0, 0, 0, 0.5);
            border-left: 3px solid #ff88cc;
            padding: 6px;
            margin: 4px 0;
            font-size: 10px;
        }

        .step-active {
            border-left-color: #ffcc00;
            background: rgba(255, 204, 0, 0.1);
        }

        .step-completed {
            border-left-color: #00ff00;
            background: rgba(0, 255, 0, 0.1);
        }

        .step-failed {
            border-left-color: #ff0000;
            background: rgba(255, 0, 0, 0.1);
        }

        .ai-communication {
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid #ff88cc;
            border-radius: 6px;
            padding: 8px;
            max-height: 150px;
            overflow-y: auto;
            font-size: 9px;
        }

        .message {
            padding: 4px;
            margin: 2px 0;
            border-radius: 4px;
        }

        .msg-request { background: rgba(255, 102, 0, 0.2); color: #ff6600; }
        .msg-response { background: rgba(0, 255, 0, 0.2); color: #00ff00; }
        .msg-handoff { background: rgba(255, 136, 204, 0.2); color: #ff88cc; }
        .msg-error { background: rgba(255, 0, 0, 0.2); color: #ff0000; }

        .timestamp {
            color: #888;
            font-size: 8px;
        }

        .performance-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin: 8px 0;
        }

        .metric-item {
            background: rgba(0, 0, 0, 0.6);
            padding: 6px;
            border-radius: 4px;
            text-align: center;
            font-size: 9px;
        }

        .success { color: #44ff44; }
        .warning { color: #ffaa44; }
        .error { color: #ff4444; }
        .info { color: #44aaff; }

        .lock-timeout {
            color: #ff6600;
            font-size: 8px;
            opacity: 0.8;
        }

        .priority-badge {
            position: absolute;
            top: 2px;
            left: 2px;
            background: #ff6600;
            color: #000;
            border-radius: 3px;
            padding: 1px 4px;
            font-size: 7px;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="lock-container">
        <h1>🔒 Multi-AI Lock & Handoff System v1.0</h1>
        
        <!-- AI Nodes Panel -->
        <div class="panel">
            <h2>🤖 AI Nodes</h2>
            
            <div id="aiNodes">
                <div class="ai-node" id="node-junior">
                    <div class="lock-indicator lock-held">🔒</div>
                    <div class="ai-name">Junior</div>
                    <div class="ai-status">Active • Processing welcome.scroll</div>
                    <div class="ai-locks">
                        <div>Holds: rows 10-15</div>
                        <div>Waiting: none</div>
                        <div>Priority: HIGH</div>
                        <div>Timeout: 30s</div>
                    </div>
                </div>
                
                <div class="ai-node" id="node-claude">
                    <div class="lock-indicator lock-waiting">⏳</div>
                    <div class="ai-name">Claude</div>
                    <div class="ai-status">Waiting • Ready for handoff</div>
                    <div class="ai-locks">
                        <div>Holds: none</div>
                        <div>Waiting: rows 16-20</div>
                        <div>Priority: NORMAL</div>
                        <div>Timeout: 45s</div>
                    </div>
                </div>
                
                <div class="ai-node" id="node-gemini">
                    <div class="lock-indicator lock-free">✓</div>
                    <div class="ai-name">Gemini</div>
                    <div class="ai-status">Idle • Available</div>
                    <div class="ai-locks">
                        <div>Holds: none</div>
                        <div>Waiting: none</div>
                        <div>Priority: LOW</div>
                        <div>Timeout: n/a</div>
                    </div>
                </div>
            </div>

            <h3>Control Actions</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button class="control-btn" onclick="forceUnlock()">🔓 Force Unlock</button>
                <button class="control-btn" onclick="requestHandoff()">🔄 Request Handoff</button>
                <button class="critical-btn" onclick="emergencyRelease()">🚨 Emergency</button>
                <button class="control-btn" onclick="addAI()">➕ Add AI</button>
            </div>

            <h3>Deadlock Detection</h3>
            <div class="deadlock-detector" id="deadlockStatus">
                <div class="deadlock-warning" style="display: none;">⚠️ DEADLOCK DETECTED</div>
                <div id="deadlockInfo">System healthy • No deadlocks detected</div>
            </div>
        </div>

        <!-- Memory Regions Panel -->
        <div class="panel">
            <h2>🧠 Memory Regions</h2>
            
            <h3>Lock Matrix</h3>
            <div class="lock-matrix" id="lockMatrix">
                <!-- Generated dynamically -->
            </div>
            
            <div id="memoryRegions">
                <div class="memory-region region-locked">
                    <strong>Rows 10-15: Junior's Core</strong>
                    <div>🔒 Locked by: Junior (15.2s ago)</div>
                    <div>📝 Operation: scroll execution</div>
                    <div class="lock-timeout">Timeout: 14.8s remaining</div>
                </div>
                
                <div class="memory-region">
                    <strong>Rows 16-20: Shared Buffer</strong>
                    <div>✓ Available</div>
                    <div>📝 Operation: none</div>
                    <div>🔄 Next: Claude (waiting)</div>
                </div>
                
                <div class="memory-region region-contested">
                    <strong>Rows 21-25: Task Queue</strong>
                    <div>⚡ Contested by: Claude, Junior</div>
                    <div>📝 Operation: queue update</div>
                    <div class="lock-timeout">Resolving: 3.1s</div>
                </div>
                
                <div class="memory-region">
                    <strong>Rows 26-30: Junior's Cache</strong>
                    <div>✓ Available</div>
                    <div>📝 Operation: none</div>
                    <div>🔄 Reserved for: Junior</div>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px; margin-top: 8px;">
                <button class="control-btn" onclick="viewRegionDetails()">🔍 Details</button>
                <button class="control-btn" onclick="optimizeRegions()">⚡ Optimize</button>
            </div>
        </div>

        <!-- Lock Queue Panel -->
        <div class="panel">
            <h2>📋 Lock Queue</h2>
            
            <div class="lock-queue" id="lockQueue">
                <div class="queue-item queue-priority-critical">
                    <div class="priority-badge">CRIT</div>
                    <strong>Emergency dump</strong> - Junior
                    <div>Requires: rows 27-30 (exclusive)</div>
                    <div class="timestamp">Queued: 2.1s ago</div>
                </div>
                
                <div class="queue-item queue-priority-high">
                    <div class="priority-badge">HIGH</div>
                    <strong>Scroll execution</strong> - Junior
                    <div>Requires: rows 10-15 (shared read)</div>
                    <div class="timestamp">Queued: 5.7s ago</div>
                </div>
                
                <div class="queue-item queue-priority-normal">
                    <div class="priority-badge">NORM</div>
                    <strong>Task processing</strong> - Claude
                    <div>Requires: rows 16-20 (exclusive)</div>
                    <div class="timestamp">Queued: 12.3s ago</div>
                </div>
                
                <div class="queue-item queue-priority-low">
                    <div class="priority-badge">LOW</div>
                    <strong>Cache cleanup</strong> - Gemini
                    <div>Requires: rows 26-30 (shared write)</div>
                    <div class="timestamp">Queued: 45.1s ago</div>
                </div>
            </div>

            <h3>Queue Statistics</h3>
            <div class="performance-metrics">
                <div class="metric-item">
                    <strong>Avg Wait:</strong><br>
                    <span id="avgWait">2.3s</span>
                </div>
                <div class="metric-item">
                    <strong>Queue Depth:</strong><br>
                    <span id="queueDepth">4 items</span>
                </div>
                <div class="metric-item">
                    <strong>Throughput:</strong><br>
                    <span id="throughput">12.5 ops/min</span>
                </div>
                <div class="metric-item">
                    <strong>Conflicts:</strong><br>
                    <span id="conflicts">3 resolved</span>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button class="control-btn" onclick="prioritizeQueue()">⚡ Prioritize</button>
                <button class="control-btn" onclick="clearQueue()">🧹 Clear</button>
            </div>
        </div>

        <!-- Handoff Protocol Panel -->
        <div class="panel">
            <h2>🔄 Handoff Protocol</h2>
            
            <div class="handoff-sequence" id="handoffSequence">
[10:35:23] HANDOFF INITIATED: Junior → Claude
[10:35:24] Stage 1: Lock negotiation started
[10:35:24] Stage 2: Memory state checkpointed  
[10:35:25] Stage 3: Resources transferred (rows 16-20)
[10:35:26] Stage 4: Claude acknowledged ownership
[10:35:26] Stage 5: Junior released locks
[10:35:27] HANDOFF COMPLETE: 4.2s total

[10:36:45] HANDOFF INITIATED: Claude → Junior
[10:36:46] Stage 1: Lock negotiation started
[10:36:46] Stage 2: Memory state checkpointed
[10:36:47] Stage 3: Resources transferred (rows 21-25)
[10:36:48] Stage 4: Junior acknowledged ownership
[10:36:48] Stage 5: Claude released locks
[10:36:49] HANDOFF COMPLETE: 3.8s total
            </div>

            <h3>Active Handoff</h3>
            <div class="handoff-protocol" id="activeHandoff">
                <div class="protocol-step step-completed">
                    ✅ 1. Initiate handoff request (Junior → Claude)
                </div>
                <div class="protocol-step step-completed">
                    ✅ 2. Validate AI eligibility and priority
                </div>
                <div class="protocol-step step-active">
                    ⚡ 3. Create memory checkpoint for rollback
                </div>
                <div class="protocol-step">
                    ⏳ 4. Transfer resource ownership atomically
                </div>
                <div class="protocol-step">
                    ⏳ 5. Confirm handoff completion & update locks
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button class="control-btn" onclick="initiateHandoff()">🔄 Start Handoff</button>
                <button class="critical-btn" onclick="abortHandoff()">❌ Abort</button>
            </div>
        </div>

        <!-- AI Communication Panel -->
        <div class="panel">
            <h2>💬 AI Communication</h2>
            
            <div class="ai-communication" id="aiComms">
                <div class="message msg-request">
                    <span class="timestamp">[10:35:23]</span> Junior → Claude: REQUEST_HANDOFF {rows: 16-20, priority: normal}
                </div>
                <div class="message msg-response">
                    <span class="timestamp">[10:35:24]</span> Claude → Junior: ACK_HANDOFF {ready: true, eta: 2s}
                </div>
                <div class="message msg-handoff">
                    <span class="timestamp">[10:35:26]</span> System: HANDOFF_COMPLETE {from: Junior, to: Claude, rows: 16-20}
                </div>
                <div class="message msg-request">
                    <span class="timestamp">[10:35:30]</span> Claude → System: LOCK_REQUEST {rows: 21-25, mode: exclusive}
                </div>
                <div class="message msg-error">
                    <span class="timestamp">[10:35:31]</span> System → Claude: LOCK_DENIED {reason: contested, holder: Junior}
                </div>
                <div class="message msg-request">
                    <span class="timestamp">[10:35:32]</span> Claude → Junior: NEGOTIATE_LOCK {rows: 21-25, timeout: 10s}
                </div>
                <div class="message msg-response">
                    <span class="timestamp">[10:35:35]</span> Junior → Claude: LOCK_GRANTED {rows: 21-25, duration: 30s}
                </div>
            </div>

            <h3>Communication Stats</h3>
            <div class="performance-metrics">
                <div class="metric-item">
                    <strong>Messages:</strong><br>
                    <span id="totalMessages">247</span>
                </div>
                <div class="metric-item">
                    <strong>Success Rate:</strong><br>
                    <span id="successRate">94.3%</span>
                </div>
                <div class="metric-item">
                    <strong>Avg Response:</strong><br>
                    <span id="avgResponse">1.2s</span>
                </div>
                <div class="metric-item">
                    <strong>Timeouts:</strong><br>
                    <span id="timeouts">7</span>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 4px;">
                <button class="control-btn" onclick="sendTestMessage()">📨 Test Msg</button>
                <button class="control-btn" onclick="clearComms()">🧹 Clear</button>
            </div>
        </div>
    </div>

    <script>
        // Multi-AI Lock & Handoff System
        class MultiAILockSystem {
            constructor() {
                this.ais = new Map();
                this.memoryRegions = new Map();
                this.lockQueue = [];
                this.handoffQueue = [];
                this.communications = [];
                this.stats = {
                    totalHandoffs: 0,
                    successfulHandoffs: 0,
                    avgHandoffTime: 0,
                    totalLocks: 0,
                    lockConflicts: 0,
                    deadlockEvents: 0
                };
                
                this.initializeSystem();
            }

            initializeSystem() {
                this.log('info', 'Multi-AI Lock System initialized');
                
                // Initialize AI nodes
                this.registerAI('Junior', { priority: 'high', memoryRegion: [10, 30], status: 'active' });
                this.registerAI('Claude', { priority: 'normal', memoryRegion: [31, 51], status: 'waiting' });
                this.registerAI('Gemini', { priority: 'low', memoryRegion: [52, 72], status: 'idle' });
                
                // Initialize memory regions
                this.initializeMemoryRegions();
                
                // Start monitoring loops
                this.startDeadlockDetection();
                this.startLockTimeout();
                this.startHandoffProcessor();
                
                // Simulate some initial activity
                this.simulateActivity();
            }

            registerAI(name, config) {
                const ai = {
                    name,
                    priority: config.priority,
                    memoryRegion: config.memoryRegion,
                    status: config.status,
                    locksHeld: new Set(),
                    locksWaiting: new Set(),
                    lastActivity: Date.now(),
                    sessionId: this.generateId(),
                    handoffCapable: true
                };
                
                this.ais.set(name, ai);
                this.log('info', `AI registered: ${name} (${config.priority} priority)`);
                this.updateAIDisplay();
            }

            initializeMemoryRegions() {
                const regions = [
                    { name: 'Junior Core', rows: [10, 15], type: 'exclusive', owner: 'Junior' },
                    { name: 'Shared Buffer', rows: [16, 20], type: 'shared', owner: null },
                    { name: 'Task Queue', rows: [21, 25], type: 'contested', owner: null },
                    { name: 'Junior Cache', rows: [26, 30], type: 'reserved', owner: 'Junior' },
                    { name: 'Claude Core', rows: [31, 35], type: 'exclusive', owner: null },
                    { name: 'Claude Buffer', rows: [36, 40], type: 'shared', owner: null },
                    { name: 'Gemini Core', rows: [52, 57], type: 'exclusive', owner: null }
                ];
                
                regions.forEach(region => {
                    this.memoryRegions.set(region.name, {
                        ...region,
                        locked: region.owner !== null,
                        lockTime: region.owner ? Date.now() : null,
                        waitQueue: []
                    });
                });
                
                this.updateMemoryDisplay();
                this.updateLockMatrix();
            }

            requestLock(aiName, regionName, mode = 'exclusive', timeout = 30000) {
                const ai = this.ais.get(aiName);
                const region = this.memoryRegions.get(regionName);
                
                if (!ai || !region) {
                    this.log('error', `Invalid lock request: ${aiName} → ${regionName}`);
                    return false;
                }

                const lockRequest = {
                    id: this.generateId(),
                    aiName,
                    regionName,
                    mode,
                    timeout,
                    requestTime: Date.now(),
                    priority: this.getPriorityValue(ai.priority)
                };

                // Check if lock can be granted immediately
                if (this.canGrantLock(lockRequest)) {
                    this.grantLock(lockRequest);
                    return true;
                } else {
                    this.queueLockRequest(lockRequest);
                    this.sendMessage(aiName, 'System', 'LOCK_QUEUED', { 
                        region: regionName, 
                        position: this.lockQueue.length 
                    });
                    return false;
                }
            }

            canGrantLock(request) {
                const region = this.memoryRegions.get(request.regionName);
                
                if (!region.locked) {
                    return true;
                }
                
                // Check for shared read locks
                if (request.mode === 'shared' && region.type === 'shared') {
                    return true;
                }
                
                return false;
            }

            grantLock(request) {
                const ai = this.ais.get(request.aiName);
                const region = this.memoryRegions.get(request.regionName);
                
                region.locked = true;
                region.owner = request.aiName;
                region.lockTime = Date.now();
                region.mode = request.mode;
                
                ai.locksHeld.add(request.regionName);
                ai.locksWaiting.delete(request.regionName);
                
                this.stats.totalLocks++;
                
                this.log('success', `Lock granted: ${request.aiName} → ${request.regionName} (${request.mode})`);
                this.sendMessage('System', request.aiName, 'LOCK_GRANTED', {
                    region: request.regionName,
                    mode: request.mode,
                    duration: request.timeout
                });
                
                this.updateAIDisplay();
                this.updateMemoryDisplay();
                this.updateLockMatrix();
            }

            queueLockRequest(request) {
                const ai = this.ais.get(request.aiName);
                ai.locksWaiting.add(request.regionName);
                
                // Insert in priority order
                let inserted = false;
                for (let i = 0; i < this.lockQueue.length; i++) {
                    if (request.priority > this.lockQueue[i].priority) {
                        this.lockQueue.splice(i, 0, request);
                        inserted = true;
                        break;
                    }
                }
                
                if (!inserted) {
                    this.lockQueue.push(request);
                }
                
                this.log('info', `Lock queued: ${request.aiName} → ${request.regionName} (position ${this.lockQueue.indexOf(request) + 1})`);
                this.updateLockQueueDisplay();
            }

            releaseLock(aiName, regionName) {
                const ai = this.ais.get(aiName);
                const region = this.memoryRegions.get(regionName);
                
                if (!ai || !region || region.owner !== aiName) {
                    this.log('error', `Invalid lock release: ${aiName} → ${regionName}`);
                    return false;
                }
                
                region.locked = false;
                region.owner = null;
                region.lockTime = null;
                region.mode = null;
                
                ai.locksHeld.delete(regionName);
                
                this.log('success', `Lock released: ${aiName} → ${regionName}`);
                this.sendMessage(aiName, 'System', 'LOCK_RELEASED', { region: regionName });
                
                // Process next in queue
                this.processLockQueue();
                
                this.updateAIDisplay();
                this.updateMemoryDisplay();
                this.updateLockMatrix();
                
                return true;
            }

            processLockQueue() {
                if (this.lockQueue.length === 0) return;
                
                const request = this.lockQueue[0];
                
                if (this.canGrantLock(request)) {
                    this.lockQueue.shift();
                    this.grantLock(request);
                    
                    // Recursively process more requests
                    setTimeout(() => this.processLockQueue(), 100);
                }
            }

            initiateHandoff(fromAI, toAI, regions) {
                if (!this.ais.has(fromAI) || !this.ais.has(toAI)) {
                    this.log('error', `Invalid handoff: ${fromAI} → ${toAI}`);
                    return false;
                }
                
                const handoff = {
                    id: this.generateId(),
                    fromAI,
                    toAI,
                    regions,
                    startTime: Date.now(),
                    status: 'negotiating',
                    steps: [
                        { name: 'Initiate handoff request', status: 'pending' },
                        { name: 'Validate AI eligibility', status: 'pending' },
                        { name: 'Create memory checkpoint', status: 'pending' },
                        { name: 'Transfer resource ownership', status: 'pending' },
                        { name: 'Confirm handoff completion', status: 'pending' }
                    ]
                };
                
                this.handoffQueue.push(handoff);
                
                this.log('info', `Handoff initiated: ${fromAI} → ${toAI}`);
                this.sendMessage(fromAI, toAI, 'REQUEST_HANDOFF', {
                    regions,
                    priority: this.ais.get(toAI).priority
                });
                
                this.processHandoff(handoff);
                return true;
            }

            async processHandoff(handoff) {
                this.updateHandoffDisplay(handoff);
                
                for (let i = 0; i < handoff.steps.length; i++) {
                    const step = handoff.steps[i];
                    step.status = 'active';
                    this.updateHandoffDisplay(handoff);
                    
                    await this.delay(800 + Math.random() * 400); // 0.8-1.2s per step
                    
                    const success = await this.executeHandoffStep(handoff, i);
                    
                    if (success) {
                        step.status = 'completed';
                        this.log('success', `Handoff step ${i + 1} completed: ${step.name}`);
                    } else {
                        step.status = 'failed';
                        this.log('error', `Handoff step ${i + 1} failed: ${step.name}`);
                        this.abortHandoff(handoff);
                        return;
                    }
                }
                
                this.completeHandoff(handoff);
            }

            async executeHandoffStep(handoff, stepIndex) {
                const { fromAI, toAI, regions } = handoff;
                
                switch (stepIndex) {
                    case 0: // Initiate handoff request
                        this.sendMessage(fromAI, toAI, 'REQUEST_HANDOFF', { regions });
                        return true;
                        
                    case 1: // Validate AI eligibility
                        const fromAIObj = this.ais.get(fromAI);
                        const toAIObj = this.ais.get(toAI);
                        
                        if (!fromAIObj.handoffCapable || !toAIObj.handoffCapable) {
                            return false;
                        }
                        
                        this.sendMessage(toAI, fromAI, 'ACK_HANDOFF', { ready: true });
                        return true;
                        
                    case 2: // Create memory checkpoint
                        this.createMemoryCheckpoint(handoff.id);
                        return true;
                        
                    case 3: // Transfer resource ownership
                        return this.transferResources(fromAI, toAI, regions);
                        
                    case 4: // Confirm handoff completion
                        this.sendMessage('System', 'Broadcast', 'HANDOFF_COMPLETE', {
                            from: fromAI,
                            to: toAI,
                            regions,
                            duration: Date.now() - handoff.startTime
                        });
                        return true;
                        
                    default:
                        return false;
                }
            }

            transferResources(fromAI, toAI, regions) {
                try {
                    const fromAIObj = this.ais.get(fromAI);
                    const toAIObj = this.ais.get(toAI);
                    
                    regions.forEach(regionName => {
                        const region = this.memoryRegions.get(regionName);
                        
                        if (region && region.owner === fromAI) {
                            // Transfer ownership
                            region.owner = toAI;
                            region.lockTime = Date.now();
                            
                            // Update AI lock sets
                            fromAIObj.locksHeld.delete(regionName);
                            toAIObj.locksHeld.add(regionName);
                            
                            this.log('info', `Resource transferred: ${regionName} (${fromAI} → ${toAI})`);
                        }
                    });
                    
                    return true;
                } catch (error) {
                    this.log('error', `Resource transfer failed: ${error.message}`);
                    return false;
                }
            }

            completeHandoff(handoff) {
                const duration = Date.now() - handoff.startTime;
                handoff.status = 'completed';
                
                this.stats.totalHandoffs++;
                this.stats.successfulHandoffs++;
                this.stats.avgHandoffTime = 
                    ((this.stats.avgHandoffTime * (this.stats.totalHandoffs - 1)) + duration) / this.stats.totalHandoffs;
                
                this.log('success', `Handoff completed: ${handoff.fromAI} → ${handoff.toAI} (${duration}ms)`);
                
                // Remove from queue
                this.handoffQueue = this.handoffQueue.filter(h => h.id !== handoff.id);
                
                this.updateAIDisplay();
                this.updateMemoryDisplay();
                this.updateHandoffDisplay();
            }

            abortHandoff(handoff) {
                handoff.status = 'aborted';
                
                this.log('error', `Handoff aborted: ${handoff.fromAI} → ${handoff.toAI}`);
                this.sendMessage('System', 'Broadcast', 'HANDOFF_ABORTED', {
                    from: handoff.fromAI,
                    to: handoff.toAI,
                    reason: 'Step execution failed'
                });
                
                // Restore from checkpoint if needed
                this.restoreFromCheckpoint(handoff.id);
                
                // Remove from queue
                this.handoffQueue = this.handoffQueue.filter(h => h.id !== handoff.id);
                
                this.updateHandoffDisplay();
            }

            createMemoryCheckpoint(checkpointId) {
                const checkpoint = {
                    id: checkpointId,
                    timestamp: Date.now(),
                    memoryState: new Map(),
                    aiStates: new Map()
                };
                
                // Save current memory region states
                this.memoryRegions.forEach((region, name) => {
                    checkpoint.memoryState.set(name, { ...region });
                });
                
                // Save current AI states
                this.ais.forEach((ai, name) => {
                    checkpoint.aiStates.set(name, {
                        locksHeld: new Set(ai.locksHeld),
                        locksWaiting: new Set(ai.locksWaiting),
                        status: ai.status
                    });
                });
                
                // Store checkpoint (in real implementation, this would go to persistent storage)
                this.checkpoints = this.checkpoints || new Map();
                this.checkpoints.set(checkpointId, checkpoint);
                
                this.log('info', `Memory checkpoint created: ${checkpointId}`);
            }

            restoreFromCheckpoint(checkpointId) {
                const checkpoint = this.checkpoints?.get(checkpointId);
                if (!checkpoint) {
                    this.log('error', `Checkpoint not found: ${checkpointId}`);
                    return false;
                }
                
                // Restore memory regions
                checkpoint.memoryState.forEach((state, name) => {
                    this.memoryRegions.set(name, { ...state });
                });
                
                // Restore AI states
                checkpoint.aiStates.forEach((state, name) => {
                    const ai = this.ais.get(name);
                    if (ai) {
                        ai.locksHeld = new Set(state.locksHeld);
                        ai.locksWaiting = new Set(state.locksWaiting);
                        ai.status = state.status;
                    }
                });
                
                this.log('warning', `System restored from checkpoint: ${checkpointId}`);
                this.updateAIDisplay();
                this.updateMemoryDisplay();
                
                return true;
            }

            detectDeadlock() {
                const waitGraph = new Map();
                
                // Build wait-for graph
                this.ais.forEach((ai, name) => {
                    waitGraph.set(name, new Set());
                    
                    ai.locksWaiting.forEach(regionName => {
                        const region = this.memoryRegions.get(regionName);
                        if (region && region.owner && region.owner !== name) {
                            waitGraph.get(name).add(region.owner);
                        }
                    });
                });
                
                // Detect cycles using DFS
                const visited = new Set();
                const recursionStack = new Set();
                
                const hasCycle = (node) => {
                    if (recursionStack.has(node)) return true;
                    if (visited.has(node)) return false;
                    
                    visited.add(node);
                    recursionStack.add(node);
                    
                    const neighbors = waitGraph.get(node) || new Set();
                    for (const neighbor of neighbors) {
                        if (hasCycle(neighbor)) return true;
                    }
                    
                    recursionStack.delete(node);
                    return false;
                };
                
                for (const ai of this.ais.keys()) {
                    if (!visited.has(ai) && hasCycle(ai)) {
                        this.handleDeadlock(waitGraph);
                        return true;
                    }
                }
                
                return false;
            }

            handleDeadlock(waitGraph) {
                this.stats.deadlockEvents++;
                this.log('error', '🚨 DEADLOCK DETECTED - Initiating resolution');
                
                // Find victim AI (lowest priority AI in cycle)
                let victim = null;
                let lowestPriority = Infinity;
                
                this.ais.forEach((ai, name) => {
                    const priority = this.getPriorityValue(ai.priority);
                    if (priority < lowestPriority && ai.locksWaiting.size > 0) {
                        lowestPriority = priority;
                        victim = name;
                    }
                });
                
                if (victim) {
                    this.log('warning', `Deadlock victim selected: ${victim}`);
                    this.abortAIOperations(victim);
                    
                    // Force release some locks
                    const victimAI = this.ais.get(victim);
                    victimAI.locksHeld.forEach(regionName => {
                        this.releaseLock(victim, regionName);
                    });
                    
                    victimAI.locksWaiting.clear();
                    
                    this.sendMessage('System', victim, 'DEADLOCK_RESOLUTION', {
                        action: 'abort_and_retry',
                        reason: 'Selected as deadlock victim'
                    });
                }
                
                this.updateDeadlockDisplay(true);
                
                // Clear deadlock warning after resolution
                setTimeout(() => {
                    this.updateDeadlockDisplay(false);
                }, 5000);
            }

            abortAIOperations(aiName) {
                const ai = this.ais.get(aiName);
                if (!ai) return;
                
                ai.status = 'recovering';
                
                // Remove from lock queue
                this.lockQueue = this.lockQueue.filter(req => req.aiName !== aiName);
                
                // Abort any active handoffs
                this.handoffQueue.forEach(handoff => {
                    if (handoff.fromAI === aiName || handoff.toAI === aiName) {
                        this.abortHandoff(handoff);
                    }
                });
                
                this.log('warning', `AI operations aborted: ${aiName}`);
                
                // Restart AI after delay
                setTimeout(() => {
                    ai.status = 'active';
                    this.updateAIDisplay();
                }, 3000);
            }

            startDeadlockDetection() {
                setInterval(() => {
                    this.detectDeadlock();
                }, 2000); // Check every 2 seconds
            }

            startLockTimeout() {
                setInterval(() => {
                    const now = Date.now();
                    
                    // Check for timed-out lock requests
                    this.lockQueue = this.lockQueue.filter(request => {
                        const elapsed = now - request.requestTime;
                        if (elapsed > request.timeout) {
                            this.log('warning', `Lock request timed out: ${request.aiName} → ${request.regionName}`);
                            this.sendMessage('System', request.aiName, 'LOCK_TIMEOUT', {
                                region: request.regionName,
                                elapsed
                            });
                            
                            const ai = this.ais.get(request.aiName);
                            if (ai) {
                                ai.locksWaiting.delete(request.regionName);
                            }
                            
                            return false; // Remove from queue
                        }
                        return true;
                    });
                    
                    // Check for stuck locks (held too long)
                    this.memoryRegions.forEach((region, name) => {
                        if (region.locked && region.lockTime) {
                            const lockDuration = now - region.lockTime;
                            if (lockDuration > 60000) { // 1 minute
                                this.log('warning', `Long-held lock detected: ${region.owner} → ${name} (${lockDuration}ms)`);
                                
                                // Could force release if needed
                                if (lockDuration > 120000) { // 2 minutes
                                    this.log('error', `Force releasing stuck lock: ${name}`);
                                    this.releaseLock(region.owner, name);
                                }
                            }
                        }
                    });
                    
                    this.updateLockQueueDisplay();
                }, 1000);
            }

            startHandoffProcessor() {
                setInterval(() => {
                    // Update handoff displays
                    this.updateHandoffSequenceDisplay();
                }, 1000);
            }

            simulateActivity() {
                // Simulate Junior working
                setTimeout(() => {
                    this.requestLock('Junior', 'Shared Buffer', 'shared');
                }, 2000);
                
                setTimeout(() => {
                    this.requestLock('Claude', 'Task Queue', 'exclusive');
                }, 4000);
                
                setTimeout(() => {
                    this.initiateHandoff('Junior', 'Claude', ['Shared Buffer']);
                }, 8000);
                
                // Periodic activity simulation
                setInterval(() => {
                    const ais = Array.from(this.ais.keys());
                    const regions = Array.from(this.memoryRegions.keys());
                    
                    if (Math.random() < 0.3) { // 30% chance
                        const ai = ais[Math.floor(Math.random() * ais.length)];
                        const region = regions[Math.floor(Math.random() * regions.length)];
                        this.requestLock(ai, region, Math.random() < 0.7 ? 'shared' : 'exclusive');
                    }
                    
                    if (Math.random() < 0.1) { // 10% chance
                        const fromAI = ais[Math.floor(Math.random() * ais.length)];
                        const toAI = ais[Math.floor(Math.random() * ais.length)];
                        if (fromAI !== toAI) {
                            const region = regions[Math.floor(Math.random() * regions.length)];
                            this.initiateHandoff(fromAI, toAI, [region]);
                        }
                    }
                }, 10000); // Every 10 seconds
            }

            sendMessage(from, to, type, data = {}) {
                const message = {
                    id: this.generateId(),
                    timestamp: Date.now(),
                    from,
                    to,
                    type,
                    data
                };
                
                this.communications.push(message);
                
                // Keep only last 50 messages
                if (this.communications.length > 50) {
                    this.communications = this.communications.slice(-50);
                }
                
                this.updateCommunicationDisplay();
                
                return message;
            }

            getPriorityValue(priority) {
                const priorities = { critical: 4, high: 3, normal: 2, low: 1 };
                return priorities[priority] || 1;
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            generateId() {
                return Math.random().toString(36).substr(2, 9);
            }

            log(level, message) {
                const timestamp = new Date().toLocaleTimeString();
                const logEntry = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
                console.log(logEntry);
            }

            // UI Update Methods
            updateAIDisplay() {
                this.ais.forEach((ai, name) => {
                    const nodeElement = document.getElementById(`node-${name.toLowerCase()}`);
                    if (!nodeElement) return;
                    
                    const indicator = nodeElement.querySelector('.lock-indicator');
                    const statusElement = nodeElement.querySelector('.ai-status');
                    const locksElement = nodeElement.querySelector('.ai-locks');
                    
                    // Update lock indicator
                    if (ai.locksHeld.size > 0) {
                        indicator.className = 'lock-indicator lock-held';
                        indicator.textContent = '🔒';
                    } else if (ai.locksWaiting.size > 0) {
                        indicator.className = 'lock-indicator lock-waiting';
                        indicator.textContent = '⏳';
                    } else {
                        indicator.className = 'lock-indicator lock-free';
                        indicator.textContent = '✓';
                    }
                    
                    // Update status
                    const statusMap = {
                        active: '🟢 Active',
                        waiting: '🟡 Waiting',
                        idle: '⚪ Idle',
                        recovering: '🔄 Recovering'
                    };
                    statusElement.textContent = `${statusMap[ai.status] || ai.status} • ${ai.locksHeld.size} locks held`;
                    
                    // Update lock details
                    locksElement.innerHTML = `
                        <div>Holds: ${Array.from(ai.locksHeld).join(', ') || 'none'}</div>
                        <div>Waiting: ${Array.from(ai.locksWaiting).join(', ') || 'none'}</div>
                        <div>Priority: ${ai.priority.toUpperCase()}</div>
                        <div>Session: ${ai.sessionId.substr(0, 8)}</div>
                    `;
                });
            }

            updateMemoryDisplay() {
                const container = document.getElementById('memoryRegions');
                container.innerHTML = '';
                
                this.memoryRegions.forEach((region, name) => {
                    const regionElement = document.createElement('div');
                    regionElement.className = 'memory-region';
                    
                    if (region.locked) {
                        regionElement.classList.add('region-locked');
                    }
                    
                    const lockDuration = region.lockTime ? 
                        ((Date.now() - region.lockTime) / 1000).toFixed(1) : 0;
                    
                    regionElement.innerHTML = `
                        <strong>${name} (Rows ${region.rows[0]}-${region.rows[1]})</strong>
                        <div>${region.locked ? '🔒' : '✓'} ${region.locked ? `Locked by: ${region.owner} (${lockDuration}s ago)` : 'Available'}</div>
                        <div>📝 Type: ${region.type}</div>
                        ${region.locked ? `<div class="lock-timeout">Mode: ${region.mode || 'exclusive'}</div>` : ''}
                    `;
                    
                    container.appendChild(regionElement);
                });
            }

            updateLockMatrix() {
                const matrix = document.getElementById('lockMatrix');
                matrix.innerHTML = '';
                
                const regions = Array.from(this.memoryRegions.values()).slice(0, 16); // Show first 16 regions
                
                regions.forEach((region, index) => {
                    const cell = document.createElement('div');
                    cell.className = 'matrix-cell';
                    cell.title = `${region.name || `Region ${index}`} - ${region.locked ? `Locked by ${region.owner}` : 'Free'}`;
                    
                    if (region.locked) {
                        cell.classList.add('cell-locked');
                        cell.textContent = region.owner?.charAt(0) || 'L';
                    } else if (region.waitQueue?.length > 0) {
                        cell.classList.add('cell-waiting');
                        cell.textContent = region.waitQueue.length;
                    } else {
                        cell.classList.add('cell-free');
                        cell.textContent = '✓';
                    }
                    
                    matrix.appendChild(cell);
                });
            }

            updateLockQueueDisplay() {
                const container = document.getElementById('lockQueue');
                
                if (this.lockQueue.length === 0) {
                    container.innerHTML = '<div class="queue-item">No pending lock requests</div>';
                    return;
                }
                
                container.innerHTML = this.lockQueue.slice(0, 8).map((request, index) => {
                    const elapsed = ((Date.now() - request.requestTime) / 1000).toFixed(1);
                    const priority = ['low', 'normal', 'high', 'critical'][request.priority - 1] || 'normal';
                    
                    return `
                        <div class="queue-item queue-priority-${priority}">
                            <div class="priority-badge">${priority.substr(0, 4).toUpperCase()}</div>
                            <strong>${request.regionName}</strong> - ${request.aiName}
                            <div>Mode: ${request.mode}, Timeout: ${(request.timeout / 1000).toFixed(0)}s</div>
                            <div class="timestamp">Waiting: ${elapsed}s</div>
                        </div>
                    `;
                }).join('');
                
                // Update queue stats
                document.getElementById('queueDepth').textContent = `${this.lockQueue.length} items`;
            }

            updateHandoffDisplay(activeHandoff = null) {
                const container = document.getElementById('activeHandoff');
                
                if (!activeHandoff && this.handoffQueue.length > 0) {
                    activeHandoff = this.handoffQueue[0];
                }
                
                if (!activeHandoff) {
                    container.innerHTML = '<div class="protocol-step">No active handoffs</div>';
                    return;
                }
                
                container.innerHTML = activeHandoff.steps.map((step, index) => {
                    const stepClass = step.status === 'completed' ? 'step-completed' :
                                     step.status === 'active' ? 'step-active' :
                                     step.status === 'failed' ? 'step-failed' : '';
                    
                    const icon = step.status === 'completed' ? '✅' :
                                step.status === 'active' ? '⚡' :
                                step.status === 'failed' ? '❌' : '⏳';
                    
                    return `
                        <div class="protocol-step ${stepClass}">
                            ${icon} ${index + 1}. ${step.name}
                        </div>
                    `;
                }).join('');
            }

            updateHandoffSequenceDisplay() {
                const container = document.getElementById('handoffSequence');
                const recentHandoffs = this.handoffQueue.slice(-10);
                
                if (recentHandoffs.length === 0) {
                    container.textContent = 'No recent handoff activity';
                    return;
                }
                
                let content = '';
                recentHandoffs.forEach(handoff => {
                    const timestamp = new Date(handoff.startTime).toLocaleTimeString();
                    const duration = handoff.status === 'completed' ? 
                        `${((Date.now() - handoff.startTime) / 1000).toFixed(1)}s` : 'ongoing';
                    
                    content += `[${timestamp}] HANDOFF ${handoff.status.toUpperCase()}: ${handoff.fromAI} → ${handoff.toAI}\n`;
                    if (handoff.status === 'completed') {
                        content += `[${timestamp}] Duration: ${duration}\n\n`;
                    }
                });
                
                container.textContent = content;
                container.scrollTop = container.scrollHeight;
            }

            updateCommunicationDisplay() {
                const container = document.getElementById('aiComms');
                const recent = this.communications.slice(-15);
                
                container.innerHTML = recent.map(msg => {
                    const timestamp = new Date(msg.timestamp).toLocaleTimeString();
                    const typeClass = msg.type.includes('REQUEST') ? 'msg-request' :
                                     msg.type.includes('ACK') || msg.type.includes('GRANTED') ? 'msg-response' :
                                     msg.type.includes('HANDOFF') ? 'msg-handoff' :
                                     msg.type.includes('ERROR') || msg.type.includes('DENIED') ? 'msg-error' :
                                     'msg-request';
                    
                    return `
                        <div class="message ${typeClass}">
                            <span class="timestamp">[${timestamp}]</span> ${msg.from} → ${msg.to}: ${msg.type} ${JSON.stringify(msg.data)}
                        </div>
                    `;
                }).join('');
                
                container.scrollTop = container.scrollHeight;
            }

            updateDeadlockDisplay(hasDeadlock) {
                const warning = document.querySelector('.deadlock-warning');
                const info = document.getElementById('deadlockInfo');
                
                if (hasDeadlock) {
                    warning.style.display = 'block';
                    info.textContent = `Deadlock detected • Resolution in progress • Victim selection active`;
                } else {
                    warning.style.display = 'none';
                    info.textContent = `System healthy • No deadlocks detected • ${this.stats.deadlockEvents} total events`;
                }
            }
        }

        // Global lock system instance
        const lockSystem = new MultiAILockSystem();

        // Control Functions
        function forceUnlock() {
            const aiName = prompt('Enter AI name to force unlock:');
            if (aiName && lockSystem.ais.has(aiName)) {
                const ai = lockSystem.ais.get(aiName);
                ai.locksHeld.forEach(regionName => {
                    lockSystem.releaseLock(aiName, regionName);
                });
                lockSystem.log('warning', `Force unlocked all regions for ${aiName}`);
            }
        }

        function requestHandoff() {
            const fromAI = prompt('From AI:');
            const toAI = prompt('To AI:');
            const regions = prompt('Regions (comma-separated):')?.split(',').map(r => r.trim());
            
            if (fromAI && toAI && regions) {
                lockSystem.initiateHandoff(fromAI, toAI, regions);
            }
        }

        function emergencyRelease() {
            if (confirm('🚨 Emergency release all locks? This will abort all operations.')) {
                lockSystem.memoryRegions.forEach((region, name) => {
                    if (region.locked) {
                        lockSystem.releaseLock(region.owner, name);
                    }
                });
                
                lockSystem.ais.forEach((ai, name) => {
                    ai.locksHeld.clear();
                    ai.locksWaiting.clear();
                    ai.status = 'recovering';
                });
                
                lockSystem.lockQueue = [];
                lockSystem.handoffQueue = [];
                
                lockSystem.log('error', '🚨 Emergency release executed - all locks cleared');
                
                // Restart AIs after delay
                setTimeout(() => {
                    lockSystem.ais.forEach((ai, name) => {
                        ai.status = 'active';
                    });
                    lockSystem.updateAIDisplay();
                }, 3000);
            }
        }

        function addAI() {
            const name = prompt('AI Name:');
            const priority = prompt('Priority (low/normal/high):', 'normal');
            const startRow = parseInt(prompt('Memory start row:', '73'));
            const endRow = parseInt(prompt('Memory end row:', '93'));
            
            if (name && !lockSystem.ais.has(name)) {
                lockSystem.registerAI(name, {
                    priority,
                    memoryRegion: [startRow, endRow],
                    status: 'idle'
                });
                
                // Add new AI node to display
                const container = document.getElementById('aiNodes');
                const newNode = document.createElement('div');
                newNode.className = 'ai-node';
                newNode.id = `node-${name.toLowerCase()}`;
                newNode.innerHTML = `
                    <div class="lock-indicator lock-free">✓</div>
                    <div class="ai-name">${name}</div>
                    <div class="ai-status">Idle • Just registered</div>
                    <div class="ai-locks">
                        <div>Holds: none</div>
                        <div>Waiting: none</div>
                        <div>Priority: ${priority.toUpperCase()}</div>
                        <div>Timeout: n/a</div>
                    </div>
                `;
                container.appendChild(newNode);
                
                lockSystem.log('success', `New AI registered: ${name}`);
            }
        }

        function viewRegionDetails() {
            const regionName = prompt('Enter region name for details:');
            if (regionName && lockSystem.memoryRegions.has(regionName)) {
                const region = lockSystem.memoryRegions.get(regionName);
                alert(`Region: ${regionName}\nLocked: ${region.locked}\nOwner: ${region.owner || 'none'}\nType: ${region.type}\nWait Queue: ${region.waitQueue?.length || 0}`);
            }
        }

        function optimizeRegions() {
            lockSystem.log('info', 'Optimizing memory region allocation...');
            
            // Simple optimization: release unused locks
            let optimized = 0;
            lockSystem.memoryRegions.forEach((region, name) => {
                if (region.locked && region.lockTime) {
                    const duration = Date.now() - region.lockTime;
                    if (duration > 30000) { // 30 seconds
                        lockSystem.log('warning', `Releasing long-held lock: ${name} (${duration}ms)`);
                        lockSystem.releaseLock(region.owner, name);
                        optimized++;
                    }
                }
            });
            
            lockSystem.log('success', `Region optimization complete: ${optimized} locks released`);
        }

        function prioritizeQueue() {
            lockSystem.log('info', 'Reprioritizing lock queue...');
            
            // Boost priority of waiting requests
            lockSystem.lockQueue.forEach(request => {
                const waitTime = Date.now() - request.requestTime;
                if (waitTime > 10000) { // 10 seconds
                    request.priority = Math.min(request.priority + 1, 4);
                }
            });
            
            // Re-sort queue
            lockSystem.lockQueue.sort((a, b) => b.priority - a.priority);
            lockSystem.updateLockQueueDisplay();
            
            lockSystem.log('success', 'Queue reprioritized');
        }

        function clearQueue() {
            if (confirm('Clear all pending lock requests?')) {
                const cleared = lockSystem.lockQueue.length;
                
                // Notify waiting AIs
                lockSystem.lockQueue.forEach(request => {
                    lockSystem.sendMessage('System', request.aiName, 'LOCK_CANCELLED', {
                        region: request.regionName,
                        reason: 'Queue cleared by administrator'
                    });
                    
                    const ai = lockSystem.ais.get(request.aiName);
                    if (ai) {
                        ai.locksWaiting.delete(request.regionName);
                    }
                });
                
                lockSystem.lockQueue = [];
                lockSystem.updateLockQueueDisplay();
                lockSystem.updateAIDisplay();
                
                lockSystem.log('warning', `Queue cleared: ${cleared} requests cancelled`);
            }
        }

        function initiateHandoff() {
            // Auto-select AIs with available handoff opportunities
            const activeAIs = Array.from(lockSystem.ais.entries())
                .filter(([name, ai]) => ai.locksHeld.size > 0);
            
            if (activeAIs.length < 2) {
                alert('Need at least 2 AIs with held locks for handoff');
                return;
            }
            
            const [fromName, fromAI] = activeAIs[0];
            const [toName, toAI] = activeAIs[1];
            const regions = Array.from(fromAI.locksHeld).slice(0, 1); // Transfer one region
            
            lockSystem.initiateHandoff(fromName, toName, regions);
        }

        function abortHandoff() {
            if (lockSystem.handoffQueue.length > 0) {
                const handoff = lockSystem.handoffQueue[0];
                lockSystem.abortHandoff(handoff);
            } else {
                alert('No active handoffs to abort');
            }
        }

        function sendTestMessage() {
            const fromAI = prompt('From AI:', 'Junior');
            const toAI = prompt('To AI:', 'Claude');
            const msgType = prompt('Message type:', 'TEST_MESSAGE');
            
            if (fromAI && toAI && msgType) {
                lockSystem.sendMessage(fromAI, toAI, msgType, {
                    test: true,
                    timestamp: Date.now()
                });
            }
        }

        function clearComms() {
            lockSystem.communications = [];
            lockSystem.updateCommunicationDisplay();
            lockSystem.log('info', 'Communication log cleared');
        }

        // Auto-update displays
        setInterval(() => {
            lockSystem.updateAIDisplay();
            lockSystem.updateMemoryDisplay();
            lockSystem.updateLockMatrix();
        }, 2000);

        // Update performance metrics
        setInterval(() => {
            document.getElementById('avgWait').textContent = 
                lockSystem.lockQueue.length > 0 ? 
                `${(lockSystem.lockQueue.reduce((sum, req) => sum + (Date.now() - req.requestTime), 0) / lockSystem.lockQueue.length / 1000).toFixed(1)}s` : 
                '0s';
            
            document.getElementById('totalMessages').textContent = lockSystem.communications.length;
            
            const successRate = lockSystem.stats.totalHandoffs > 0 ? 
                (lockSystem.stats.successfulHandoffs / lockSystem.stats.totalHandoffs * 100).toFixed(1) : '100';
            document.getElementById('successRate').textContent = `${successRate}%`;
            
            document.getElementById('avgResponse').textContent = `${(lockSystem.stats.avgHandoffTime / 1000).toFixed(1)}s`;
            
            document.getElementById('conflicts').textContent = lockSystem.stats.lockConflicts;
            
            document.getElementById('timeouts').textContent = lockSystem.lockQueue.filter(req => 
                Date.now() - req.requestTime > req.timeout).length;
        }, 1000);

        lockSystem.log('success', '🚀 Multi-AI Lock & Handoff System fully operational');
    </script>
</body>
</html>