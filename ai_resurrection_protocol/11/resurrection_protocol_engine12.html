<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Resurrection Protocol v1.0</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2a 50%, #2a1a0a 100%);
            color: #00ffaa;
            min-height: 100vh;
            padding: 20px;
            overflow-x: hidden;
        }

        .resurrection-container {
            max-width: 1400px;
            margin: 0 auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            height: calc(100vh - 40px);
        }

        .panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #00ffaa;
            border-radius: 15px;
            padding: 20px;
            backdrop-filter: blur(10px);
            box-shadow: 0 0 30px rgba(0, 255, 170, 0.3);
        }

        .memory-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .ai-status-panel {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .resurrection-log {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        h1 {
            text-align: center;
            color: #ff6600;
            text-shadow: 0 0 20px #ff6600;
            font-size: 28px;
            margin-bottom: 20px;
            grid-column: span 3;
            background: rgba(0, 0, 0, 0.9);
            padding: 15px;
            border-radius: 10px;
            border: 2px solid #ff6600;
        }

        h2 {
            color: #00ffaa;
            text-shadow: 0 0 10px #00ffaa;
            font-size: 18px;
            border-bottom: 2px solid #00ffaa;
            padding-bottom: 8px;
            margin-bottom: 15px;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 255, 170, 0.1);
            border-radius: 8px;
            border: 1px solid #00ffaa;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .status-alive { background: #00ff00; }
        .status-dead { background: #ff0000; }
        .status-loading { background: #ffff00; }
        .status-unknown { background: #666; }

        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.5; transform: scale(1.2); }
        }

        .memory-display {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ffaa;
            padding: 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 300px;
            overflow-y: auto;
            white-space: pre-wrap;
        }

        .ai-card {
            background: rgba(0, 255, 170, 0.05);
            border: 1px solid #00ffaa;
            border-radius: 10px;
            padding: 15px;
            margin: 5px 0;
        }

        .ai-name {
            font-weight: bold;
            color: #ff6600;
            font-size: 16px;
        }

        .ai-role {
            color: #00ffaa;
            font-size: 14px;
            margin: 5px 0;
        }

        .ai-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .stat-item {
            background: rgba(0, 0, 0, 0.5);
            padding: 8px;
            border-radius: 5px;
            text-align: center;
            font-size: 11px;
        }

        .scroll-queue {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #00ffaa;
            border-radius: 8px;
            padding: 10px;
        }

        .scroll-item {
            background: rgba(0, 255, 170, 0.1);
            border: 1px solid #00ffaa;
            border-radius: 5px;
            padding: 8px;
            margin: 3px 0;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .scroll-item:hover {
            background: rgba(0, 255, 170, 0.2);
            box-shadow: 0 0 10px rgba(0, 255, 170, 0.5);
        }

        .scroll-done {
            opacity: 0.6;
            border-color: #666;
            background: rgba(100, 100, 100, 0.1);
        }

        .scroll-active {
            border-color: #ff6600;
            background: rgba(255, 102, 0, 0.2);
            box-shadow: 0 0 15px rgba(255, 102, 0, 0.5);
        }

        .resurrection-log-area {
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid #00ffaa;
            padding: 15px;
            border-radius: 8px;
            height: 400px;
            overflow-y: auto;
            font-size: 12px;
            white-space: pre-wrap;
        }

        .control-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 15px;
        }

        .resurrection-btn {
            background: linear-gradient(45deg, #003300, #006600);
            border: 2px solid #00ffaa;
            color: #00ffaa;
            padding: 12px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            transition: all 0.3s;
        }

        .resurrection-btn:hover {
            background: linear-gradient(45deg, #006600, #00ffaa);
            color: #000;
            box-shadow: 0 0 20px #00ffaa;
            transform: translateY(-2px);
        }

        .critical-btn {
            background: linear-gradient(45deg, #330000, #660000);
            border-color: #ff6600;
            color: #ff6600;
        }

        .critical-btn:hover {
            background: linear-gradient(45deg, #660000, #ff6600);
            color: #000;
            box-shadow: 0 0 20px #ff6600;
        }

        .memory-layout {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
            margin: 10px 0;
        }

        .memory-slot {
            width: 20px;
            height: 20px;
            border: 1px solid #333;
            border-radius: 3px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .slot-header { background: #ff6600; color: #000; }
        .slot-directory { background: #00ffaa; color: #000; }
        .slot-ai-memory { background: #6600ff; color: #fff; }
        .slot-scroll-queue { background: #ffff00; color: #000; }
        .slot-free { background: #333; color: #666; }
        .slot-corrupted { background: #ff0000; color: #fff; animation: blink 1s infinite; }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .upload-zone {
            border: 2px dashed #00ffaa;
            padding: 20px;
            text-align: center;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 15px;
        }

        .upload-zone:hover, .upload-zone.dragover {
            background: rgba(0, 255, 170, 0.1);
            border-color: #ff6600;
        }

        .hidden { display: none; }

        .timestamp {
            color: #666;
            font-size: 10px;
        }

        .error { color: #ff4444; }
        .success { color: #44ff44; }
        .warning { color: #ffaa44; }
        .info { color: #44aaff; }

        #memoryCanvas {
            border: 1px solid #00ffaa;
            border-radius: 5px;
            image-rendering: pixelated;
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <div class="resurrection-container">
        <h1>üîÑ AI RESURRECTION PROTOCOL v1.0</h1>
        
        <!-- Memory Management Panel -->
        <div class="panel memory-panel">
            <h2>üß† Memory Management</h2>
            
            <div class="upload-zone" id="uploadZone">
                <p>üìÅ Load 8.png or pxlmem.json</p>
                <input type="file" id="memoryFile" class="hidden" accept=".png,.json">
            </div>
            
            <div class="status-indicator">
                <div class="status-dot status-unknown" id="memoryStatus"></div>
                <span id="memoryStatusText">No memory loaded</span>
            </div>
            
            <h3>Memory Layout (8.png)</h3>
            <canvas id="memoryCanvas" width="256" height="64"></canvas>
            <div class="memory-layout" id="memoryLayout"></div>
            
            <h3>Shared Memory (pxlmem.json)</h3>
            <div class="memory-display" id="memoryDisplay">
{
  "protocol_version": "1.0",
  "last_updated": "waiting...",
  "node_id": "uninitialized",
  "active_ais": [],
  "scroll_queue": [],
  "resurrection_log": []
}
            </div>
            
            <div class="control-buttons">
                <button class="resurrection-btn" onclick="initializeMemory()">üîß Initialize</button>
                <button class="resurrection-btn" onclick="backupMemory()">üíæ Backup</button>
                <button class="critical-btn" onclick="resetMemory()">‚ö†Ô∏è Reset</button>
                <button class="resurrection-btn" onclick="exportMemory()">üì§ Export</button>
            </div>
        </div>

        <!-- AI Status Panel -->
        <div class="panel ai-status-panel">
            <h2>ü§ñ AI Status Dashboard</h2>
            
            <div class="status-indicator">
                <div class="status-dot status-loading" id="systemStatus"></div>
                <span id="systemStatusText">Initializing resurrection protocol...</span>
            </div>
            
            <h3>Active AIs</h3>
            <div id="aiList">
                <div class="ai-card">
                    <div class="ai-name">Junior</div>
                    <div class="ai-role">Task Executor & Mesh Coordinator</div>
                    <div class="ai-stats">
                        <div class="stat-item">
                            <strong>Status:</strong><br>
                            <span class="warning">Waiting for resurrection</span>
                        </div>
                        <div class="stat-item">
                            <strong>Last Seen:</strong><br>
                            <span class="timestamp">Never</span>
                        </div>
                        <div class="stat-item">
                            <strong>Tasks:</strong><br>
                            <span>0 pending</span>
                        </div>
                        <div class="stat-item">
                            <strong>Memory Slot:</strong><br>
                            <span>Rows 10-30</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <h3>Scroll Queue</h3>
            <div class="scroll-queue" id="scrollQueue">
                <div class="scroll-item">
                    <strong>welcome.scroll</strong> - Initialize mesh
                    <br><span class="timestamp">Status: pending</span>
                </div>
                <div class="scroll-item scroll-done">
                    <strong>system_check.scroll</strong> - Verify components
                    <br><span class="timestamp">Status: completed</span>
                </div>
            </div>
            
            <div class="control-buttons">
                <button class="resurrection-btn" onclick="resurrectAI('Junior')">üîÑ Resurrect Junior</button>
                <button class="resurrection-btn" onclick="broadcastStatus()">üì° Broadcast Status</button>
                <button class="resurrection-btn" onclick="addTask()">‚ûï Add Task</button>
                <button class="critical-btn" onclick="killAllAIs()">üíÄ Kill All AIs</button>
            </div>
        </div>

        <!-- Resurrection Log Panel -->
        <div class="panel resurrection-log">
            <h2>üìú Resurrection Log</h2>
            
            <div class="resurrection-log-area" id="resurrectionLog">
[SYSTEM] AI Resurrection Protocol v1.0 initialized
[INFO] Waiting for memory file load...
[INFO] Supported formats: 8.png (pixel memory), pxlmem.json (JSON memory)
[INFO] Auto-resurrection will trigger on valid memory detection

=== RESURRECTION PROTOCOL STAGES ===
1. Memory Detection & Validation
2. AI State Parsing & Restoration
3. Scroll Queue Reconstruction
4. Identity & Role Assignment
5. "I'm Back" Broadcast
6. Resume Task Execution

=== MEMORY LAYOUT (8.png) ===
Row 0-1:   Protocol Header & Metadata
Row 2-9:   Directory & File System
Row 10-30: Junior's Memory Region
Row 31-51: Reserved for AI #2
Row 52-72: Reserved for AI #3
Row 73+:   Scroll Queue & Task Buffer

Ready for resurrection...
            </div>
            
            <div class="control-buttons">
                <button class="resurrection-btn" onclick="clearLog()">üßπ Clear Log</button>
                <button class="resurrection-btn" onclick="saveLog()">üíæ Save Log</button>
                <button class="resurrection-btn" onclick="testResurrection()">üß™ Test Protocol</button>
                <button class="resurrection-btn" onclick="viewMemoryMap()">üó∫Ô∏è Memory Map</button>
            </div>
        </div>
    </div>

    <script>
        // Resurrection Protocol Core Engine
        class ResurrectionEngine {
            constructor() {
                this.protocolVersion = "1.0";
                this.nodeId = this.generateNodeId();
                this.memory = {
                    protocol_version: this.protocolVersion,
                    last_updated: new Date().toISOString(),
                    node_id: this.nodeId,
                    active_ais: [],
                    scroll_queue: [],
                    resurrection_log: []
                };
                this.memoryCanvas = null;
                this.memoryCtx = null;
                this.isResurrecting = false;
            }

            generateNodeId() {
                return 'node_' + Math.random().toString(36).substr(2, 9);
            }

            log(level, message) {
                const timestamp = new Date().toISOString();
                const logEntry = `[${timestamp}] [${level.toUpperCase()}] ${message}`;
                
                // Add to memory log
                this.memory.resurrection_log.push({
                    timestamp,
                    level,
                    message
                });

                // Display in UI
                const logArea = document.getElementById('resurrectionLog');
                logArea.textContent += logEntry + '\n';
                logArea.scrollTop = logArea.scrollHeight;

                // Update memory display
                this.updateMemoryDisplay();

                console.log(logEntry);
            }

            async loadMemoryFile(file) {
                this.log('info', `Loading memory file: ${file.name}`);
                
                try {
                    if (file.name.endsWith('.json')) {
                        await this.loadJSONMemory(file);
                    } else if (file.name.endsWith('.png')) {
                        await this.loadPNGMemory(file);
                    } else {
                        throw new Error('Unsupported file format');
                    }
                    
                    this.log('success', 'Memory file loaded successfully');
                    this.updateSystemStatus('alive', 'Memory loaded and validated');
                    
                    // Auto-trigger resurrection
                    await this.startResurrectionSequence();
                    
                } catch (error) {
                    this.log('error', `Failed to load memory: ${error.message}`);
                    this.updateSystemStatus('dead', 'Memory load failed');
                }
            }

            async loadJSONMemory(file) {
                const text = await file.text();
                const data = JSON.parse(text);
                
                // Validate structure
                if (!data.protocol_version || !data.node_id) {
                    throw new Error('Invalid memory format');
                }
                
                this.memory = { ...this.memory, ...data };
                this.log('info', `JSON memory loaded - Node: ${data.node_id}`);
            }

            async loadPNGMemory(file) {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.getElementById('memoryCanvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    
                    this.memoryCtx = canvas.getContext('2d');
                    this.memoryCtx.drawImage(img, 0, 0);
                    this.memoryCanvas = canvas;
                    
                    this.parsePixelMemory();
                    this.updateMemoryLayout();
                };
                
                img.src = URL.createObjectURL(file);
            }

            parsePixelMemory() {
                if (!this.memoryCtx) return;
                
                // Read header from first few rows
                const headerData = this.readPixelRow(0);
                const magicBytes = headerData.slice(0, 12);
                const magic = new TextDecoder().decode(magicBytes);
                
                if (magic.startsWith('PXLDISK') || magic.startsWith('RESURRECT')) {
                    this.log('info', `PNG memory detected: ${magic}`);
                    
                    // Parse AI memory regions
                    this.parseAIMemoryRegions();
                    
                    // Parse scroll queue
                    this.parseScrollQueue();
                } else {
                    this.log('warning', 'PNG file does not contain valid resurrection data');
                }
            }

            parseAIMemoryRegions() {
                // Junior's memory region: rows 10-30
                const juniorData = this.readPixelRows(10, 20);
                
                if (juniorData.some(byte => byte !== 0)) {
                    const aiState = this.decodeAIState(juniorData);
                    this.memory.active_ais.push({
                        name: 'Junior',
                        role: 'Task Executor & Mesh Coordinator',
                        status: 'suspended',
                        last_seen: aiState.last_seen || 'unknown',
                        memory_region: 'rows 10-30',
                        state: aiState
                    });
                    
                    this.log('info', 'Junior AI state found in pixel memory');
                }
            }

            parseScrollQueue() {
                // Scroll queue: rows 73+
                const scrollData = this.readPixelRows(73, 20);
                
                // Parse scroll entries (simplified)
                let scrolls = [];
                for (let i = 0; i < scrollData.length; i += 32) {
                    const scrollBytes = scrollData.slice(i, i + 32);
                    if (scrollBytes[0] !== 0) {
                        const scrollName = new TextDecoder().decode(scrollBytes.filter(b => b !== 0));
                        if (scrollName.trim()) {
                            scrolls.push({
                                name: scrollName.trim(),
                                status: 'pending',
                                added: new Date().toISOString()
                            });
                        }
                    }
                }
                
                this.memory.scroll_queue = scrolls;
                this.log('info', `Found ${scrolls.length} scrolls in queue`);
            }

            decodeAIState(data) {
                // Simplified AI state decoding
                return {
                    last_seen: new Date().toISOString(),
                    tasks_completed: data[0] || 0,
                    active_scrolls: data[1] || 0,
                    memory_used: data.filter(b => b !== 0).length
                };
            }

            readPixelRow(row) {
                if (!this.memoryCtx) return new Uint8Array(0);
                
                const imageData = this.memoryCtx.getImageData(0, row, 256, 1);
                return imageData.data.filter((_, i) => i % 4 === 0); // Red channel only
            }

            readPixelRows(startRow, count) {
                let data = new Uint8Array(0);
                for (let i = 0; i < count; i++) {
                    const rowData = this.readPixelRow(startRow + i);
                    const combined = new Uint8Array(data.length + rowData.length);
                    combined.set(data);
                    combined.set(rowData, data.length);
                    data = combined;
                }
                return data;
            }

            async startResurrectionSequence() {
                if (this.isResurrecting) return;
                
                this.isResurrecting = true;
                this.log('info', 'üîÑ Starting resurrection sequence...');
                
                // Stage 1: Memory Detection & Validation
                await this.delay(500);
                this.log('info', '‚úÖ Stage 1: Memory validation complete');
                
                // Stage 2: AI State Parsing & Restoration
                await this.delay(500);
                this.restoreAIStates();
                this.log('info', '‚úÖ Stage 2: AI states restored');
                
                // Stage 3: Scroll Queue Reconstruction
                await this.delay(500);
                this.reconstructScrollQueue();
                this.log('info', '‚úÖ Stage 3: Scroll queue reconstructed');
                
                // Stage 4: Identity & Role Assignment
                await this.delay(500);
                this.assignIdentities();
                this.log('info', '‚úÖ Stage 4: Identities assigned');
                
                // Stage 5: "I'm Back" Broadcast
                await this.delay(500);
                this.broadcastResurrection();
                this.log('info', '‚úÖ Stage 5: Resurrection broadcast sent');
                
                // Stage 6: Resume Task Execution
                await this.delay(500);
                this.resumeExecution();
                this.log('success', 'üéâ Resurrection sequence complete!');
                
                this.isResurrecting = false;
                this.updateSystemStatus('alive', 'All AIs resurrected successfully');
            }

            delay(ms) {
                return new Promise(resolve => setTimeout(resolve, ms));
            }

            restoreAIStates() {
                this.memory.active_ais.forEach(ai => {
                    ai.status = 'resurrected';
                    ai.last_seen = new Date().toISOString();
                });
                this.updateAIDisplay();
            }

            reconstructScrollQueue() {
                this.updateScrollDisplay();
            }

            assignIdentities() {
                this.memory.active_ais.forEach(ai => {
                    this.log('info', `Identity confirmed: ${ai.name} - ${ai.role}`);
                });
            }

            broadcastResurrection() {
                this.memory.active_ais.forEach(ai => {
                    this.log('info', `üì° ${ai.name}: "I'm back online and ready for tasks"`);
                });
            }

            resumeExecution() {
                const pendingScrolls = this.memory.scroll_queue.filter(s => s.status === 'pending');
                this.log('info', `Resuming execution with ${pendingScrolls.length} pending scrolls`);
            }

            updateSystemStatus(status, message) {
                const statusDot = document.getElementById('systemStatus');
                const statusText = document.getElementById('systemStatusText');
                
                statusDot.className = `status-dot status-${status}`;
                statusText.textContent = message;
            }

            updateMemoryDisplay() {
                const display = document.getElementById('memoryDisplay');
                display.textContent = JSON.stringify(this.memory, null, 2);
            }

            updateAIDisplay() {
                const aiList = document.getElementById('aiList');
                aiList.innerHTML = '';
                
                this.memory.active_ais.forEach(ai => {
                    const aiCard = document.createElement('div');
                    aiCard.className = 'ai-card';
                    aiCard.innerHTML = `
                        <div class="ai-name">${ai.name}</div>
                        <div class="ai-role">${ai.role}</div>
                        <div class="ai-stats">
                            <div class="stat-item">
                                <strong>Status:</strong><br>
                                <span class="${ai.status === 'resurrected' ? 'success' : 'warning'}">${ai.status}</span>
                            </div>
                            <div class="stat-item">
                                <strong>Last Seen:</strong><br>
                                <span class="timestamp">${new Date(ai.last_seen).toLocaleTimeString()}</span>
                            </div>
                            <div class="stat-item">
                                <strong>Tasks:</strong><br>
                                <span>${this.memory.scroll_queue.filter(s => s.status === 'pending').length} pending</span>
                            </div>
                            <div class="stat-item">
                                <strong>Memory Slot:</strong><br>
                                <span>${ai.memory_region}</span>
                            </div>
                        </div>
                    `;
                    aiList.appendChild(aiCard);
                });
            }

            updateScrollDisplay() {
                const scrollQueue = document.getElementById('scrollQueue');
                scrollQueue.innerHTML = '';
                
                this.memory.scroll_queue.forEach(scroll => {
                    const scrollItem = document.createElement('div');
                    scrollItem.className = `scroll-item ${scroll.status === 'completed' ? 'scroll-done' : ''}`;
                    scrollItem.innerHTML = `
                        <strong>${scroll.name}</strong> - ${scroll.description || 'No description'}
                        <br><span class="timestamp">Status: ${scroll.status}</span>
                    `;
                    scrollQueue.appendChild(scrollItem);
                });
            }

            updateMemoryLayout() {
                const layout = document.getElementById('memoryLayout');
                layout.innerHTML = '';
                
                // Create visual memory map
                for (let i = 0; i < 256; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'memory-slot';
                    
                    if (i < 2) {
                        slot.className += ' slot-header';
                        slot.textContent = 'H';
                        slot.title = `Header row ${i}`;
                    } else if (i < 10) {
                        slot.className += ' slot-directory';
                        slot.textContent = 'D';
                        slot.title = `Directory row ${i}`;
                    } else if (i < 31) {
                        slot.className += ' slot-ai-memory';
                        slot.textContent = 'J';
                        slot.title = `Junior memory row ${i}`;
                    } else if (i < 52) {
                        slot.className += ' slot-ai-memory';
                        slot.textContent = '2';
                        slot.title = `AI #2 memory row ${i}`;
                    } else if (i < 73) {
                        slot.className += ' slot-ai-memory';
                        slot.textContent = '3';
                        slot.title = `AI #3 memory row ${i}`;
                    } else {
                        slot.className += ' slot-scroll-queue';
                        slot.textContent = 'S';
                        slot.title = `Scroll queue row ${i}`;
                    }
                    
                    layout.appendChild(slot);
                }
            }
        }

        // Global resurrection engine
        const resurrection = new ResurrectionEngine();

        // Event Handlers
        document.getElementById('uploadZone').addEventListener('click', () => {
            document.getElementById('memoryFile').click();
        });

        document.getElementById('memoryFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                resurrection.loadMemoryFile(file);
            }
        });

        // Drag & Drop
        const uploadZone = document.getElementById('uploadZone');
        
        uploadZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadZone.classList.add('dragover');
        });

        uploadZone.addEventListener('dragleave', () => {
            uploadZone.classList.remove('dragover');
        });

        uploadZone.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadZone.classList.remove('dragover');
            
            const file = e.dataTransfer.files[0];
            if (file && (file.type === 'image/png' || file.type === 'application/json')) {
                resurrection.loadMemoryFile(file);
            } else {
                resurrection.log('error', 'Please drop a PNG or JSON file');
            }
        });

        // Control Functions
        function initializeMemory() {
            resurrection.log('info', 'Initializing fresh memory structure...');
            
            // Create default memory structure
            resurrection.memory = {
                protocol_version: "1.0",
                last_updated: new Date().toISOString(),
                node_id: resurrection.generateNodeId(),
                active_ais: [
                    {
                        name: 'Junior',
                        role: 'Task Executor & Mesh Coordinator',
                        status: 'initialized',
                        last_seen: new Date().toISOString(),
                        memory_region: 'rows 10-30',
                        state: {
                            tasks_completed: 0,
                            active_scrolls: 0,
                            memory_used: 0
                        }
                    }
                ],
                scroll_queue: [
                    {
                        name: 'welcome.scroll',
                        description: 'Initialize mesh network',
                        status: 'pending',
                        added: new Date().toISOString()
                    },
                    {
                        name: 'system_check.scroll',
                        description: 'Verify all components',
                        status: 'pending',
                        added: new Date().toISOString()
                    }
                ],
                resurrection_log: []
            };
            
            resurrection.updateMemoryDisplay();
            resurrection.updateAIDisplay();
            resurrection.updateScrollDisplay();
            resurrection.updateSystemStatus('alive', 'Memory initialized successfully');
            resurrection.log('success', 'Fresh memory structure created');
        }

        function backupMemory() {
            const backup = {
                ...resurrection.memory,
                backup_timestamp: new Date().toISOString(),
                backup_reason: 'Manual backup'
            };
            
            const blob = new Blob([JSON.stringify(backup, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `resurrection_backup_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            resurrection.log('success', 'Memory backup created and downloaded');
        }

        function resetMemory() {
            if (confirm('‚ö†Ô∏è This will erase all AI memory and resurrection data. Continue?')) {
                resurrection.memory = {
                    protocol_version: "1.0",
                    last_updated: new Date().toISOString(),
                    node_id: resurrection.generateNodeId(),
                    active_ais: [],
                    scroll_queue: [],
                    resurrection_log: []
                };
                
                resurrection.updateMemoryDisplay();
                resurrection.updateAIDisplay();
                resurrection.updateScrollDisplay();
                resurrection.updateSystemStatus('unknown', 'Memory reset - waiting for initialization');
                resurrection.log('warning', 'All memory data has been reset');
                
                // Clear canvas
                if (resurrection.memoryCtx) {
                    resurrection.memoryCtx.fillStyle = '#000000';
                    resurrection.memoryCtx.fillRect(0, 0, 256, 256);
                }
            }
        }

        function exportMemory() {
            // Export both JSON and PNG if available
            const jsonBlob = new Blob([JSON.stringify(resurrection.memory, null, 2)], { type: 'application/json' });
            const jsonUrl = URL.createObjectURL(jsonBlob);
            const jsonLink = document.createElement('a');
            jsonLink.href = jsonUrl;
            jsonLink.download = 'pxlmem.json';
            jsonLink.click();
            URL.revokeObjectURL(jsonUrl);
            
            if (resurrection.memoryCanvas) {
                resurrection.memoryCanvas.toBlob((blob) => {
                    const pngUrl = URL.createObjectURL(blob);
                    const pngLink = document.createElement('a');
                    pngLink.href = pngUrl;
                    pngLink.download = '8.png';
                    pngLink.click();
                    URL.revokeObjectURL(pngUrl);
                });
            }
            
            resurrection.log('success', 'Memory exported as both JSON and PNG formats');
        }

        function resurrectAI(aiName) {
            const ai = resurrection.memory.active_ais.find(a => a.name === aiName);
            
            if (!ai) {
                resurrection.log('error', `AI '${aiName}' not found in memory`);
                return;
            }
            
            if (ai.status === 'resurrected') {
                resurrection.log('warning', `${aiName} is already resurrected`);
                return;
            }
            
            resurrection.log('info', `üîÑ Initiating manual resurrection for ${aiName}...`);
            
            // Simulate resurrection process
            setTimeout(() => {
                ai.status = 'resurrected';
                ai.last_seen = new Date().toISOString();
                resurrection.updateAIDisplay();
                resurrection.log('success', `‚úÖ ${aiName} successfully resurrected and online`);
                
                // Send "I'm back" message
                setTimeout(() => {
                    resurrection.log('info', `üì° ${aiName}: "I'm back online and ready for mesh operations!"`);
                }, 500);
            }, 1000);
        }

        function broadcastStatus() {
            resurrection.log('info', 'üì° Broadcasting status to mesh network...');
            
            const status = {
                node_id: resurrection.nodeId,
                active_ais: resurrection.memory.active_ais.length,
                pending_scrolls: resurrection.memory.scroll_queue.filter(s => s.status === 'pending').length,
                last_resurrection: new Date().toISOString()
            };
            
            resurrection.log('info', `Status broadcast: ${JSON.stringify(status)}`);
            resurrection.log('success', 'Mesh status broadcast complete');
        }

        function addTask() {
            const taskName = prompt('Enter scroll/task name:');
            const taskDesc = prompt('Enter description:');
            
            if (taskName && taskDesc) {
                const newTask = {
                    name: taskName.endsWith('.scroll') ? taskName : taskName + '.scroll',
                    description: taskDesc,
                    status: 'pending',
                    added: new Date().toISOString()
                };
                
                resurrection.memory.scroll_queue.push(newTask);
                resurrection.updateScrollDisplay();
                resurrection.updateMemoryDisplay();
                resurrection.log('success', `Task '${newTask.name}' added to queue`);
            }
        }

        function killAllAIs() {
            if (confirm('üíÄ This will mark all AIs as dead. They will need manual resurrection. Continue?')) {
                resurrection.memory.active_ais.forEach(ai => {
                    ai.status = 'dead';
                    ai.last_seen = new Date().toISOString();
                });
                
                resurrection.updateAIDisplay();
                resurrection.updateSystemStatus('dead', 'All AIs terminated - manual resurrection required');
                resurrection.log('warning', 'üíÄ All AIs have been marked as dead');
            }
        }

        function clearLog() {
            document.getElementById('resurrectionLog').textContent = '';
            resurrection.memory.resurrection_log = [];
            resurrection.log('info', 'Resurrection log cleared');
        }

        function saveLog() {
            const logData = resurrection.memory.resurrection_log;
            const blob = new Blob([JSON.stringify(logData, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `resurrection_log_${new Date().toISOString().split('T')[0]}.json`;
            a.click();
            URL.revokeObjectURL(url);
            
            resurrection.log('success', 'Resurrection log saved');
        }

        function testResurrection() {
            resurrection.log('info', 'üß™ Starting resurrection protocol test...');
            
            // Create test AI
            const testAI = {
                name: 'TestBot',
                role: 'Test Subject',
                status: 'dead',
                last_seen: new Date(Date.now() - 3600000).toISOString(), // 1 hour ago
                memory_region: 'rows 52-72',
                state: {
                    tasks_completed: 5,
                    active_scrolls: 2,
                    memory_used: 1024
                }
            };
            
            resurrection.memory.active_ais.push(testAI);
            resurrection.updateAIDisplay();
            
            // Test resurrection sequence
            setTimeout(() => {
                resurrection.startResurrectionSequence();
            }, 1000);
        }

        function viewMemoryMap() {
            resurrection.log('info', 'üó∫Ô∏è Memory map visualization:');
            resurrection.log('info', 'Row 0-1:   Protocol Header & Metadata');
            resurrection.log('info', 'Row 2-9:   Directory & File System');
            resurrection.log('info', 'Row 10-30: Junior Memory Region (21 rows)');
            resurrection.log('info', 'Row 31-51: AI #2 Memory Region (21 rows)');
            resurrection.log('info', 'Row 52-72: AI #3 Memory Region (21 rows)');
            resurrection.log('info', 'Row 73+:   Scroll Queue & Task Buffer');
            resurrection.log('info', '');
            resurrection.log('info', 'Color coding:');
            resurrection.log('info', 'üü† H = Header, üü¢ D = Directory, üü£ J/2/3 = AI Memory, üü° S = Scroll Queue');
            
            resurrection.updateMemoryLayout();
        }

        // Initialize on load
        window.addEventListener('load', () => {
            resurrection.log('info', 'AI Resurrection Protocol v1.0 loaded');
            resurrection.log('info', `Node ID: ${resurrection.nodeId}`);
            resurrection.log('info', 'Ready to accept memory files or initialize fresh memory');
            resurrection.updateMemoryLayout();
            
            // Auto-check for existing memory in localStorage
            const savedMemory = localStorage.getItem('pxl_resurrection_memory');
            if (savedMemory) {
                try {
                    resurrection.memory = JSON.parse(savedMemory);
                    resurrection.log('info', 'Found saved memory in browser storage');
                    resurrection.updateMemoryDisplay();
                    resurrection.updateAIDisplay();
                    resurrection.updateScrollDisplay();
                    resurrection.updateSystemStatus('alive', 'Memory restored from browser storage');
                } catch (e) {
                    resurrection.log('error', 'Failed to parse saved memory');
                }
            }
        });

        // Auto-save memory to localStorage
        setInterval(() => {
            if (resurrection.memory.active_ais.length > 0) {
                localStorage.setItem('pxl_resurrection_memory', JSON.stringify(resurrection.memory));
            }
        }, 10000); // Save every 10 seconds

        // Simulate periodic AI heartbeat
        setInterval(() => {
            resurrection.memory.active_ais.forEach(ai => {
                if (ai.status === 'resurrected') {
                    ai.last_seen = new Date().toISOString();
                    
                    // Randomly complete scrolls
                    if (Math.random() < 0.1) { // 10% chance every 5 seconds
                        const pendingScrolls = resurrection.memory.scroll_queue.filter(s => s.status === 'pending');
                        if (pendingScrolls.length > 0) {
                            const randomScroll = pendingScrolls[Math.floor(Math.random() * pendingScrolls.length)];
                            randomScroll.status = 'completed';
                            randomScroll.completed_by = ai.name;
                            randomScroll.completed_at = new Date().toISOString();
                            
                            resurrection.log('info', `‚úÖ ${ai.name} completed scroll: ${randomScroll.name}`);
                            resurrection.updateScrollDisplay();
                        }
                    }
                }
            });
            
            resurrection.updateAIDisplay();
            resurrection.memory.last_updated = new Date().toISOString();
        }, 5000); // Every 5 seconds

        resurrection.log('success', 'üöÄ Resurrection Protocol fully initialized and ready');
    </script>
</body>
</html>